<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Fraction fields · Nemo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>Nemo.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="about.html">About Nemo</a></li><li><a class="toctext" href="types.html">Types in Nemo</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in Nemo</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="integer.html">Integers</a></li><li><a class="toctext" href="polynomial.html">Univariate polynomials</a></li><li><a class="toctext" href="mpolynomial.html">Multivariate polynomials</a></li><li><a class="toctext" href="series.html">Power series and Laurent series</a></li><li><a class="toctext" href="puiseux.html">Puiseux series</a></li><li><a class="toctext" href="residue.html">Residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li class="current"><a class="toctext" href="fraction.html">Fraction fields</a><ul class="internal"><li><a class="toctext" href="#Fraction-functionality-1">Fraction functionality</a></li><li><a class="toctext" href="#Rational-enumeration-1">Rational enumeration</a></li></ul></li><li><a class="toctext" href="rational.html">Rationals</a></li><li><a class="toctext" href="arb.html">Real balls</a></li><li><a class="toctext" href="acb.html">Complex balls</a></li><li><a class="toctext" href="gfp.html">Galois fields</a></li><li><a class="toctext" href="finitefield.html">Finite fields</a></li><li><a class="toctext" href="ff_embedding.html">Finite field embeddings</a></li><li><a class="toctext" href="numberfield.html">Number field arithmetic</a></li><li><a class="toctext" href="padic.html">Padics</a></li><li><a class="toctext" href="qadic.html">Qadics</a></li></ul></li><li><a class="toctext" href="matrix.html">Matrices</a></li><li><a class="toctext" href="factor.html">Factorisation</a></li></ul></nav><article id="docs"><header><nav><ul><li>Fields</li><li><a href="fraction.html">Fraction fields</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/fraction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Fraction fields</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Fraction-fields-1" id="Fraction-fields-1">Fraction fields</a></h1><p>Nemo allows the creation of fraction fields over any ring <span>$R$</span>. We don't require <span>$R$</span> to be an integral domain, however no attempt is made to deal with the general case. Two fractions <span>$a/b$</span> and <span>$c/d$</span> are equal in Nemo iff <span>$ad = bc$</span>. Thus, in practice, a greatest common divisor function is currently required for the ring <span>$R$</span>.</p><p>In order to make the representation <span>$a/b$</span> unique for printing, we have a notion of canonical unit for elements of a ring <span>$R$</span>. When canonicalising <span>$a/b$</span>, each of the elements <span>$a$</span> and <span>$b$</span> is first divided by the canonical unit of <span>$b$</span>.</p><p>The <code>canonical_unit</code> function is defined for elements of every Nemo ring. It must have the properties</p><pre><code class="language-none">canonical_unit(u) == u
canonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)</code></pre><p>for any unit <span>$u$</span> of the ring in question, and <span>$a$</span> and <span>$b$</span> arbitrary elements of the ring.</p><p>For example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.</p><p>The canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.</p><p>There are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.</p><p>The following table shows each of the fraction types available in Nemo, the base ring <span>$R$</span>, and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).</p><table><tbody><tr><th>Base ring</th><th>Library</th><th>Element type</th><th>Parent type</th></tr><tr><td>Generic ring <span>$R$</span></td><td>AbstractAlgebra.jl</td><td><code>Generic.Frac{T}</code></td><td><code>Generic.FracField{T}</code></td></tr><tr><td><span>$\mathbb{Z}$</span></td><td>Flint</td><td><code>fmpq</code></td><td><code>FlintRationalField</code></td></tr></tbody></table><p>All fraction element types belong to the abstract type <code>FracElem</code> and all of the fraction field types belong to the abstract type <code>FracField</code>. This enables one to write generic functions that can accept any Nemo fraction type.</p><h2><a class="nav-anchor" href="#Fraction-functionality-1" id="Fraction-functionality-1">Fraction functionality</a></h2><p>All fraction types in Nemo implement the AbstractAlgebra.jl fraction field interface:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/fraction_fields.html">https://nemocas.github.io/AbstractAlgebra.jl/fraction_fields.html</a></p><p>In addition, generic fractions fields are implemented in AbstractAlgebra.jl, with the following functionality:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/fraction.html">https://nemocas.github.io/AbstractAlgebra.jl/fraction.html</a></p><p>All fraction types in Nemo also implement this generic functionality.</p><h3><a class="nav-anchor" href="#Basic-manipulation-1" id="Basic-manipulation-1">Basic manipulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.abs-Tuple{fmpq}" id="Base.abs-Tuple{fmpq}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">abs(a::fmpq)</code></pre><blockquote><p>Return the absolute value of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.sign-Tuple{fmpq}" id="Base.sign-Tuple{fmpq}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sign(a::fmpq)</code></pre><blockquote><p>Return the sign of <span>$a$</span> (<span>$-1$</span>, <span>$0$</span> or <span>$1$</span>) as a fraction.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.height-Tuple{fmpq}" id="Nemo.height-Tuple{fmpq}"><code>Nemo.height</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">height(a::fmpq)</code></pre><blockquote><p>Return the height of the fraction <span>$a$</span>, namely the largest of the absolute values of the numerator and denominator.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.height_bits-Tuple{fmpq}" id="Nemo.height_bits-Tuple{fmpq}"><code>Nemo.height_bits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">height_bits(a::fmpq)</code></pre><blockquote><p>Return the number of bits of the height of the fraction <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.:&lt;&lt;-Tuple{fmpq,Int64}" id="Base.:&lt;&lt;-Tuple{fmpq,Int64}"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&lt;&lt;(a::fmpq, b::Int)</code></pre><blockquote><p>Return <span>$2^b\times a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.:&gt;&gt;-Tuple{fmpq,Int64}" id="Base.:&gt;&gt;-Tuple{fmpq,Int64}"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&gt;&gt;(a::fmpq, b::Int)</code></pre><blockquote><p>Return <span>$2^b/a$</span>.</p></blockquote></div></section><p>Rational fractions can be compared with each other and with integers. Julia provides the full range of operators <span>$&lt;, &gt;, \leq, \geq$</span> which depend on the following functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.isless-Tuple{fmpq,fmpq}" id="Base.isless-Tuple{fmpq,fmpq}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpq, b::fmpq)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.isless-Tuple{Integer,fmpq}" id="Base.isless-Tuple{Integer,fmpq}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::Integer, b::fmpq)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.isless-Tuple{fmpq,Integer}" id="Base.isless-Tuple{fmpq,Integer}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpq, b::Integer)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.isless-Tuple{fmpq,fmpz}" id="Base.isless-Tuple{fmpq,fmpz}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpq, b::fmpz)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.isless-Tuple{fmpz,fmpq}" id="Base.isless-Tuple{fmpz,fmpq}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpz, b::fmpq)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.floor-Tuple{fmpq}" id="Base.floor-Tuple{fmpq}"><code>Base.floor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">floor(a::fmpq)</code></pre><blockquote><p>Returns the greatest integer that is less than or equal to <span>$a$</span>. The result is returned as a rational with denominator <span>$1$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.ceil-Tuple{fmpq}" id="Base.ceil-Tuple{fmpq}"><code>Base.ceil</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ceil(a::fmpq)</code></pre><blockquote><p>Returns the least integer that is greater than or equal to <span>$a$</span>. The result is returned as a rational with denominator <span>$1$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">d = abs(ZZ(11)//3)
4 &lt;= ZZ(7)//ZZ(3)</code></pre><h3><a class="nav-anchor" href="#Modular-arithmetic-1" id="Modular-arithmetic-1">Modular arithmetic</a></h3><p>The following functions are available for rationals.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.mod-Tuple{fmpq,fmpz}" id="Base.mod-Tuple{fmpq,fmpz}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mod(a::fmpq, b::fmpz)</code></pre><blockquote><p>Return <span>$a \pmod{b}$</span> where <span>$b$</span> is an integer coprime to the denominator of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.mod-Tuple{fmpq,Integer}" id="Base.mod-Tuple{fmpq,Integer}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mod(a::fmpq, b::Integer)</code></pre><blockquote><p>Return <span>$a \pmod{b}$</span> where <span>$b$</span> is an integer coprime to the denominator of <span>$a$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = -fmpz(2)//3
b = fmpz(1)//2

c = mod(a, 7)
d = mod(b, fmpz(5))</code></pre><h3><a class="nav-anchor" href="#Rational-Reconstruction-1" id="Rational-Reconstruction-1">Rational Reconstruction</a></h3><p>Rational reconstruction is available for rational numbers.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.reconstruct-Tuple{fmpz,fmpz}" id="Nemo.reconstruct-Tuple{fmpz,fmpz}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::fmpz, b::fmpz)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.reconstruct-Tuple{fmpz,Integer}" id="Nemo.reconstruct-Tuple{fmpz,Integer}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::fmpz, b::Integer)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.reconstruct-Tuple{Integer,fmpz}" id="Nemo.reconstruct-Tuple{Integer,fmpz}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::Integer, b::fmpz)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.reconstruct-Tuple{Integer,Integer}" id="Nemo.reconstruct-Tuple{Integer,Integer}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::Integer, b::Integer)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = reconstruct(7, 13)
b = reconstruct(fmpz(15), 31)
c = reconstruct(fmpz(123), fmpz(237))</code></pre><h2><a class="nav-anchor" href="#Rational-enumeration-1" id="Rational-enumeration-1">Rational enumeration</a></h2><p>Various methods exist to enumerate rationals.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.next_minimal-Tuple{fmpq}" id="Nemo.next_minimal-Tuple{fmpq}"><code>Nemo.next_minimal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_minimal(a::fmpq)</code></pre><blockquote><p>Given <span>$a$</span>, returns the next rational number in the sequence obtained by enumerating all positive denominators <span>$q$</span>, and for each <span>$q$</span> enumerating the numerators <span>$1 \le p &lt; q$</span> in order and generating both <span>$p/q$</span> and <span>$q/p$</span>, but skipping all gcd<span>$(p,q) \neq 1$</span>. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being <span>$0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, \ldots$</span>. This enumeration produces the rational numbers in order of minimal height. It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If <span>$a &lt; 0$</span> we throw a <code>DomainError()</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.next_signed_minimal-Tuple{fmpq}" id="Nemo.next_signed_minimal-Tuple{fmpq}"><code>Nemo.next_signed_minimal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_signed_minimal(a::fmpq)</code></pre><blockquote><p>Given a signed rational number <span>$a$</span> assumed to be in canonical form, returns the next element in the minimal-height sequence generated by <code>next_minimal</code> but with negative numbers interleaved. The sequence begins <span>$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots$</span>. Starting with zero, this generates every rational number once and only once, in order of minimal height.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.next_calkin_wilf-Tuple{fmpq}" id="Nemo.next_calkin_wilf-Tuple{fmpq}"><code>Nemo.next_calkin_wilf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_calkin_wilf(a::fmpq)</code></pre><blockquote><p>Given <span>$a$</span> return the next number in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being <span>$0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \ldots$</span>. Despite the appearance of the initial entries, the Calkin-Wilf enumeration does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.next_signed_calkin_wilf-Tuple{fmpq}" id="Nemo.next_signed_calkin_wilf-Tuple{fmpq}"><code>Nemo.next_signed_calkin_wilf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_signed_calkin_wilf(a::fmpq)</code></pre><blockquote><p>Given a signed rational number <span>$a$</span> returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins <span>$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots$</span>. Starting with zero, this generates every rational number once and only once, but not in order of minimal height.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">next_minimal(fmpz(2)//3)
next_signed_minimal(-fmpz(21)//31)
next_calkin_wilf(fmpz(321)//113)
next_signed_calkin_wilf(-fmpz(51)//(17))</code></pre><h3><a class="nav-anchor" href="#Random-generation-1" id="Random-generation-1">Random generation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.rand_bits-Tuple{FlintRationalField,Int64}" id="Nemo.rand_bits-Tuple{FlintRationalField,Int64}"><code>Nemo.rand_bits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rand_bits(::FlintRationalField, b::Int)</code></pre><blockquote><p>Return a random signed rational whose numerator and denominator both have <span>$b$</span> bits before canonicalisation. Note that the resulting numerator and denominator can be smaller than <span>$b$</span> bits.</p></blockquote></div></section><h3><a class="nav-anchor" href="#Special-functions-1" id="Special-functions-1">Special functions</a></h3><p>The following special functions are available for specific rings in Nemo.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.harmonic-Tuple{Int64}" id="Nemo.harmonic-Tuple{Int64}"><code>Nemo.harmonic</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">harmonic(n::Int)</code></pre><blockquote><p>Computes the harmonic number <span>$H_n = 1 + 1/2 + 1/3 + \cdots + 1/n$</span>. Table lookup is used for <span>$H_n$</span> whose numerator and denominator fit in a single limb. For larger <span>$n$</span>, a divide and conquer strategy is used.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.bernoulli-Tuple{Int64}" id="Nemo.bernoulli-Tuple{Int64}"><code>Nemo.bernoulli</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bernoulli(n::Int)</code></pre><blockquote><p>Computes the Bernoulli number <span>$B_n$</span> for nonnegative <span>$n$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.bernoulli_cache-Tuple{Int64}" id="Nemo.bernoulli_cache-Tuple{Int64}"><code>Nemo.bernoulli_cache</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bernoulli_cache(n::Int)</code></pre><blockquote><p>Precomputes and caches all the Bernoulli numbers up to <span>$B_n$</span>. This is much faster than repeatedly calling <code>bernoulli(k)</code>. Once cached, subsequent calls to <code>bernoulli(k)</code> for any <span>$k \le n$</span> will read from the cache, making them virtually free.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.dedekind_sum-Tuple{fmpz,fmpz}" id="Nemo.dedekind_sum-Tuple{fmpz,fmpz}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::fmpz, k::fmpz)</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.dedekind_sum-Tuple{fmpz,Integer}" id="Nemo.dedekind_sum-Tuple{fmpz,Integer}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::fmpz, k::Integer)</code></pre><blockquote><p>Computes the Dedekind sum <span>$s(h,k)$</span> for arbitrary <span>$h$</span> and <span>$k$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.dedekind_sum-Tuple{Integer,fmpz}" id="Nemo.dedekind_sum-Tuple{Integer,fmpz}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::Integer, k::fmpz)</code></pre><blockquote><p>Computes the Dedekind sum <span>$s(h,k)$</span> for arbitrary <span>$h$</span> and <span>$k$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.dedekind_sum-Tuple{Integer,Integer}" id="Nemo.dedekind_sum-Tuple{Integer,Integer}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::Integer, k::Integer)</code></pre><blockquote><p>Computes the Dedekind sum <span>$s(h,k)$</span> for arbitrary <span>$h$</span> and <span>$k$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = harmonic(12)

b = dedekind_sum(12, 13)
c = dedekind_sum(-120, fmpz(1305))

d = bernoulli(12)

bernoulli_cache(100)
e = bernoulli(100)</code></pre><footer><hr/><a class="previous" href="residue.html"><span class="direction">Previous</span><span class="title">Residue rings</span></a><a class="next" href="rational.html"><span class="direction">Next</span><span class="title">Rationals</span></a></footer></article></body></HTML>