<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Matrices · Nemo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>Nemo.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="about.html">About Nemo</a></li><li><a class="toctext" href="types.html">Types in Nemo</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in Nemo</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="integer.html">Integers</a></li><li><a class="toctext" href="polynomial.html">Univariate polynomials</a></li><li><a class="toctext" href="series.html">Power series and Laurent series</a></li><li><a class="toctext" href="puiseux.html">Puiseux series</a></li><li><a class="toctext" href="residue.html">Residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="fraction.html">Fraction fields</a></li><li><a class="toctext" href="rational.html">Rationals</a></li><li><a class="toctext" href="arb.html">Real balls</a></li><li><a class="toctext" href="acb.html">Complex balls</a></li><li><a class="toctext" href="gfp.html">Galois fields</a></li><li><a class="toctext" href="finitefield.html">Finite fields</a></li><li><a class="toctext" href="numberfield.html">Number field arithmetic</a></li><li><a class="toctext" href="padic.html">Padics</a></li></ul></li><li class="current"><a class="toctext" href="matrix.html">Matrices</a><ul class="internal"><li><a class="toctext" href="#Matrix-functionality-1">Matrix functionality</a></li></ul></li><li><a class="toctext" href="factor.html">Factorisation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="matrix.html">Matrices</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/matrix.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Matrices</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Matrices-1" id="Matrices-1">Matrices</a></h1><p>Nemo allow the creation of dense matrices over any computable ring <span>$R$</span>. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of matrices over numerous specific rings, usually provided by C/C++ libraries.</p><p>The following table shows each of the matrix types available in Nemo, the base ring <span>$R$</span>, and the Julia/Nemo types for that kind of matrix (the type information is mainly of concern to developers).</p><table><tbody><tr><th>Base ring</th><th>Library</th><th>Element type</th><th>Parent type</th></tr><tr><td>Generic ring <span>$R$</span></td><td>AbstractAlgebra.jl</td><td><code>Generic.Mat{T}</code></td><td><code>Generic.MatSpace{T}</code></td></tr><tr><td><span>$\mathbb{Z}$</span></td><td>Flint</td><td><code>fmpz_mat</code></td><td><code>FmpzMatSpace</code></td></tr><tr><td><span>$\mathbb{Z}/n\mathbb{Z}$</span> (small <span>$n$</span>)</td><td>Flint</td><td><code>nmod_mat</code></td><td><code>NmodMatSpace</code></td></tr><tr><td><span>$\mathbb{Q}$</span></td><td>Flint</td><td><code>fmpq_mat</code></td><td><code>FmpqMatSpace</code></td></tr><tr><td><span>$\mathbb{Z}/p\mathbb{Z}$</span> (small <span>$p$</span>)</td><td>Flint</td><td><code>gfp_mat</code></td><td><code>GFPMatSpace</code></td></tr><tr><td><span>$\mathbb{F}_{p^n}$</span> (small <span>$p$</span>)</td><td>Flint</td><td><code>fq_nmod_mat</code></td><td><code>FqNmodMatSpace</code></td></tr><tr><td><span>$\mathbb{F}_{p^n}$</span> (large <span>$p$</span>)</td><td>Flint</td><td><code>fq_mat</code></td><td>`FqMatSpace</td></tr><tr><td><span>$\mathbb{R}$</span></td><td>Arb</td><td><code>arb_mat</code></td><td><code>ArbMatSpace</code></td></tr><tr><td><span>$\mathbb{C}$</span></td><td>Arb</td><td><code>acb_mat</code></td><td><code>AcbMatSpace</code></td></tr></tbody></table><p>The dimensions and base ring <span>$R$</span> of a generic matrix are stored in its parent object. </p><p>All matrix element types belong to the abstract type <code>MatElem</code> and all of the matrix space types belong to the abstract type <code>MatSpace</code>. This enables one to write generic functions that can accept any Nemo matrix type.</p><h2><a class="nav-anchor" href="#Matrix-functionality-1" id="Matrix-functionality-1">Matrix functionality</a></h2><p>All matrix spaces in Nemo follow the AbstractAlgebra.jl matrix interface:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/matrix_spaces.html">https://nemocas.github.io/AbstractAlgebra.jl/matrix_spaces.html</a></p><p>In addition, AbstractAlgebra.jl provides a great deal of generic functionality for matrices. Some of this functionality is also provided by C libraries, such as Flint, for various specific rings.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/matrix.html">https://nemocas.github.io/AbstractAlgebra.jl/matrix.html</a></p><p>In the following, we list the functionality which is provided in addition to the generic matrix functionality, for specific rings in Nemo.</p><h3><a class="nav-anchor" href="#Comparison-operators-1" id="Comparison-operators-1">Comparison operators</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.overlaps-Tuple{arb_mat,arb_mat}" id="Nemo.overlaps-Tuple{arb_mat,arb_mat}"><code>Nemo.overlaps</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">overlaps(x::arb_mat, y::arb_mat)</code></pre><blockquote><p>Returns <code>true</code> if all entries of <span>$x$</span> overlap with the corresponding entry of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.overlaps-Tuple{acb_mat,acb_mat}" id="Nemo.overlaps-Tuple{acb_mat,acb_mat}"><code>Nemo.overlaps</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">overlaps(x::acb_mat, y::acb_mat)</code></pre><blockquote><p>Returns <code>true</code> if all entries of <span>$x$</span> overlap with the corresponding entry of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.contains-Tuple{arb_mat,arb_mat}" id="Nemo.contains-Tuple{arb_mat,arb_mat}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::arb_mat, y::arb_mat)</code></pre><blockquote><p>Returns <code>true</code> if all entries of <span>$x$</span> contain the corresponding entry of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.contains-Tuple{acb_mat,acb_mat}" id="Nemo.contains-Tuple{acb_mat,acb_mat}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::acb_mat, y::acb_mat)</code></pre><blockquote><p>Returns <code>true</code> if all entries of <span>$x$</span> contain the corresponding entry of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><p>In addition we have the following ad hoc comparison operators.</p><p><strong>Examples</strong></p><pre><code class="language-julia">C = RR[1 2; 3 4]
D = RR["1 +/- 0.1" "2 +/- 0.1"; "3 +/- 0.1" "4 +/- 0.1"]
overlaps(C, D)
contains(D, C)</code></pre><h3><a class="nav-anchor" href="#Scaling-1" id="Scaling-1">Scaling</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.:&lt;&lt;-Tuple{fmpz_mat,Int64}" id="Base.:&lt;&lt;-Tuple{fmpz_mat,Int64}"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&lt;&lt;(x::fmpz_mat, y::Int)</code></pre><blockquote><p>Return <span>$2^yx$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.:&gt;&gt;-Tuple{fmpz_mat,Int64}" id="Base.:&gt;&gt;-Tuple{fmpz_mat,Int64}"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&gt;&gt;(x::fmpz_mat, y::Int)</code></pre><blockquote><p>Return <span>$x/2^y$</span> where rounding is towards zero.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)

A = S([fmpz(2) 3 5; 1 4 7; 9 6 3])
 
B = A&lt;&lt;5
C = B&gt;&gt;2</code></pre><p>##i# Determinant</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.det_divisor-Tuple{fmpz_mat}" id="Nemo.det_divisor-Tuple{fmpz_mat}"><code>Nemo.det_divisor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">det_divisor(x::fmpz_mat)</code></pre><blockquote><p>Return some positive divisor of the determinant of <span>$x$</span>, if the determinant is nonzero, otherwise return zero.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.det_given_divisor-Tuple{fmpz_mat,Integer,Bool}" id="Nemo.det_given_divisor-Tuple{fmpz_mat,Integer,Bool}"><code>Nemo.det_given_divisor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">det_given_divisor(x::fmpz_mat, d::Integer, proved=true)</code></pre><blockquote><p>Return the determinant of <span>$x$</span> given a positive divisor of its determinant. If <code>proved == true</code> (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.det_given_divisor-Tuple{fmpz_mat,fmpz,Bool}" id="Nemo.det_given_divisor-Tuple{fmpz_mat,fmpz,Bool}"><code>Nemo.det_given_divisor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">det_given_divisor(x::fmpz_mat, d::fmpz, proved=true)</code></pre><blockquote><p>Return the determinant of <span>$x$</span> given a positive divisor of its determinant. If <code>proved == true</code> (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)

A = S([fmpz(2) 3 5; 1 4 7; 9 6 3])
 
c = det_divisor(A)
d = det_given_divisor(A, c)</code></pre><h3><a class="nav-anchor" href="#Linear-solving-1" id="Linear-solving-1">Linear solving</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.cansolve-Tuple{fmpz_mat,fmpz_mat}" id="Nemo.cansolve-Tuple{fmpz_mat,fmpz_mat}"><code>Nemo.cansolve</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cansolve(a::fmpz_mat, b::fmpz_mat) -&gt; Bool, fmpz_mat</code></pre><blockquote><p>Return true and a matrix <span>$x$</span> such that <span>$ax = b$</span>, or false and some matrix in case <span>$x$</span> does not exist.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.solve_dixon-Tuple{fmpz_mat,fmpz_mat}" id="Nemo.solve_dixon-Tuple{fmpz_mat,fmpz_mat}"><code>Nemo.solve_dixon</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">solve_dixon(a::fmpz_mat, b::fmpz_mat)</code></pre><blockquote><p>Return a tuple <span>$(x, m)$</span> consisting of a column vector <span>$x$</span> such that <span>$ax = b \pmod{m}$</span>. The element  <span>$b$</span> must be a column vector with the same number &gt; of rows as <span>$a$</span> and <span>$a$</span> must be a square matrix. If these conditions are not met or <span>$(x, d)$</span> does not exist, an exception is raised.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.solve_dixon-Tuple{fmpq_mat,fmpq_mat}" id="Nemo.solve_dixon-Tuple{fmpq_mat,fmpq_mat}"><code>Nemo.solve_dixon</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">solve_dixon(a::fmpq_mat, b::fmpq_mat)</code></pre><blockquote><p>Solve <span>$ax = b$</span> by clearing denominators and using Dixon's algorithm. This is usually faster for large systems.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)
T = MatrixSpace(ZZ, 3, 1)

A = S([fmpz(2) 3 5; 1 4 7; 9 2 2])   
B = T([fmpz(4), 5, 7])

X, m = solve_dixon(A, B)</code></pre><h3><a class="nav-anchor" href="#Pseudo-inverse-1" id="Pseudo-inverse-1">Pseudo inverse</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.pseudo_inv-Tuple{fmpz_mat}" id="Nemo.pseudo_inv-Tuple{fmpz_mat}"><code>Nemo.pseudo_inv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pseudo_inv(x::fmpz_mat)</code></pre><blockquote><p>Return a tuple <span>$(z, d)$</span> consisting of a matrix <span>$z$</span> and denominator <span>$d$</span> such that <span>$z/d$</span> is the inverse of <span>$x$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)

A = S([1 0 1; 2 3 1; 5 6 7])
  
B, d = pseudo_inv(A)</code></pre><h3><a class="nav-anchor" href="#Nullspace-1" id="Nullspace-1">Nullspace</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.nullspace_right_rational-Tuple{fmpz_mat}" id="Nemo.nullspace_right_rational-Tuple{fmpz_mat}"><code>Nemo.nullspace_right_rational</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nullspace_right_rational(x::fmpz_mat)</code></pre><blockquote><p>Return a tuple <span>$(r, U)$</span> consisting of a matrix <span>$U$</span> such that the first <span>$r$</span> columns form the right rational nullspace of <span>$x$</span>, i.e. a set of vectors over <span>$\mathbb{Z}$</span> giving a <span>$\mathbb{Q}$</span>-basis  for the nullspace of <span>$x$</span> considered as a matrix over</p></blockquote><div>\[\mathbb{Q}\]</div><p>.</p></div></section><h3><a class="nav-anchor" href="#Modular-reduction-1" id="Modular-reduction-1">Modular reduction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.reduce_mod-Tuple{fmpz_mat,Integer}" id="Nemo.reduce_mod-Tuple{fmpz_mat,Integer}"><code>Nemo.reduce_mod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reduce_mod(x::fmpz_mat, y::Integer)</code></pre><blockquote><p>Reduce the entries of <span>$x$</span> modulo <span>$y$</span> and return the result.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.reduce_mod-Tuple{fmpz_mat,fmpz}" id="Nemo.reduce_mod-Tuple{fmpz_mat,fmpz}"><code>Nemo.reduce_mod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reduce_mod(x::fmpz_mat, y::fmpz)</code></pre><blockquote><p>Reduce the entries of <span>$x$</span> modulo <span>$y$</span> and return the result.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)

A = S([fmpz(2) 3 5; 1 4 7; 9 2 2])
   
reduce_mod(A, ZZ(5))
reduce_mod(A, 2)</code></pre><h3><a class="nav-anchor" href="#Lifting-1" id="Lifting-1">Lifting</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lift-Tuple{nmod_mat}" id="Nemo.lift-Tuple{nmod_mat}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lift(a::nmod_mat)</code></pre><blockquote><p>Return a lift of the matrix <span>$a$</span> to a matrix over <span>$\mathbb{Z}$</span>, i.e. where the entries of the returned matrix are those of <span>$a$</span> lifted to <span>$\mathbb{Z}$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lift-Tuple{gfp_mat}" id="Nemo.lift-Tuple{gfp_mat}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lift(a::gfp_mat)</code></pre><blockquote><p>Return a lift of the matrix <span>$a$</span> to a matrix over <span>$\mathbb{Z}$</span>, i.e. where the entries of the returned matrix are those of <span>$a$</span> lifted to <span>$\mathbb{Z}$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = ResidueRing(ZZ, 7)
S = MatrixSpace(R, 3, 3)

a = S([4 5 6; 7 3 2; 1 4 5])
  
 b = lift(a)</code></pre><h3><a class="nav-anchor" href="#Special-matrices-1" id="Special-matrices-1">Special matrices</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.hadamard-Tuple{FmpzMatSpace}" id="Nemo.hadamard-Tuple{FmpzMatSpace}"><code>Nemo.hadamard</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hadamard(R::FmpzMatSpace)</code></pre><blockquote><p>Return the Hadamard matrix for the given matrix space. The number of rows and columns must be equal.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.ishadamard-Tuple{fmpz_mat}" id="Nemo.ishadamard-Tuple{fmpz_mat}"><code>Nemo.ishadamard</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ishadamard(x::fmpz_mat)</code></pre><blockquote><p>Return <code>true</code> if the given matrix is Hadamard, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.hilbert-Tuple{FmpqMatSpace}" id="Nemo.hilbert-Tuple{FmpqMatSpace}"><code>Nemo.hilbert</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hilbert(R::FmpqMatSpace)</code></pre><blockquote><p>Return the Hilbert matrix in the given matrix space. This is the matrix with entries <span>$H_{i,j} = 1/(i + j - 1)$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = MatrixSpace(ZZ, 3, 3)
S = MatrixSpace(QQ, 3, 3)

A = hadamard(R)
ishadamard(A)
B = hilbert(R)</code></pre><h3><a class="nav-anchor" href="#Hermite-Normal-Form-1" id="Hermite-Normal-Form-1">Hermite Normal Form</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.hnf-Tuple{fmpz_mat}" id="AbstractAlgebra.Generic.hnf-Tuple{fmpz_mat}"><code>AbstractAlgebra.Generic.hnf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hnf(x::fmpz_mat)</code></pre><blockquote><p>Return the Hermite Normal Form of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.hnf_with_transform-Tuple{fmpz_mat}" id="Nemo.hnf_with_transform-Tuple{fmpz_mat}"><code>Nemo.hnf_with_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hnf_with_transform(x::fmpz_mat)</code></pre><blockquote><p>Compute a tuple <span>$(H, T)$</span> where <span>$H$</span> is the Hermite normal form of <span>$x$</span> and <span>$T$</span> is a transformation matrix so that <span>$H = Tx$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.hnf_modular-Tuple{fmpz_mat,fmpz}" id="Nemo.hnf_modular-Tuple{fmpz_mat,fmpz}"><code>Nemo.hnf_modular</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hnf_modular(x::fmpz_mat, d::fmpz)</code></pre><blockquote><p>Compute the Hermite normal form of <span>$x$</span> given that <span>$d$</span> is a multiple of the determinant of the nonzero rows of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.hnf_modular_eldiv-Tuple{fmpz_mat,fmpz}" id="Nemo.hnf_modular_eldiv-Tuple{fmpz_mat,fmpz}"><code>Nemo.hnf_modular_eldiv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hnf_modular_eldiv(x::fmpz_mat, d::fmpz)</code></pre><blockquote><p>Compute the Hermite normal form of <span>$x$</span> given that <span>$d$</span> is a multiple of the largest elementary divisor of <span>$x$</span>. The matrix <span>$x$</span> must have full rank.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.ishnf-Tuple{fmpz_mat}" id="Nemo.ishnf-Tuple{fmpz_mat}"><code>Nemo.ishnf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ishnf(x::fmpz_mat)</code></pre><blockquote><p>Return <code>true</code> if the given matrix is in Hermite Normal Form, otherwise return <code>false</code>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)

A = S([fmpz(2) 3 5; 1 4 7; 19 3 7])
   
B = hnf(A)
H, T = hnf_with_transform(A)
M = hnf_modular(A, fmpz(27))
N = hnf_modular_eldiv(A, fmpz(27))
ishnf(M)</code></pre><h3><a class="nav-anchor" href="#Lattice-basis-reduction-1" id="Lattice-basis-reduction-1">Lattice basis reduction</a></h3><p>Nemo provides LLL lattice basis reduction. Optionally one can specify the setup using a context object created by the following function.</p><pre><code class="language-none">lll_ctx(delta::Float64, eta::Float64, rep=:zbasis, gram=:approx)</code></pre><p>Return a LLL context object specifying LLL parameters <span>$\delta$</span> and <span>$\eta$</span> and specifying the representation as either <code>:zbasis</code> or <code>:gram</code> and the Gram type as either <code>:approx</code> or <code>:exact</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll-Tuple{fmpz_mat,lll_ctx}" id="Nemo.lll-Tuple{fmpz_mat,lll_ctx}"><code>Nemo.lll</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51))</code></pre><blockquote><p>Return the LLL reduction of the matrix <span>$x$</span>. By default the matrix <span>$x$</span> is a <span>$\mathbb{Z}$</span>-basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters <span>$\delta = 0.99$</span> and <span>$\eta = 0.51$</span>. All of these defaults can be overridden by specifying an optional context object.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll_with_transform-Tuple{fmpz_mat,lll_ctx}" id="Nemo.lll_with_transform-Tuple{fmpz_mat,lll_ctx}"><code>Nemo.lll_with_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><blockquote><p>Compute a tuple <span>$(L, T)$</span> where <span>$L$</span> is the LLL reduction of <span>$a$</span> and <span>$T$</span> is a transformation matrix so that <span>$L = Ta$</span>. All the default parameters can be overridden by supplying an optional context object.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll_gram-Tuple{fmpz_mat,lll_ctx}" id="Nemo.lll_gram-Tuple{fmpz_mat,lll_ctx}"><code>Nemo.lll_gram</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll_gram(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51, :gram))</code></pre><blockquote><p>Given the Gram matrix <span>$x$</span> of a matrix, compute the Gram matrix of its LLL reduction.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll_gram_with_transform-Tuple{fmpz_mat,lll_ctx}" id="Nemo.lll_gram_with_transform-Tuple{fmpz_mat,lll_ctx}"><code>Nemo.lll_gram_with_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll_gram_with_transform(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51, :gram))</code></pre><blockquote><p>Given the Gram matrix <span>$x$</span> of a matrix <span>$M$</span>, compute a tuple <span>$(L, T)$</span> where <span>$L$</span> is the gram matrix of the LLL reduction of the matrix and <span>$T$</span> is a transformation matrix so that <span>$L = TM$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll_with_removal-Tuple{fmpz_mat,fmpz,lll_ctx}" id="Nemo.lll_with_removal-Tuple{fmpz_mat,fmpz,lll_ctx}"><code>Nemo.lll_with_removal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll_with_removal(x::fmpz_mat, b::fmpz, ctx=lll_ctx(0.99, 0.51))</code></pre><blockquote><p>Compute the LLL reduction of <span>$x$</span> and throw away rows whose norm exceeds the given bound <span>$b$</span>. Return a tuple <span>$(r, L)$</span> where the first <span>$r$</span> rows of <span>$L$</span> are the rows remaining after removal.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll_with_removal_transform-Tuple{fmpz_mat,fmpz,lll_ctx}" id="Nemo.lll_with_removal_transform-Tuple{fmpz_mat,fmpz,lll_ctx}"><code>Nemo.lll_with_removal_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll_with_removal_transform(x::fmpz_mat, b::fmpz, ctx=lll_ctx(0.99, 0.51))</code></pre><blockquote><p>Compute a tuple <span>$(r, L, T)$</span> where the first <span>$r$</span> rows of <span>$L$</span> are those remaining from the LLL reduction after removal of vectors with norm exceeding the bound <span>$b$</span> and <span>$T$</span> is a transformation matrix so that <span>$L = Tx$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll!-Tuple{fmpz_mat,lll_ctx}" id="Nemo.lll!-Tuple{fmpz_mat,lll_ctx}"><code>Nemo.lll!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll!(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51))</code></pre><blockquote><p>Perform the LLL reduction of the matrix <span>$x$</span> inplace. By default the matrix <span>$x$</span> is a &gt; <span>$\mathbb{Z}$</span>-basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters <span>$\delta = 0.99$</span> and <span>$\eta = 0.51$</span>. All of these defaults can be overridden by specifying an optional context object.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.lll_gram!-Tuple{fmpz_mat,lll_ctx}" id="Nemo.lll_gram!-Tuple{fmpz_mat,lll_ctx}"><code>Nemo.lll_gram!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll_gram!(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51, :gram))</code></pre><blockquote><p>Given the Gram matrix <span>$x$</span> of a matrix, compute the Gram matrix of its LLL reduction inplace.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)

A = S([fmpz(2) 3 5; 1 4 7; 19 3 7])
   
L = lll(A, lll_ctx(0.95, 0.55, :zbasis, :approx)
L, T = lll_with_transform(A)

G == lll_gram(gram(A))
G, T = lll_gram_with_transform(gram(A))

r, L = lll_with_removal(A, fmpz(100))
r, L, T = lll_with_removal_transform(A, fmpz(100))</code></pre><h3><a class="nav-anchor" href="#Smith-Normal-Form-1" id="Smith-Normal-Form-1">Smith Normal Form</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.snf-Tuple{fmpz_mat}" id="AbstractAlgebra.Generic.snf-Tuple{fmpz_mat}"><code>AbstractAlgebra.Generic.snf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">snf(x::fmpz_mat)</code></pre><blockquote><p>Compute the Smith normal form of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.snf_diagonal-Tuple{fmpz_mat}" id="Nemo.snf_diagonal-Tuple{fmpz_mat}"><code>Nemo.snf_diagonal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">snf_diagonal(x::fmpz_mat)</code></pre><blockquote><p>Given a diagonal matrix <span>$x$</span> compute the Smith normal form of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.issnf-Tuple{fmpz_mat}" id="Nemo.issnf-Tuple{fmpz_mat}"><code>Nemo.issnf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issnf(x::fmpz_mat)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is in Smith normal form, otherwise return <code>false</code>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(ZZ, 3, 3)

A = S([fmpz(2) 3 5; 1 4 7; 19 3 7])
   
B = snf(A)
issnf(B) == true

B = S([fmpz(2) 0 0; 0 4 0; 0 0 7])

C = snf_diagonal(B)</code></pre><h3><a class="nav-anchor" href="#Strong-Echelon-Form-1" id="Strong-Echelon-Form-1">Strong Echelon Form</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.strong_echelon_form-Tuple{nmod_mat}" id="Nemo.strong_echelon_form-Tuple{nmod_mat}"><code>Nemo.strong_echelon_form</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">strong_echelon_form(a::nmod_mat)</code></pre><blockquote><p>Return the strong echeleon form of <span>$a$</span>. The matrix <span>$a$</span> must have at least as many rows as columns.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.strong_echelon_form-Tuple{gfp_mat}" id="Nemo.strong_echelon_form-Tuple{gfp_mat}"><code>Nemo.strong_echelon_form</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">strong_echelon_form(a::gfp_mat)</code></pre><blockquote><p>Return the strong echeleon form of <span>$a$</span>. The matrix <span>$a$</span> must have at least as many rows as columns.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = ResidueRing(ZZ, 12)
S = MatrixSpace(R, 3, 3)

A = S([4 1 0; 0 0 5; 0 0 0 ])

B = strong_echelon_form(A)</code></pre><h3><a class="nav-anchor" href="#Howell-Form-1" id="Howell-Form-1">Howell Form</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.howell_form-Tuple{nmod_mat}" id="Nemo.howell_form-Tuple{nmod_mat}"><code>Nemo.howell_form</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">howell_form(a::nmod_mat)</code></pre><blockquote><p>Return the Howell normal form of <span>$a$</span>. The matrix <span>$a$</span> must have at least as many rows as columns.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.howell_form-Tuple{gfp_mat}" id="Nemo.howell_form-Tuple{gfp_mat}"><code>Nemo.howell_form</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">howell_form(a::gfp_mat)</code></pre><blockquote><p>Return the Howell normal form of <span>$a$</span>. The matrix <span>$a$</span> must have at least as many rows as columns.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = ResidueRing(ZZ, 12)
S = MatrixSpace(R, 3, 3)

A = S([4 1 0; 0 0 5; 0 0 0 ])

B = howell_form(A)</code></pre><h3><a class="nav-anchor" href="#Gram-Schmidt-Orthogonalisation-1" id="Gram-Schmidt-Orthogonalisation-1">Gram-Schmidt Orthogonalisation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.gso-Tuple{fmpq_mat}" id="Nemo.gso-Tuple{fmpq_mat}"><code>Nemo.gso</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gso(x::fmpq_mat)</code></pre><blockquote><p>Return the Gram-Schmidt Orthogonalisation of the matrix <span>$x$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">S = MatrixSpace(QQ, 3, 3)

A = S([4 7 3; 2 9 1; 0 5 3])

B = gso(A)</code></pre><h3><a class="nav-anchor" href="#Exponential-1" id="Exponential-1">Exponential</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.exp-Tuple{arb_mat}" id="Base.exp-Tuple{arb_mat}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">exp(x::arb_mat)</code></pre><blockquote><p>Returns the exponential of the matrix <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.exp-Tuple{acb_mat}" id="Base.exp-Tuple{acb_mat}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">exp(x::acb_mat)</code></pre><blockquote><p>Returns the exponential of the matrix <span>$x$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">A = RR[2 0 0; 0 3 0; 0 0 1]

B = exp(A)</code></pre><h3><a class="nav-anchor" href="#Norm-1" id="Norm-1">Norm</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.bound_inf_norm-Tuple{arb_mat}" id="Nemo.bound_inf_norm-Tuple{arb_mat}"><code>Nemo.bound_inf_norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bound_inf_norm(x::arb_mat)</code></pre><blockquote><p>Returns a nonnegative element <span>$z$</span> of type <code>arb</code>, such that <span>$z$</span> is an upper bound for the infinity norm for every matrix in <span>$x$</span></p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.bound_inf_norm-Tuple{acb_mat}" id="Nemo.bound_inf_norm-Tuple{acb_mat}"><code>Nemo.bound_inf_norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bound_inf_norm(x::acb_mat)</code></pre><blockquote><p>Returns a nonnegative element <span>$z$</span> of type <code>acb</code>, such that <span>$z$</span> is an upper bound for the infinity norm for every matrix in <span>$x$</span></p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">A = RR[1 2 3; 4 5 6; 7 8 9]

d = bound_inf_norm(A)</code></pre><h3><a class="nav-anchor" href="#Shifting-1" id="Shifting-1">Shifting</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.Math.ldexp-Tuple{arb_mat,Int64}" id="Base.Math.ldexp-Tuple{arb_mat,Int64}"><code>Base.Math.ldexp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ldexp(x::acb_mat, y::Int)</code></pre><blockquote><p>Return <span>$2^yx$</span>. Note that <span>$y$</span> can be positive, zero or negative.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.Math.ldexp-Tuple{acb_mat,Int64}" id="Base.Math.ldexp-Tuple{acb_mat,Int64}"><code>Base.Math.ldexp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ldexp(x::acb_mat, y::Int)</code></pre><blockquote><p>Return <span>$2^yx$</span>. Note that <span>$y$</span> can be positive, zero or negative.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">A = RR[1 2 3; 4 5 6; 7 8 9]

B = ldexp(A, 4)

overlaps(16*A, B)</code></pre><h3><a class="nav-anchor" href="#Predicates-1" id="Predicates-1">Predicates</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.isreal-Tuple{acb_mat}" id="Base.isreal-Tuple{acb_mat}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isreal(M::acb_mat)</code></pre><blockquote><p>Returns whether every entry of <span>$M$</span> has vanishing imaginary part.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">A = CC[1 2 3; 4 5 6; 7 8 9]

isreal(A)

isreal(onei(CC)*A)</code></pre><h3><a class="nav-anchor" href="#Conversion-to-Julia-matrices-1" id="Conversion-to-Julia-matrices-1">Conversion to Julia matrices</a></h3><p>Julia matrices use a different data structure than Nemo matrices. Conversion to Julia matrices is usually only required for interfacing with other packages. It isn't necessary to convert Nemo matrices to Julia matrices in order to manipulate them.</p><p>This conversion can be performed with standard Julia syntax, such as the following, where <code>A</code> is an <code>fmpz_mat</code>: </p><pre><code class="language-julia">Matrix{Int}(A)
Matrix{BigInt}(A)</code></pre><p>In case the matrix cannot be converted without loss, an <code>InexactError</code> is thrown: in this case, cast to a matrix of <code>BigInt</code>s rather than <code>Int</code>s. </p><footer><hr/><a class="previous" href="padic.html"><span class="direction">Previous</span><span class="title">Padics</span></a><a class="next" href="factor.html"><span class="direction">Next</span><span class="title">Factorisation</span></a></footer></article></body></HTML>