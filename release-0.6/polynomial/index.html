<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="X-UA-Compatible"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="William Hart" name="author"/><link href="../img/favicon.ico" rel="shortcut icon"/><title>Univariate polynomials - Nemo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css"/><link href="../css/theme.css" rel="stylesheet" type="text/css"/><link href="../css/theme_extra.css" rel="stylesheet" type="text/css"/><link href="../css/highlight.css" rel="stylesheet"/><link href="../assets/Documenter.css" rel="stylesheet"/><script>
    // Current page data
    var mkdocs_page_name = "Univariate polynomials";
    var mkdocs_page_input_path = "polynomial.md";
    var mkdocs_page_url = "/polynomial/";
  </script><script src="../js/jquery-2.1.1.min.js"></script><script src="../js/modernizr-2.8.3.min.js"></script><script src="../js/highlight.pack.js" type="text/javascript"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.mkdocs_page_url) {
        let level = window.mkdocs_page_url.split('/').length;
        if (window.mkdocs_page_url[0] === '/') {
            level -= 1;
        }
        if (window.mkdocs_page_url.slice(-1) === '/') {
            level -= 1;
        }
        href = "." + "/..".repeat(level) + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift"><div class="wy-side-nav-search"><a class="icon icon-home" href=".."> Nemo.jl</a><div role="search"><form action="../search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="" href="..">Getting Started</a></li><li class="toctree-l1"><a class="" href="../about/">About Nemo</a></li><li class="toctree-l1"><a class="" href="../types/">Types in Nemo</a></li><li class="toctree-l1"><a class="" href="../constructors/">Parent object constructors</a></li><li class="toctree-l1 current"><a class="current" href="./">Univariate polynomials</a><ul class="subnav"><li class="toctree-l2"><a href="#introduction">Introduction</a></li><li class="toctree-l2"><a href="#polynomial-ring-constructors">Polynomial ring constructors</a></li><li class="toctree-l2"><a href="#polynomial-element-constructors">Polynomial element constructors</a></li><li class="toctree-l2"><a href="#basic-functionality">Basic functionality</a></li><li class="toctree-l2"><a href="#basic-manipulation">Basic manipulation</a></li><li class="toctree-l2"><a href="#arithmetic-operators">Arithmetic operators</a></li><li class="toctree-l2"><a href="#comparison-operators">Comparison operators</a></li><li class="toctree-l2"><a href="#function">Function</a></li><li class="toctree-l2"><a href="#function_1">Function</a></li><li class="toctree-l2"><a href="#truncation">Truncation</a></li><li class="toctree-l2"><a href="#reversal">Reversal</a></li><li class="toctree-l2"><a href="#shifting">Shifting</a></li><li class="toctree-l2"><a href="#modulo-arithmetic">Modulo arithmetic</a></li><li class="toctree-l2"><a href="#euclidean-division">Euclidean division</a></li><li class="toctree-l2"><a href="#pseudodivision">Pseudodivision</a></li><li class="toctree-l2"><a href="#content-primitive-part-gcd-and-lcm">Content, primitive part, GCD and LCM</a></li><li class="toctree-l2"><a href="#evaluation-composition-and-substitution">Evaluation, composition and substitution</a></li><li class="toctree-l2"><a href="#remove-and-valuation">Remove and valuation</a></li><li class="toctree-l2"><a href="#derivative-and-integral">Derivative and integral</a></li><li class="toctree-l2"><a href="#resultant-and-discriminant">Resultant and discriminant</a></li><li class="toctree-l2"><a href="#newton-representation">Newton representation</a></li><li class="toctree-l2"><a href="#multipoint-evaluation-and-interpolation">Multipoint evaluation and interpolation</a></li><li class="toctree-l2"><a href="#signature">Signature</a></li><li class="toctree-l2"><a href="#root-finding">Root finding</a></li><li class="toctree-l2"><a href="#construction-from-roots">Construction from roots</a></li><li class="toctree-l2"><a href="#lifting">Lifting</a></li><li class="toctree-l2"><a href="#overlapping-and-containment">Overlapping and containment</a></li><li class="toctree-l2"><a href="#factorisation">Factorisation</a></li><li class="toctree-l2"><a href="#special-functions">Special functions</a></li></ul></li><li class="toctree-l1"><a class="" href="../series/">Capped relative power series</a></li><li class="toctree-l1"><a class="" href="../residue/">Residue rings</a></li><li class="toctree-l1"><a class="" href="../fraction/">Fraction fields</a></li><li class="toctree-l1"><a class="" href="../matrix/">Matrices</a></li><li class="toctree-l1"><a class="" href="../integer/">Integers</a></li><li class="toctree-l1"><a class="" href="../rational/">Rationals</a></li><li class="toctree-l1"><a class="" href="../finitefield/">Finite fields</a></li><li class="toctree-l1"><a class="" href="../padic/">P-adic fields</a></li><li class="toctree-l1"><a class="" href="../arb/">Real balls</a></li><li class="toctree-l1"><a class="" href="../acb/">Complex boxes</a></li><li class="toctree-l1"><a class="" href="../numberfield/">Number fields</a></li><li class="toctree-l1"><a class="" href="../maximalorder/">Maximal orders</a></li><li class="toctree-l1"><a class="" href="../classgroup/">Class groups</a></li><li class="toctree-l1"><a class="" href="../perm/">Permutation groups</a></li><li class="toctree-l1"><a class="" href="../factor/">Factorization</a></li></ul></div>
       
    </nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="..">Nemo.jl</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="..">Docs</a> »</li><li>Univariate polynomials</li><li class="wy-breadcrumbs-aside"><a class="icon icon-github" href="https://github.com/Nemocas/Nemo.jl/edit/master/docs/polynomial.md"> Edit on GitHub</a></li></ul><hr/></div><div role="main"><div class="section"><p><a id="Introduction-1"></a></p><h2 id="introduction">Introduction</h2><p>Nemo allow the creation of dense, univariate polynomials over any computable ring <script type="math/tex">R</script>. There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.</p><p>The following table shows each of the polynomial types available in Nemo, the base ring <script type="math/tex">R</script>, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).</p><table><thead><tr><th align="right">Base ring</th><th align="right">Library</th><th align="right">Element type</th><th align="right">Parent type</th></tr></thead><tbody><tr><td align="right">Generic ring <script type="math/tex">R</script></td><td align="right">Nemo</td><td align="right"><code>GenPoly{T}</code></td><td align="right"><code>GenPolyRing{T}</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{Z}</script></td><td align="right">Flint</td><td align="right"><code>fmpz_poly</code></td><td align="right"><code>FmpzPolyRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> (small <script type="math/tex">n</script>)</td><td align="right">Flint</td><td align="right"><code>nmod_poly</code></td><td align="right"><code>NmodPolyRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> (large <script type="math/tex">n</script>)</td><td align="right">Flint</td><td align="right"><code>fmpz_mod_poly</code></td><td align="right"><code>FmpzModPolyRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{Q}</script></td><td align="right">Flint</td><td align="right"><code>fmpq_poly</code></td><td align="right"><code>FmpqPolyRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{F}_{p^n}</script> (small <script type="math/tex">n</script>)</td><td align="right">Flint</td><td align="right"><code>fq_nmod_poly</code></td><td align="right"><code>FqNmodPolyRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{F}_{p^n}</script> (large <script type="math/tex">n</script>)</td><td align="right">Flint</td><td align="right"><code>fq_poly</code></td><td align="right"><code>FqPolyRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{R}</script></td><td align="right">Arb</td><td align="right"><code>arb_poly</code></td><td align="right"><code>ArbPolyRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{C}</script></td><td align="right">Arb</td><td align="right"><code>acb_poly</code></td><td align="right"><code>AcbPolyRing</code></td></tr></tbody></table><p>The string representation of the variable and the base ring <script type="math/tex">R</script> of a generic polynomial is stored in its parent object. </p><p>All polynomial element types belong to the abstract type <code>PolyElem</code> and all of the polynomial ring types belong to the abstract type <code>PolyRing</code>. This enables one to write generic functions that can accept any Nemo polynomial type.</p><p><a id="Polynomial-ring-constructors-1"></a></p><h2 id="polynomial-ring-constructors">Polynomial ring constructors</h2><p>In order to construct polynomials in Nemo, one must first construct the polynomial ring itself. This is accomplished with the following constructor.</p><pre><code>PolynomialRing(::Ring, ::AbstractString, ::Bool)
</code></pre><p>A shorthand version of this function is provided: given a base ring <code>R</code>, we abbreviate the constructor as follows.</p><pre><code>R["x"]
</code></pre><p>Here are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = QQ["z"]

f = R()
g = R(123)
h = S(ZZ(1234))
k = S(x + 1)
m = T(z + 1)
</code></pre><p><a id="Polynomial-element-constructors-1"></a></p><h2 id="polynomial-element-constructors">Polynomial element constructors</h2><p>Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.</p><p>The easiest way is simply using the generator returned by the <code>PolynomialRing</code> constructor and and build up the polynomial using basic arithmetic. Julia has quite flexible notation for the construction of polynomials in this way.</p><p>In addition we provide the following functions for constructing certain useful polynomials.</p><p><a href="#Base.zero-Tuple{Nemo.PolyRing}" id="Base.zero-Tuple{Nemo.PolyRing}">#</a><strong><code>Base.zero</code></strong> — <em>Method</em>.</p><pre><code>zero(R::PolyRing)
</code></pre><blockquote><p>Return the zero polynomial in the given polynomial ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L135" target="_blank">source</a><br/></p><p><a href="#Base.one-Tuple{Nemo.PolyRing}" id="Base.one-Tuple{Nemo.PolyRing}">#</a><strong><code>Base.one</code></strong> — <em>Method</em>.</p><pre><code>one(R::PolyRing)
</code></pre><blockquote><p>Return the constant polynomial <script type="math/tex">1</script> in the given polynomial ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L141" target="_blank">source</a><br/></p><p><a href="#Nemo.gen-Tuple{Nemo.PolyRing}" id="Nemo.gen-Tuple{Nemo.PolyRing}">#</a><strong><code>Nemo.gen</code></strong> — <em>Method</em>.</p><pre><code>gen(R::PolyRing)
</code></pre><blockquote><p>Return the generator of the given polynomial ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L147" target="_blank">source</a><br/></p><p>Here are some examples of constructing polynomials.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x^3 + 3x + 21
g = (x + 1)*y^2 + 2x + 1

h = zero(S)
k = one(R)
m = gen(S)
</code></pre><p><a id="Basic-functionality-1"></a></p><h2 id="basic-functionality">Basic functionality</h2><p>All univariate polynomial modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)</p><p>Developers who are writing their own polynomial module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom univariate polynomial types in Nemo. </p><p>We write <code>U</code> for the type of the polynomials in the polynomial ring and <code>T</code> for the type of elements of the coefficient ring.</p><p>All of these functions are provided for all existing polynomial types in Nemo.</p><pre><code>parent_type{U &lt;: PolyElem}(::Type{U})
</code></pre><p>Given the type of polynomial elements, should return the type of the corresponding parent object.</p><pre><code>elem_type(R::PolyRing)
</code></pre><p>Given a parent object for the polynomial ring, return the type of elements of the polynomial ring.</p><pre><code>Base.hash(a::PolyElem, h::UInt)
</code></pre><p>Return a <code>UInt</code> hexadecimal hash of the polynomial <script type="math/tex">a</script>. This should be xor'd with a fixed random hexadecimal specific to the polynomial type. The hash of each coefficient should be xor'd with the supplied parameter <code>h</code> as part of computing the hash.</p><pre><code>fit!(a::PolyElem, n::Int)
</code></pre><p>By reallocating if necessary, ensure that the given polynomial has space for at least <script type="math/tex">n</script> coefficients. This function does not change the length of the polynomial and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.</p><pre><code>normalise(a::PolyElem, n::Int)
</code></pre><p>Return the normalised length of the given polynomial, assuming its current length is <script type="math/tex">n</script>. Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the polynomial. That can be done with a subsequent call to <code>set_length!</code> using the length returned by <code>normalise</code>.</p><pre><code>set_length!(a::PolyElem, n::Int)
</code></pre><p>Set the length of an existing polynomial that has sufficient space allocated, i.e. a polynomial for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial type has a field, <code>length</code>, which corresponds to the current length of the polynomial, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.</p><pre><code>length(a::PolyElem)
</code></pre><p>Return the current length (not the number of allocated coefficients), of the given polynomial. Note that this function only needs to be provided by a developer for a custom polynomial type if the Julia type definition for polynomial elements doesn't contain a field <code>length</code> corresponding to the current length of the polynomial. Otherwise the supplied generic implementation will work.</p><pre><code>coeff(a::PolyElem, n::Int)
</code></pre><p>Return the degree <code>n</code> coefficient of the given polynomial. Note coefficients are numbered from <code>n = 0</code> for the constant coefficient. If <script type="math/tex">n</script> is bigger then the degree of the polynomial, the function returns a zero coefficient. We require <script type="math/tex">n \geq 0</script>. </p><pre><code>setcoeff!{T &lt;: RingElem}(a::PolyElem{T}, n::Int, c::T)
</code></pre><p>Set the coefficient of the degree <script type="math/tex">n</script> term of the given polynomial to the given value <code>a</code>. The polynomial is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.</p><pre><code>deepcopy(a::PolyElem)
</code></pre><p>Construct a copy of the given polynomial and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo polynomials are mutable and so returning shallow copies is not sufficient.</p><pre><code>mul!(c::PolyElem, a::PolyElem, b::PolyElem)
</code></pre><p>Multiply <script type="math/tex">a</script> by <script type="math/tex">b</script> and set the existing polynomial <script type="math/tex">c</script> to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.</p><pre><code>addeq!(c::PolyElem, a::PolyElem)
</code></pre><p>In-place addition. Adds <script type="math/tex">a</script> to <script type="math/tex">c</script> and sets <script type="math/tex">c</script> to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.</p><p>Given a parent object <code>S</code> for a polynomial ring, the following coercion functions are provided to coerce various elements into the polynomial ring. Developers provide these by overloading the <code>call</code> operator for the polynomial parent objects.</p><pre><code>S()
</code></pre><p>Coerce zero into the ring <script type="math/tex">S</script>.</p><pre><code>S(n::Integer)
S(n::fmpz)
</code></pre><p>Coerce an integer value or Flint integer into the polynomial ring <script type="math/tex">S</script>.</p><pre><code>S(n::T)
</code></pre><p>Coerces an element of the base ring, of type <code>T</code> into <script type="math/tex">S</script>.</p><pre><code>S(A::Array{T, 1})
</code></pre><p>Take an array of elements in the base ring, of type <code>T</code> and construct the polynomial with those coefficients, starting with the constant coefficient.</p><pre><code>S(f::PolyElem)
</code></pre><p>Take a polynomial that is already in the ring <script type="math/tex">S</script> and simply return it. A copy of the original is not made.</p><pre><code>S(c::RingElem)
</code></pre><p>Try to coerce the given ring element into the polynomial ring. This only succeeds if <script type="math/tex">c</script> can be coerced into the base ring.</p><p>In addition to the above, developers of custom polynomials must ensure the parent object of a polynomial type constains a field <code>base_ring</code> specifying the base ring, a field <code>S</code> containing a symbol (not a string) representing the variable name of the polynomial ring. They must also ensure that each polynomial element contains a field <code>parent</code> specifying the parent object of the polynomial.</p><p>Typically a developer will also overload the <code>PolynomialRing</code> generic function to create polynomials of the custom type they are implementing.</p><p><a id="Basic-manipulation-1"></a></p><h2 id="basic-manipulation">Basic manipulation</h2><p>Numerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.</p><p><a href="#Nemo.base_ring-Tuple{Nemo.PolyRing}" id="Nemo.base_ring-Tuple{Nemo.PolyRing}">#</a><strong><code>Nemo.base_ring</code></strong> — <em>Method</em>.</p><pre><code>base_ring(R::PolyRing)
</code></pre><blockquote><p>Return the base ring of the given polynomial ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L27" target="_blank">source</a><br/></p><p><a href="#Nemo.base_ring-Tuple{Nemo.PolyElem}" id="Nemo.base_ring-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.base_ring</code></strong> — <em>Method</em>.</p><pre><code>base_ring(a::PolyElem)
</code></pre><blockquote><p>Return the base ring of the polynomial ring of the given polynomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L33" target="_blank">source</a><br/></p><p><a href="#Base.parent-Tuple{Nemo.PolyElem}" id="Base.parent-Tuple{Nemo.PolyElem}">#</a><strong><code>Base.parent</code></strong> — <em>Method</em>.</p><pre><code>parent(a::PolyElem)
</code></pre><blockquote><p>Return the parent of the given polynomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L39" target="_blank">source</a><br/></p><p><a href="#Base.var-Tuple{Nemo.PolyRing}" id="Base.var-Tuple{Nemo.PolyRing}">#</a><strong><code>Base.var</code></strong> — <em>Method</em>.</p><pre><code>var(a::PolyRing)
</code></pre><blockquote><p>Return the internal name of the generator of the polynomial ring. Note that this is returned as a <code>Symbol</code> not a <code>String</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L45" target="_blank">source</a><br/></p><p><a href="#Nemo.vars-Tuple{Nemo.PolyRing}" id="Nemo.vars-Tuple{Nemo.PolyRing}">#</a><strong><code>Nemo.vars</code></strong> — <em>Method</em>.</p><pre><code>vars(a::PolyRing)
</code></pre><blockquote><p>Return an array of the variable names for the polynomial ring. Note that this is returned as an array of <code>Symbol</code> not <code>String</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L52" target="_blank">source</a><br/></p><p><a href="#Nemo.degree-Tuple{Nemo.PolyElem}" id="Nemo.degree-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.degree</code></strong> — <em>Method</em>.</p><pre><code>degree(a::PolyElem)
</code></pre><blockquote><p>Return the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L92" target="_blank">source</a><br/></p><p><a href="#Nemo.modulus-Tuple{Nemo.PolyElem{T&lt;:Nemo.ResElem}}" id="Nemo.modulus-Tuple{Nemo.PolyElem{T&lt;:Nemo.ResElem}}">#</a><strong><code>Nemo.modulus</code></strong> — <em>Method</em>.</p><pre><code>modulus{T &lt;: ResElem}(a::PolyElem{T})
</code></pre><blockquote><p>Return the modulus of the coefficients of the given polynomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L99" target="_blank">source</a><br/></p><p><a href="#Nemo.lead-Tuple{Nemo.PolyElem}" id="Nemo.lead-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.lead</code></strong> — <em>Method</em>.</p><pre><code>lead(x::PolyElem)
</code></pre><blockquote><p>Return the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L107" target="_blank">source</a><br/></p><p><a href="#Nemo.trail-Tuple{Nemo.PolyElem}" id="Nemo.trail-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.trail</code></strong> — <em>Method</em>.</p><pre><code>trail(x::PolyElem)
</code></pre><blockquote><p>Return the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L115" target="_blank">source</a><br/></p><p><a href="#Nemo.iszero-Tuple{Nemo.PolyElem}" id="Nemo.iszero-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.iszero</code></strong> — <em>Method</em>.</p><pre><code>iszero(a::PolyElem)
</code></pre><blockquote><p>Return <code>true</code> if the given polynomial is zero, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L153" target="_blank">source</a><br/></p><p><a href="#Nemo.isone-Tuple{Nemo.PolyElem}" id="Nemo.isone-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.isone</code></strong> — <em>Method</em>.</p><pre><code>isone(a::PolyElem)
</code></pre><blockquote><p>Return <code>true</code> if the given polynomial is the constant polynomial <script type="math/tex">1</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L159" target="_blank">source</a><br/></p><p><a href="#Nemo.isgen-Tuple{Nemo.PolyElem}" id="Nemo.isgen-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.isgen</code></strong> — <em>Method</em>.</p><pre><code>isgen(a::PolyElem)
</code></pre><blockquote><p>Return <code>true</code> if the given polynomial is the constant generator of its polynomial ring, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L166" target="_blank">source</a><br/></p><p><a href="#Nemo.isunit-Tuple{Nemo.PolyElem}" id="Nemo.isunit-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.isunit</code></strong> — <em>Method</em>.</p><pre><code>isunit(a::PolyElem)
</code></pre><blockquote><p>Return <code>true</code> if the given polynomial is a unit in its polynomial ring, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L175" target="_blank">source</a><br/></p><p><a href="#Nemo.ismonomial-Tuple{Nemo.PolyElem}" id="Nemo.ismonomial-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.ismonomial</code></strong> — <em>Method</em>.</p><pre><code>ismonomial(a::PolyElem)
</code></pre><blockquote><p>Return <code>true</code> if the given polynomial is a monomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L203" target="_blank">source</a><br/></p><p><a href="#Nemo.isterm-Tuple{Nemo.PolyElem}" id="Nemo.isterm-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.isterm</code></strong> — <em>Method</em>.</p><pre><code>isterm(a::PolyElem)
</code></pre><blockquote><p>Return <code>true</code> if the given polynomial is has one term. This function is recursive, with all scalar types returning true.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L184" target="_blank">source</a><br/></p><p><a href="#Base.den-Tuple{Nemo.fmpq_poly}" id="Base.den-Tuple{Nemo.fmpq_poly}">#</a><strong><code>Base.den</code></strong> — <em>Method</em>.</p><pre><code>den(a::fmpq_poly)
</code></pre><blockquote><p>Return the least common denominator of the coefficients of the polynomial <script type="math/tex">a</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpq_poly.jl#L29" target="_blank">source</a><br/></p><p>Here are some examples of basic manipulation of polynomials.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(QQ, "z")

a = zero(S)
b = one(S)

c = ZZ(1)//2*z^2 + ZZ(1)//3
d = x*y^2 + (x + 1)*y + 3

U = base_ring(S)
V = base_ring(y + 1)
v = var(S)
T = parent(y + 1)

f = lead(d)

g = isgen(y)
h = isone(b)
k = iszero(a)
m = isunit(b)
n = degree(d)
p = length(b)
q = den(c)
</code></pre><p><a id="Arithmetic-operators-1"></a></p><h2 id="arithmetic-operators">Arithmetic operators</h2><p>All the usual arithmetic operators are overloaded for Nemo polynomials. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use <code>divexact</code>. To construct an element of a fraction field one can use the double slash operator <code>//</code>.</p><p>The following standard operators and functions are provided.</p><table><thead><tr><th align="right">Function</th><th align="right">Operation</th></tr></thead><tbody><tr><td align="right"><code>-(a::PolyElem)</code></td><td align="right">unary minus</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})</code></td><td align="right">addition</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>divexact{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})</code></td><td align="right">exact division</td></tr></tbody></table><p>The following ad hoc operators and functions are also provided.</p><table><thead><tr><th align="right">Function</th><th align="right">Operation</th></tr></thead><tbody><tr><td align="right"><code>+(a::Integer, b::PolyElem)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::PolyElem, b::Integer)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::fmpz, b::PolyElem)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::PolyElem, b::fmpz)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::T, b::PolyElem{T})</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::PolyElem{T}, b::T)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>-(a::Integer, b::PolyElem)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::PolyElem, b::Integer)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::fmpz, b::PolyElem)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::PolyElem, b::fmpz)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::T, b::PolyElem{T})</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::PolyElem{T}, b::T)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>*(a::Integer, b::PolyElem)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::PolyElem, b::Integer)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::fmpz, b::PolyElem)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::PolyElem, b::fmpz)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::T, b::PolyElem{T})</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::PolyElem{T}, b::T)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>divexact(a::PolyElem, b::Integer)</code></td><td align="right">exact division</td></tr><tr><td align="right"><code>divexact(a::PolyElem, b::fmpz)</code></td><td align="right">exact division</td></tr><tr><td align="right"><code>divexact{T &lt;: RingElem}(a::PolyElem{T}, b::T)</code></td><td align="right">exact division</td></tr><tr><td align="right"><code>^(a::PolyElem, n::Int)</code></td><td align="right">powering</td></tr></tbody></table><p>If the appropriate <code>promote_rule</code> and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.</p><p>Here are some examples of arithmetic operations on polynomials.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = f - g
k = f*g
m = f + g
n = g - 4
p = fmpz(5) - g
q = f*7
r = divexact(f, -1)
s = divexact(g*(x + 1), x + 1)
t = f^3
</code></pre><p><a id="Comparison-operators-1"></a></p><h2 id="comparison-operators">Comparison operators</h2><p>The following comparison operators are implemented for polynomials in Nemo. Julia provides the corresponding <code>!=</code> operator automatically.</p><p><a id="Function-1"></a></p><h2 id="function">Function</h2><p><code>isequal{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})</code><code>=={T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})</code></p><p>The <code>isequal</code> operation returns <code>true</code> if and only if all the coefficients of the polynomial are precisely equal as compared by <code>isequal</code>. This is a stronger form of equality, used for comparing inexact coefficients, such as elements of a power series ring, the <script type="math/tex">p</script>-adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal. </p><p>We also have the following ad hoc comparison operators.</p><p><a id="Function-2"></a></p><h2 id="function_1">Function</h2><p><code>=={T &lt;: RingElem}(a::PolyElem{T}, b::T)</code><code>=={T &lt;: RingElem}(a::T, b::PolyElem{T})</code><code>==(a::PolyElem, b::Integer)</code><code>==(a::Integer, b::PolyElem)</code><code>==(a::PolyElem, b::fmpz)</code><code>==(a::fmpz, b::PolyElem)</code></p><p>Here are some examples of comparisons.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = x*y^2 + (x + 1)*y + 3
h = S(3)

f == g
isequal(f, g)
f != 3
g != x
h == fmpz(3)
</code></pre><p><a id="Truncation-1"></a></p><h2 id="truncation">Truncation</h2><p><a href="#Base.truncate-Tuple{Nemo.PolyElem,Int64}" id="Base.truncate-Tuple{Nemo.PolyElem,Int64}">#</a><strong><code>Base.truncate</code></strong> — <em>Method</em>.</p><pre><code>truncate(a::PolyElem, n::Int)
</code></pre><blockquote><p>Return <script type="math/tex">a</script> truncated to <script type="math/tex">n</script> terms.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L861" target="_blank">source</a><br/></p><p><a href="#Nemo.mullow-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem},Int64}" id="Nemo.mullow-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem},Int64}">#</a><strong><code>Nemo.mullow</code></strong> — <em>Method</em>.</p><pre><code>mullow{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T}, n::Int)
</code></pre><blockquote><p>Return <script type="math/tex">a\times b</script> truncated to <script type="math/tex">n</script> terms.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L881" target="_blank">source</a><br/></p><p>Here are some examples of truncated operations.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = truncate(f, 1)
k = mullow(f, g, 4)
</code></pre><p><a id="Reversal-1"></a></p><h2 id="reversal">Reversal</h2><p><a href="#Base.reverse-Tuple{Nemo.PolyElem,Int64}" id="Base.reverse-Tuple{Nemo.PolyElem,Int64}">#</a><strong><code>Base.reverse</code></strong> — <em>Method</em>.</p><pre><code>reverse(x::PolyElem, len::Int)
</code></pre><blockquote><p>Return the reverse of the polynomial <script type="math/tex">x</script>, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length).  The resulting polynomial is normalised. If <code>len</code> is negative we throw a <code>DomainError()</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L925" target="_blank">source</a><br/></p><p><a href="#Base.reverse-Tuple{Nemo.PolyElem}" id="Base.reverse-Tuple{Nemo.PolyElem}">#</a><strong><code>Base.reverse</code></strong> — <em>Method</em>.</p><pre><code>reverse(x::PolyElem)
</code></pre><blockquote><p>Return the reverse of the polynomial <script type="math/tex">x</script>, i.e. the leading coefficient of <script type="math/tex">x</script> becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L944" target="_blank">source</a><br/></p><p>Here are some examples of reversal.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = reverse(f, 7)
h = reverse(f)
</code></pre><p><a id="Shifting-1"></a></p><h2 id="shifting">Shifting</h2><p><a href="#Nemo.shift_left-Tuple{Nemo.PolyElem,Int64}" id="Nemo.shift_left-Tuple{Nemo.PolyElem,Int64}">#</a><strong><code>Nemo.shift_left</code></strong> — <em>Method</em>.</p><pre><code>shift_left(x::PolyElem, n::Int)
</code></pre><blockquote><p>Return the polynomial <script type="math/tex">f</script> shifted left by <script type="math/tex">n</script> terms, i.e. multiplied by <script type="math/tex">x^n</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L960" target="_blank">source</a><br/></p><p><a href="#Nemo.shift_right-Tuple{Nemo.PolyElem,Int64}" id="Nemo.shift_right-Tuple{Nemo.PolyElem,Int64}">#</a><strong><code>Nemo.shift_right</code></strong> — <em>Method</em>.</p><pre><code>shift_right(f::PolyElem, n::Int)
</code></pre><blockquote><p>Return the polynomial <script type="math/tex">f</script> shifted right by <script type="math/tex">n</script> terms, i.e. divided by <script type="math/tex">x^n</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L982" target="_blank">source</a><br/></p><p>Here are some examples of shifting.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = shift_left(f, 7)
h = shift_right(f, 2)
</code></pre><p><a id="Modulo-arithmetic-1"></a></p><h2 id="modulo-arithmetic">Modulo arithmetic</h2><p>For polynomials over a field or residue ring, we can reduce modulo a given polynomial. This isn't always well-defined in the case of a residue ring, but when it is well-defined, we obtain the correct result. If Nemo encounters an impossible inverse, an exception will be raised.</p><p><a href="#Nemo.mulmod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Nemo.mulmod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Nemo.mulmod</code></strong> — <em>Method</em>.</p><pre><code>mulmod{T &lt;: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T}, d::PolyElem{T})
</code></pre><blockquote><p>Return <script type="math/tex">a\times b \pmod{d}</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1010" target="_blank">source</a><br/></p><p><a href="#Nemo.powmod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Int64,Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Nemo.powmod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Int64,Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Nemo.powmod</code></strong> — <em>Method</em>.</p><pre><code>powmod{T &lt;: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::Int, d::PolyElem{T})
</code></pre><blockquote><p>Return <script type="math/tex">a^b \pmod{d}</script>. There are no restrictions on <script type="math/tex">b</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1020" target="_blank">source</a><br/></p><p><a href="#Nemo.powmod-Tuple{Nemo.fmpz_mod_poly,Nemo.fmpz,Nemo.fmpz_mod_poly}" id="Nemo.powmod-Tuple{Nemo.fmpz_mod_poly,Nemo.fmpz,Nemo.fmpz_mod_poly}">#</a><strong><code>Nemo.powmod</code></strong> — <em>Method</em>.</p><pre><code>powmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)
</code></pre><blockquote><p>Return <script type="math/tex">x^e \pmod{y}</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_mod_poly.jl#L587" target="_blank">source</a><br/></p><p><a href="#Base.invmod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Base.invmod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Base.invmod</code></strong> — <em>Method</em>.</p><pre><code>invmod{T &lt;: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})
</code></pre><blockquote><p>Return <script type="math/tex">a^{-1} \pmod{d}</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1057" target="_blank">source</a><br/></p><p>Here are some examples of modular arithmetic.</p><pre><code>R, x = PolynomialRing(QQ, "x")
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, "y")

f = (3*x^2 + x + 2)*y + x^2 + 1
g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1
h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1

invmod(f, g)
mulmod(f, g, h)
powmod(f, 3, h)
</code></pre><p><a id="Euclidean-division-1"></a></p><h2 id="euclidean-division">Euclidean division</h2><p>For polynomials over a field, we have a euclidean domain, and in many cases for polynomials over a residue ring things behave as though we had a euclidean domain so long as we don't hit an impossible inverse. For such rings we define euclidean division of polynomials. If an impossible inverse is hit, we raise an exception.</p><p><a href="#Base.mod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Base.mod-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Base.mod</code></strong> — <em>Method</em>.</p><pre><code>mod{T &lt;: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})
</code></pre><blockquote><p>Return <script type="math/tex">f \pmod{g}</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1160" target="_blank">source</a><br/></p><p><a href="#Base.divrem-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Base.divrem-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Base.divrem</code></strong> — <em>Method</em>.</p><pre><code>divrem{T &lt;: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})
</code></pre><blockquote><p>Return a tuple <script type="math/tex">(q, r)</script> such that <script type="math/tex">f = qg + r</script> where <script type="math/tex">q</script> is the euclidean quotient of <script type="math/tex">f</script> by <script type="math/tex">g</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1189" target="_blank">source</a><br/></p><p>Here are some examples of euclidean division.</p><pre><code>R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)
U, y = PolynomialRing(T, "y")

f = y^3 + x*y^2 + (x + 1)*y + 3
g = (x + 1)*y^2 + (x^3 + 2x + 2)

h = mod(f, g)
q, r = divrem(f, g)
</code></pre><p><a id="Pseudodivision-1"></a></p><h2 id="pseudodivision">Pseudodivision</h2><p>Given two polynomials <script type="math/tex">a, b</script>, pseudodivision computes polynomials <script type="math/tex">q</script> and <script type="math/tex">r</script> with length<script type="math/tex">(r) <</script> length<script type="math/tex">(b)</script> such that <script type="math/tex">L^d a = bq + r,</script> where <script type="math/tex">d =</script> length<script type="math/tex">(a) -</script> length<script type="math/tex">(b) + 1</script> and <script type="math/tex">L</script> is the leading coefficient of <script type="math/tex">b</script>.</p><p>We call <script type="math/tex">q</script> the pseudoquotient and <script type="math/tex">r</script> the pseudoremainder.</p><p><a href="#Nemo.pseudorem-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Nemo.pseudorem-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Nemo.pseudorem</code></strong> — <em>Method</em>.</p><pre><code>pseudorem{T &lt;: RingElem}(f::PolyElem{T}, g::PolyElem{T})
</code></pre><blockquote><p>Return the pseudoremainder of <script type="math/tex">a</script> divided by <script type="math/tex">b</script>. If <script type="math/tex">b = 0</script> we throw a  <code>DivideError()</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1231" target="_blank">source</a><br/></p><p><a href="#Nemo.pseudodivrem-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Nemo.pseudodivrem-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Nemo.pseudodivrem</code></strong> — <em>Method</em>.</p><pre><code>pseudodivrem{T &lt;: RingElem}(f::PolyElem{T}, g::PolyElem{T})
</code></pre><blockquote><p>Return a tuple <script type="math/tex">(q, r)</script> consisting of the pseudoquotient and pseudoremainder  of <script type="math/tex">a</script> divided by <script type="math/tex">b</script>. If <script type="math/tex">b = 0</script> we throw a <code>DivideError()</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1252" target="_blank">source</a><br/></p><p>Here are some examples of pseudodivision.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = pseudorem(f, g)
q, r = pseudodivrem(f, g)
</code></pre><p><a id="Content,-primitive-part,-GCD-and-LCM-1"></a></p><h2 id="content-primitive-part-gcd-and-lcm">Content, primitive part, GCD and LCM</h2><p>In Nemo, we allow computation of the greatest common divisor of polynomials over any ring. This is enabled by making use of pseudoremainders when we aren't working over a euclidean domain or something mimicking such a domain. In certain cases this allows us to return a greatest common divisor when it otherwise wouldn't be possible. However, a greatest common divisor is not necessarily unique, or even well-defined.</p><p>If an impossible inverse is encountered whilst computing the greatest common divisor, an exception is thrown.</p><p><a href="#Base.gcd-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Base.gcd-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Base.gcd</code></strong> — <em>Method</em>.</p><pre><code>gcd{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})
</code></pre><blockquote><p>Return a greatest common divisor of <script type="math/tex">a</script> and <script type="math/tex">b</script> if it exists.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1431" target="_blank">source</a><br/></p><p><a href="#Base.lcm-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Base.lcm-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Base.lcm</code></strong> — <em>Method</em>.</p><pre><code>lcm{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})
</code></pre><blockquote><p>Return a least common multiple of <script type="math/tex">a</script> and <script type="math/tex">b</script> if it exists.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1532" target="_blank">source</a><br/></p><p><a href="#Nemo.content-Tuple{Nemo.PolyElem}" id="Nemo.content-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.content</code></strong> — <em>Method</em>.</p><pre><code>content(a::PolyElem)
</code></pre><blockquote><p>Return the content of <script type="math/tex">a</script>, i.e. the greatest common divisor of its coefficients.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1541" target="_blank">source</a><br/></p><p><a href="#Nemo.primpart-Tuple{Nemo.PolyElem}" id="Nemo.primpart-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.primpart</code></strong> — <em>Method</em>.</p><pre><code>primpart(a::PolyElem)
</code></pre><blockquote><p>Return the primitive part of <script type="math/tex">a</script>, i.e. the polynomial divided by its content.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1558" target="_blank">source</a><br/></p><p><a href="#Base.gcdx-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Base.gcdx-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Base.gcdx</code></strong> — <em>Method</em>.</p><pre><code>gcdx{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})
</code></pre><blockquote><p>Return a tuple <script type="math/tex">(r, s, t)</script> such that <script type="math/tex">r</script> is the resultant of <script type="math/tex">a</script> and <script type="math/tex">b</script> and such that <script type="math/tex">r = a\times s + b\times t</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1882" target="_blank">source</a><br/></p><p><a href="#Base.gcdx-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Base.gcdx-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Base.gcdx</code></strong> — <em>Method</em>.</p><pre><code>gcdx{T &lt;: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})
</code></pre><blockquote><p>Return a tuple <script type="math/tex">(g, s, t)</script> such that <script type="math/tex">g</script> is the greatest common divisor of <script type="math/tex">a</script> and <script type="math/tex">b</script> and such that <script type="math/tex">r = a\times s + b\times t</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1942" target="_blank">source</a><br/></p><p><a href="#Nemo.gcdinv-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Nemo.gcdinv-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}},Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Nemo.gcdinv</code></strong> — <em>Method</em>.</p><pre><code>gcdinv{T &lt;: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})
</code></pre><blockquote><p>Return a tuple <script type="math/tex">(g, s)</script> such that <script type="math/tex">g</script> is the greatest common divisor of <script type="math/tex">a</script> and <script type="math/tex">b</script> and such that <script type="math/tex">s = a^{-1} \pmod{b}</script>. This function is useful for inverting modulo a polynomial and checking that it really was invertible.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1985" target="_blank">source</a><br/></p><p>Here are some examples of content, primitive part and GCD.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = y^2 + x + 1

n = content(k)
p = primpart(k*(x^2 + 1))
q = gcd(k*m, l*m)
r = lcm(k*m, l*m)

R, x = PolynomialRing(QQ, "x")
T = ResidueRing(R, x^3 + 3x + 1)
U, z = PolynomialRing(T, "z")

g = z^3 + 2z + 1
h = z^5 + 1

r, s, t = gcdx(g, h)
u, v = gcdinv(g, h)
</code></pre><p><a id="Evaluation,-composition-and-substitution-1"></a></p><h2 id="evaluation-composition-and-substitution">Evaluation, composition and substitution</h2><p><a href="#Nemo.evaluate-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},T&lt;:Nemo.RingElem}" id="Nemo.evaluate-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},T&lt;:Nemo.RingElem}">#</a><strong><code>Nemo.evaluate</code></strong> — <em>Method</em>.</p><pre><code>evaluate{T &lt;: RingElem}(a::PolyElem{T}, b::T)
</code></pre><blockquote><p>Evaluate the polynomial <script type="math/tex">a</script> at the value <script type="math/tex">b</script> and return the result.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1577" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate-Tuple{Nemo.PolyElem,Integer}" id="Nemo.evaluate-Tuple{Nemo.PolyElem,Integer}">#</a><strong><code>Nemo.evaluate</code></strong> — <em>Method</em>.</p><pre><code>evaluate(a::PolyElem, b::Integer)
</code></pre><blockquote><p>Evaluate the polynomial <script type="math/tex">a</script> at the value <script type="math/tex">b</script> and return the result.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1597" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate-Tuple{Nemo.PolyElem,Nemo.fmpz}" id="Nemo.evaluate-Tuple{Nemo.PolyElem,Nemo.fmpz}">#</a><strong><code>Nemo.evaluate</code></strong> — <em>Method</em>.</p><pre><code>evaluate(a::PolyElem, b::fmpz)
</code></pre><blockquote><p>Evaluate the polynomial <script type="math/tex">a</script> at the value <script type="math/tex">b</script> and return the result.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1605" target="_blank">source</a><br/></p><p><a id="Remove-and-valuation-1"></a></p><h2 id="remove-and-valuation">Remove and valuation</h2><p><a href="#Nemo.remove-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Nemo.remove-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Nemo.remove</code></strong> — <em>Method</em>.</p><pre><code>remove{T &lt;: RingElem}(z::PolyElem{T}, p::PolyElem{T})
</code></pre><blockquote><p>Computes the valuation of <script type="math/tex">z</script> at <script type="math/tex">p</script>, that is, the largest <script type="math/tex">k</script> such that <script type="math/tex">p^k</script> divides <script type="math/tex">z</script>. Additionally, <script type="math/tex">z/p^k</script> is returned as well.</p><p>See also <code>valuation</code>, which only returns the valuation.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1293" target="_blank">source</a><br/></p><p><a href="#Nemo.valuation-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Nemo.valuation-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Nemo.valuation</code></strong> — <em>Method</em>.</p><pre><code>valuation{T &lt;: RingElem}(z::PolyElem{T}, p::PolyElem{T})
</code></pre><blockquote><p>Computes the valuation of <script type="math/tex">z</script> at <script type="math/tex">p</script>, that is, the largest <script type="math/tex">k</script> such that <script type="math/tex">p^k</script> divides <script type="math/tex">z</script>.</p><p>See also <code>remove</code>, which also returns <script type="math/tex">z/p^k</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1317" target="_blank">source</a><br/></p><p><a href="#Nemo.divides-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Nemo.divides-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Nemo.divides</code></strong> — <em>Method</em>.</p><pre><code>divides{T &lt;: RingElem}(f::PolyElem{T}, g::PolyElem{T})
</code></pre><blockquote><p>Returns a pair consisting of a flag which is set to <code>true</code> if <script type="math/tex">f</script> divides <script type="math/tex">g</script> and <code>false</code> otherwise, and a polynomial <script type="math/tex">h</script> such that <script type="math/tex">f = gh</script> if such a polynomial exists. If not, the value of <script type="math/tex">h</script> is undetermined.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1329" target="_blank">source</a><br/></p><p><a href="#Nemo.divides-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},T&lt;:Nemo.RingElem}" id="Nemo.divides-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},T&lt;:Nemo.RingElem}">#</a><strong><code>Nemo.divides</code></strong> — <em>Method</em>.</p><pre><code>divides{T &lt;: RingElem}(f::PolyElem{T}, g::T)
</code></pre><blockquote><p>Returns a pair consisting of a flag which is set to <code>true</code> if <script type="math/tex">g</script> divides <script type="math/tex">f</script> and <code>false</code> otherwise, and a polynomial <script type="math/tex">h</script> such that <script type="math/tex">f = gh</script> if such a polynomial exists. If not, the value of <script type="math/tex">h</script> is undetermined.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1371" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.arb_poly,Integer}" id="Nemo.evaluate2-Tuple{Nemo.arb_poly,Integer}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::arb_poly, y::Integer)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L432" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.arb_poly,Float64}" id="Nemo.evaluate2-Tuple{Nemo.arb_poly,Float64}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::arb_poly, y::Float64)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L441" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.fmpz}" id="Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.fmpz}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::arb_poly, y::fmpz)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L450" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.fmpq}" id="Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.fmpq}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::arb_poly, y::fmpq)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L459" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.arb}" id="Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.arb}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::arb_poly, y::arb)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L388" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.acb}" id="Nemo.evaluate2-Tuple{Nemo.arb_poly,Nemo.acb}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::arb_poly, y::acb)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L410" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.acb_poly,Integer}" id="Nemo.evaluate2-Tuple{Nemo.acb_poly,Integer}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::acb_poly, y::Integer)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L419" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.acb_poly,Float64}" id="Nemo.evaluate2-Tuple{Nemo.acb_poly,Float64}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::acb_poly, y::Float64)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L428" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.fmpz}" id="Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.fmpz}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::acb_poly, y::fmpq)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L437" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.fmpq}" id="Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.fmpq}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::acb_poly, y::fmpq)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L446" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.arb}" id="Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.arb}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::acb_poly, y::arb)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L455" target="_blank">source</a><br/></p><p><a href="#Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.acb}" id="Nemo.evaluate2-Tuple{Nemo.acb_poly,Nemo.acb}">#</a><strong><code>Nemo.evaluate2</code></strong> — <em>Method</em>.</p><pre><code>evaluate2(x::acb_poly, y::acb)
</code></pre><blockquote><p>Return a tuple <script type="math/tex">p, q</script> consisting of the polynomial <script type="math/tex">x</script> evaluated at <script type="math/tex">y</script> and its derivative evaluated at <script type="math/tex">y</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L397" target="_blank">source</a><br/></p><p><a href="#Nemo.compose-Tuple{Nemo.PolyElem,Nemo.PolyElem}" id="Nemo.compose-Tuple{Nemo.PolyElem,Nemo.PolyElem}">#</a><strong><code>Nemo.compose</code></strong> — <em>Method</em>.</p><pre><code>compose(a::PolyElem, b::PolyElem)
</code></pre><blockquote><p>Compose the polynomial <script type="math/tex">a</script> with the polynomial <script type="math/tex">b</script> and return the result, i.e. return <script type="math/tex">a\circ b</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1613" target="_blank">source</a><br/></p><p><a href="#Nemo.subst-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Any}" id="Nemo.subst-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Any}">#</a><strong><code>Nemo.subst</code></strong> — <em>Method</em>.</p><pre><code>subst{T &lt;: RingElem}(f::PolyElem{T}, a::Any)
</code></pre><blockquote><p>Evaluate the polynomial <script type="math/tex">f</script> at <script type="math/tex">a</script>. Note that <script type="math/tex">a</script> can be anything, whether a ring element or not.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L2364" target="_blank">source</a><br/></p><p>We also overload the functional notation so that the polynomial <script type="math/tex">f</script> can be evaluated at <script type="math/tex">a</script> by writing <script type="math/tex">f(a)</script>. This feature is only available with  Julia 0.5 however.</p><p>Here are some examples of polynomial evaluation, composition and substitution.</p><pre><code>RR = RealField(64)
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(RR, "z")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
h = z^2 + 2z + 1
M = R[x + 1 2x; x - 3 2x - 1]

k = evaluate(f, 3)
m = evaluate(f, x^2 + 2x + 1)
n = compose(f, g)
p = subst(f, M)
q = f(M)
r = f(23)
s, t = evaluate2(h, RR("2.0 +/- 0.1"))
</code></pre><p><a id="Derivative-and-integral-1"></a></p><h2 id="derivative-and-integral">Derivative and integral</h2><p><a href="#Nemo.derivative-Tuple{Nemo.PolyElem}" id="Nemo.derivative-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.derivative</code></strong> — <em>Method</em>.</p><pre><code>derivative(a::PolyElem)
</code></pre><blockquote><p>Return the derivative of the polynomial <script type="math/tex">a</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1641" target="_blank">source</a><br/></p><p><a href="#Nemo.integral-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}" id="Nemo.integral-Tuple{Nemo.PolyElem{T&lt;:Union{Nemo.FieldElem,Nemo.ResElem}}}">#</a><strong><code>Nemo.integral</code></strong> — <em>Method</em>.</p><pre><code>integral{T &lt;: Union{ResElem, FieldElem}}(x::PolyElem{T})
</code></pre><blockquote><p>Return the integral of the polynomial <script type="math/tex">a</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1665" target="_blank">source</a><br/></p><p>Here are some examples of integral and derivative.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(QQ, "z")
U = ResidueRing(T, z^3 + 3z + 1)
V, w = PolynomialRing(U, "w")

f = x*y^2 + (x + 1)*y + 3
g = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4

h = derivative(f)
k = integral(g)   
</code></pre><p><a id="Resultant-and-discriminant-1"></a></p><h2 id="resultant-and-discriminant">Resultant and discriminant</h2><p><a href="#Nemo.resultant-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}" id="Nemo.resultant-Tuple{Nemo.PolyElem{T&lt;:Nemo.RingElem},Nemo.PolyElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Nemo.resultant</code></strong> — <em>Method</em>.</p><pre><code>resultant{T &lt;: RingElem}(a::PolyElem{T}, b::PolyElem{T})
</code></pre><blockquote><p>Return the resultant of the <script type="math/tex">a</script> and <script type="math/tex">b</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1691" target="_blank">source</a><br/></p><p><a href="#Nemo.discriminant-Tuple{Nemo.PolyElem}" id="Nemo.discriminant-Tuple{Nemo.PolyElem}">#</a><strong><code>Nemo.discriminant</code></strong> — <em>Method</em>.</p><pre><code>discriminant(a::PolyElem)
</code></pre><blockquote><p>Return the discrimnant of the given polynomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L1860" target="_blank">source</a><br/></p><p>Here are some examples of computing the resultant and discriminant.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)

h = resultant(f, g)
k = discriminant(f)
</code></pre><p><a id="Newton-representation-1"></a></p><h2 id="newton-representation">Newton representation</h2><p><a href="#Nemo.monomial_to_newton!-Tuple{Array{T&lt;:Nemo.RingElem,1},Array{T&lt;:Nemo.RingElem,1}}" id="Nemo.monomial_to_newton!-Tuple{Array{T&lt;:Nemo.RingElem,1},Array{T&lt;:Nemo.RingElem,1}}">#</a><strong><code>Nemo.monomial_to_newton!</code></strong> — <em>Method</em>.</p><pre><code>monomial_to_newton!{T &lt;: RingElem}(P::Array{T, 1}, roots::Array{T, 1})
</code></pre><blockquote><p>Converts a polynomial <script type="math/tex">p</script>, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots <script type="math/tex">r_0, r_1, \ldots, r_{n-2}</script>. In other words, this determines output coefficients <script type="math/tex">c_i</script> such that <script type="math/tex">c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \ldots + c_{n-1}(x-r_0)(x-r_1)\cdots(x-r_{n-2})</script> is equal to the input polynomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L2038" target="_blank">source</a><br/></p><p><a href="#Nemo.newton_to_monomial!-Tuple{Array{T&lt;:Nemo.RingElem,1},Array{T&lt;:Nemo.RingElem,1}}" id="Nemo.newton_to_monomial!-Tuple{Array{T&lt;:Nemo.RingElem,1},Array{T&lt;:Nemo.RingElem,1}}">#</a><strong><code>Nemo.newton_to_monomial!</code></strong> — <em>Method</em>.</p><pre><code>newton_to_monomial!{T &lt;: RingElem}(P::Array{T, 1}, roots::Array{T, 1})
</code></pre><blockquote><p>Converts a polynomial <script type="math/tex">p</script>, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots <script type="math/tex">r_0, r_1, \ldots, r_{n-2}</script> to the standard monomial basis. In other words, this evaluates <script type="math/tex">c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \ldots + c_{n-1}(x-r_0)(x-r_1)\cdots(x-r_{n-2})</script> where <script type="math/tex">c_i</script> are the input coefficients given by <script type="math/tex">p</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L2062" target="_blank">source</a><br/></p><p>Here are some examples of conversion to and from Newton representation.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = deepcopy(f)
roots = [R(1), R(2), R(3)]

monomial_to_newton!(g.coeffs, roots)
newton_to_monomial!(g.coeffs, roots)
</code></pre><p><a id="Multipoint-evaluation-and-interpolation-1"></a></p><h2 id="multipoint-evaluation-and-interpolation">Multipoint evaluation and interpolation</h2><p><a href="#Nemo.interpolate-Tuple{Nemo.PolyRing,Array{T&lt;:Nemo.RingElem,1},Array{T&lt;:Nemo.RingElem,1}}" id="Nemo.interpolate-Tuple{Nemo.PolyRing,Array{T&lt;:Nemo.RingElem,1},Array{T&lt;:Nemo.RingElem,1}}">#</a><strong><code>Nemo.interpolate</code></strong> — <em>Method</em>.</p><pre><code>interpolate{T &lt;: RingElem}(S::PolyRing, x::Array{T, 1}, y::Array{T, 1})
</code></pre><blockquote><p>Given two arrays of values <script type="math/tex">xs</script> and <script type="math/tex">ys</script> of the same length <script type="math/tex">n</script>, find the polynomial <script type="math/tex">f</script> in the polynomial ring <script type="math/tex">R</script> of length at most <script type="math/tex">n</script> such that <script type="math/tex">f</script> has the value <script type="math/tex">ys</script> at the points <script type="math/tex">xs</script>. The values in the arrays <script type="math/tex">xs</script> and <script type="math/tex">ys</script> must belong to the base ring of the polynomial ring <script type="math/tex">R</script>. If no such polynomial exists, an exception is raised.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L2093" target="_blank">source</a><br/></p><p>Here is an example of interpolation.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

xs = [R(1), R(2), R(3), R(4)]
ys = [R(1), R(4), R(9), R(16)]

f = interpolate(S, xs, ys)
</code></pre><p><a id="Signature-1"></a></p><h2 id="signature">Signature</h2><p>Signature is only available for certain coefficient rings.</p><p><a href="#Nemo.signature-Tuple{Nemo.fmpz_poly}" id="Nemo.signature-Tuple{Nemo.fmpz_poly}">#</a><strong><code>Nemo.signature</code></strong> — <em>Method</em>.</p><pre><code>signature(f::fmpz_poly)
</code></pre><blockquote><p>Return the signature of the polynomial <script type="math/tex">f</script>, i.e. a tuple <script type="math/tex">(r, s)</script> such that <script type="math/tex">r</script> is the number of real roots of <script type="math/tex">f</script> and <script type="math/tex">s</script> is half the number of complex roots.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_poly.jl#L567" target="_blank">source</a><br/></p><p><a href="#Nemo.signature-Tuple{Nemo.fmpq_poly}" id="Nemo.signature-Tuple{Nemo.fmpq_poly}">#</a><strong><code>Nemo.signature</code></strong> — <em>Method</em>.</p><pre><code>signature(f::fmpq_poly)
</code></pre><blockquote><p>Return the signature of <script type="math/tex">f</script>, i.e. a tuple <script type="math/tex">(r, s)</script> where <script type="math/tex">r</script> is the number of real roots of <script type="math/tex">f</script> and <script type="math/tex">s</script> is half the number of complex roots.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpq_poly.jl#L652" target="_blank">source</a><br/></p><p>Here is an example of signature.</p><pre><code>R, x = PolynomialRing(ZZ, "x")

f = x^3 + 3x + 1

(r, s) = signature(f)
</code></pre><p><a id="Root-finding-1"></a></p><h2 id="root-finding">Root finding</h2><p><a href="#Nemo.roots-Tuple{Nemo.acb_poly}" id="Nemo.roots-Tuple{Nemo.acb_poly}">#</a><strong><code>Nemo.roots</code></strong> — <em>Method</em>.</p><pre><code>roots(x::acb_poly; target=0, isolate_real=false, initial_prec=0, max_prec=0, max_iter=0)
</code></pre><blockquote><p>Attempts to isolate the complex roots of the complex polynomial <script type="math/tex">x</script> by iteratively refining balls in which they lie.</p><p>This is done by increasing the working precision, starting at <code>initial_prec</code>. The maximal number of iterations can be set using <code>max_iter</code> and the maximal precision can be set using <code>max_prec</code>.</p><p>If <code>isolate_real</code> is set and <script type="math/tex">x</script> is strictly real, then the real roots will be isolated from the non-real roots. Every root will have either zero, positive or negative real part.</p><p>It is assumed that <script type="math/tex">x</script> is squarefree.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L613" target="_blank">source</a><br/></p><p>Here is an example of finding complex roots.</p><pre><code>CC = ComplexField(64)
C, y = PolynomialRing(CC, "y")

m = y^2 + 2y + 3
n = m + CC("0 +/- 0.0001", "0 +/- 0.0001")

r = roots(n)

p = y^7 - 1

r = roots(n, isolate_real = true)
</code></pre><p><a id="Construction-from-roots-1"></a></p><h2 id="construction-from-roots">Construction from roots</h2><p><a href="#Nemo.from_roots-Tuple{Nemo.ArbPolyRing,Array{Nemo.arb,1}}" id="Nemo.from_roots-Tuple{Nemo.ArbPolyRing,Array{Nemo.arb,1}}">#</a><strong><code>Nemo.from_roots</code></strong> — <em>Method</em>.</p><pre><code>from_roots(R::ArbPolyRing, b::Array{arb, 1})
</code></pre><blockquote><p>Construct a polynomial in the given polynomial ring from a list of its roots.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L535" target="_blank">source</a><br/></p><p><a href="#Nemo.from_roots-Tuple{Nemo.AcbPolyRing,Array{Nemo.acb,1}}" id="Nemo.from_roots-Tuple{Nemo.AcbPolyRing,Array{Nemo.acb,1}}">#</a><strong><code>Nemo.from_roots</code></strong> — <em>Method</em>.</p><pre><code>from_roots(R::AcbPolyRing, b::Array{acb, 1})
</code></pre><blockquote><p>Construct a polynomial in the given polynomial ring from a list of its roots.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L531" target="_blank">source</a><br/></p><p>Here are some examples of constructing polynomials from their roots.</p><pre><code>RR = RealField(64)
R, x = PolynomialRing(RR, "x")

xs = arb[inv(RR(i)) for i=1:5]
f = from_roots(R, xs)
</code></pre><p><a id="Lifting-1"></a></p><h2 id="lifting">Lifting</h2><p>When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from <script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> to <script type="math/tex">\mathbb{Z}</script>.</p><p><a href="#Nemo.lift-Tuple{Nemo.FmpzPolyRing,Nemo.nmod_poly}" id="Nemo.lift-Tuple{Nemo.FmpzPolyRing,Nemo.nmod_poly}">#</a><strong><code>Nemo.lift</code></strong> — <em>Method</em>.</p><pre><code>function lift(R::FmpzPolyRing, y::nmod_poly)
</code></pre><blockquote><p>Lift from a polynomial over <script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> to a polynomial over <script type="math/tex">\mathbb{Z}</script> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/nmod_poly.jl#L687" target="_blank">source</a><br/></p><p><a href="#Nemo.lift-Tuple{Nemo.FmpzPolyRing,Nemo.fmpz_mod_poly}" id="Nemo.lift-Tuple{Nemo.FmpzPolyRing,Nemo.fmpz_mod_poly}">#</a><strong><code>Nemo.lift</code></strong> — <em>Method</em>.</p><pre><code>function lift(R::FmpzPolyRing, y::fmpz_mod_poly)
</code></pre><blockquote><p>Lift from a polynomial over <script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> to a polynomial over <script type="math/tex">\mathbb{Z}</script> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_mod_poly.jl#L689" target="_blank">source</a><br/></p><p>Here is an example of lifting.</p><pre><code>R = ResidueRing(ZZ, 123456789012345678949)
S, x = PolynomialRing(R, "x")
T, y = PolynomialRing(ZZ, "y")

f = x^2 + 2x + 1

a = lift(T, f)
</code></pre><p><a id="Overlapping-and-containment-1"></a></p><h2 id="overlapping-and-containment">Overlapping and containment</h2><p>Occasionally it is useful to be able to tell when inexact polynomials overlap or contain other exact or inexact polynomials. The following functions are provided for this purpose.</p><p><a href="#Nemo.overlaps-Tuple{Nemo.arb_poly,Nemo.arb_poly}" id="Nemo.overlaps-Tuple{Nemo.arb_poly,Nemo.arb_poly}">#</a><strong><code>Nemo.overlaps</code></strong> — <em>Method</em>.</p><pre><code>overlaps(x::arb_poly, y::arb_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <script type="math/tex">x</script> overlap the coefficient balls of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L107" target="_blank">source</a><br/></p><p><a href="#Nemo.overlaps-Tuple{Nemo.acb_poly,Nemo.acb_poly}" id="Nemo.overlaps-Tuple{Nemo.acb_poly,Nemo.acb_poly}">#</a><strong><code>Nemo.overlaps</code></strong> — <em>Method</em>.</p><pre><code>overlaps(x::acb_poly, y::acb_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <script type="math/tex">x</script> overlap the coefficient boxes of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L107" target="_blank">source</a><br/></p><p><a href="#Base.contains-Tuple{Nemo.arb_poly,Nemo.arb_poly}" id="Base.contains-Tuple{Nemo.arb_poly,Nemo.arb_poly}">#</a><strong><code>Base.contains</code></strong> — <em>Method</em>.</p><pre><code>contains(x::arb_poly, y::arb_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <script type="math/tex">x</script> contain the corresponding coefficient balls of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L117" target="_blank">source</a><br/></p><p><a href="#Base.contains-Tuple{Nemo.acb_poly,Nemo.acb_poly}" id="Base.contains-Tuple{Nemo.acb_poly,Nemo.acb_poly}">#</a><strong><code>Base.contains</code></strong> — <em>Method</em>.</p><pre><code>contains(x::acb_poly, y::acb_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <script type="math/tex">x</script> contain the corresponding coefficient boxes of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L117" target="_blank">source</a><br/></p><p><a href="#Base.contains-Tuple{Nemo.arb_poly,Nemo.fmpz_poly}" id="Base.contains-Tuple{Nemo.arb_poly,Nemo.fmpz_poly}">#</a><strong><code>Base.contains</code></strong> — <em>Method</em>.</p><pre><code>contains(x::arb_poly, y::fmpz_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <script type="math/tex">x</script> contain the corresponding exact coefficients of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L127" target="_blank">source</a><br/></p><p><a href="#Base.contains-Tuple{Nemo.arb_poly,Nemo.fmpq_poly}" id="Base.contains-Tuple{Nemo.arb_poly,Nemo.fmpq_poly}">#</a><strong><code>Base.contains</code></strong> — <em>Method</em>.</p><pre><code>contains(x::arb_poly, y::fmpq_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <script type="math/tex">x</script> contain the corresponding exact coefficients of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L137" target="_blank">source</a><br/></p><p><a href="#Base.contains-Tuple{Nemo.acb_poly,Nemo.fmpz_poly}" id="Base.contains-Tuple{Nemo.acb_poly,Nemo.fmpz_poly}">#</a><strong><code>Base.contains</code></strong> — <em>Method</em>.</p><pre><code>contains(x::acb_poly, y::fmpz_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <script type="math/tex">x</script> contain the corresponding exact coefficients of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L127" target="_blank">source</a><br/></p><p><a href="#Base.contains-Tuple{Nemo.acb_poly,Nemo.fmpq_poly}" id="Base.contains-Tuple{Nemo.acb_poly,Nemo.fmpq_poly}">#</a><strong><code>Base.contains</code></strong> — <em>Method</em>.</p><pre><code>contains(x::acb_poly, y::fmpq_poly)
</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <script type="math/tex">x</script> contain the corresponding exact coefficients of <script type="math/tex">y</script>, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L137" target="_blank">source</a><br/></p><p>It is sometimes also useful to be able to determine if there is a unique integer contained in the coefficient of an inexact constant polynomial.</p><p><a href="#Nemo.unique_integer-Tuple{Nemo.arb_poly}" id="Nemo.unique_integer-Tuple{Nemo.arb_poly}">#</a><strong><code>Nemo.unique_integer</code></strong> — <em>Method</em>.</p><pre><code>unique_integer(x::arb_poly)
</code></pre><blockquote><p>Return a tuple <code>(t, z)</code> where <script type="math/tex">t</script> is <code>true</code> if there is a unique integer contained in each of the coefficients of <script type="math/tex">x</script>, otherwise sets <script type="math/tex">t</script> to <code>false</code>. In the former case, <script type="math/tex">z</script> is set to the integer polynomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/arb_poly.jl#L168" target="_blank">source</a><br/></p><p><a href="#Nemo.unique_integer-Tuple{Nemo.acb_poly}" id="Nemo.unique_integer-Tuple{Nemo.acb_poly}">#</a><strong><code>Nemo.unique_integer</code></strong> — <em>Method</em>.</p><pre><code>unique_integer(x::acb_poly)
</code></pre><blockquote><p>Return a tuple <code>(t, z)</code> where <script type="math/tex">t</script> is <code>true</code> if there is a unique integer contained in the (constant) polynomial <script type="math/tex">x</script>, along with that integer <script type="math/tex">z</script> in case it is, otherwise sets <script type="math/tex">t</script> to <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L168" target="_blank">source</a><br/></p><p>We also have the following functions.</p><p><a href="#Base.isreal-Tuple{Nemo.acb_poly}" id="Base.isreal-Tuple{Nemo.acb_poly}">#</a><strong><code>Base.isreal</code></strong> — <em>Method</em>.</p><pre><code>isreal(x::acb_poly)
</code></pre><blockquote><p>Return <code>true</code> if all the coefficients of <script type="math/tex">x</script> are real, i.e. have exact zero imaginary parts.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/arb/acb_poly.jl#L181" target="_blank">source</a><br/></p><p>Here are some examples of overlapping and containment.</p><pre><code>RR = RealField(64)
CC = ComplexField(64)
R, x = PolynomialRing(RR, "x")
C, y = PolynomialRing(CC, "y")
Zx, zx = PolynomialRing(ZZ, "x")
Qx, qx = PolynomialRing(QQ, "x")

f = x^2 + 2x + 1
h = f + RR("0 +/- 0.0001")
k = f + RR("0 +/- 0.0001") * x^4
m = y^2 + 2y + 1
n = m + CC("0 +/- 0.0001", "0 +/- 0.0001")

contains(h, f)
overlaps(f, k)
contains(n, m)
t, z = unique_integer(k)
isreal(n)
</code></pre><p><a id="Factorisation-1"></a></p><h2 id="factorisation">Factorisation</h2><p>Polynomials can only be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.</p><p><a href="#Nemo.isirreducible-Tuple{Nemo.nmod_poly}" id="Nemo.isirreducible-Tuple{Nemo.nmod_poly}">#</a><strong><code>Nemo.isirreducible</code></strong> — <em>Method</em>.</p><pre><code>isirreducible(x::nmod_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is irreducible, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/nmod_poly.jl#L707" target="_blank">source</a><br/></p><p><a href="#Nemo.isirreducible-Tuple{Nemo.fmpz_mod_poly}" id="Nemo.isirreducible-Tuple{Nemo.fmpz_mod_poly}">#</a><strong><code>Nemo.isirreducible</code></strong> — <em>Method</em>.</p><pre><code>isirreducible(x::fmpz_mod_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is irreducible, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_mod_poly.jl#L709" target="_blank">source</a><br/></p><p><a href="#Nemo.isirreducible-Tuple{Nemo.fq_poly}" id="Nemo.isirreducible-Tuple{Nemo.fq_poly}">#</a><strong><code>Nemo.isirreducible</code></strong> — <em>Method</em>.</p><pre><code>isirreducible(x::fq_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is irreducible, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_poly.jl#L544" target="_blank">source</a><br/></p><p><a href="#Nemo.isirreducible-Tuple{Nemo.fq_nmod_poly}" id="Nemo.isirreducible-Tuple{Nemo.fq_nmod_poly}">#</a><strong><code>Nemo.isirreducible</code></strong> — <em>Method</em>.</p><pre><code>isirreducible(x::fq_nmod_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is irreducible, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_nmod_poly.jl#L546" target="_blank">source</a><br/></p><p><a href="#Nemo.issquarefree-Tuple{Nemo.nmod_poly}" id="Nemo.issquarefree-Tuple{Nemo.nmod_poly}">#</a><strong><code>Nemo.issquarefree</code></strong> — <em>Method</em>.</p><pre><code>issquarefree(x::nmod_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is squarefree, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/nmod_poly.jl#L723" target="_blank">source</a><br/></p><p><a href="#Nemo.issquarefree-Tuple{Nemo.fmpz_mod_poly}" id="Nemo.issquarefree-Tuple{Nemo.fmpz_mod_poly}">#</a><strong><code>Nemo.issquarefree</code></strong> — <em>Method</em>.</p><pre><code>issquarefree(x::fmpz_mod_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is squarefree, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_mod_poly.jl#L725" target="_blank">source</a><br/></p><p><a href="#Nemo.issquarefree-Tuple{Nemo.fq_poly}" id="Nemo.issquarefree-Tuple{Nemo.fq_poly}">#</a><strong><code>Nemo.issquarefree</code></strong> — <em>Method</em>.</p><pre><code>issquarefree(x::fq_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is squarefree, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_poly.jl#L560" target="_blank">source</a><br/></p><p><a href="#Nemo.issquarefree-Tuple{Nemo.fq_nmod_poly}" id="Nemo.issquarefree-Tuple{Nemo.fq_nmod_poly}">#</a><strong><code>Nemo.issquarefree</code></strong> — <em>Method</em>.</p><pre><code>issquarefree(x::fq_nmod_poly)
</code></pre><blockquote><p>Return <code>true</code> if <script type="math/tex">x</script> is squarefree, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_nmod_poly.jl#L562" target="_blank">source</a><br/></p><p><a href="#Base.factor-Tuple{Nemo.fmpz_poly}" id="Base.factor-Tuple{Nemo.fmpz_poly}">#</a><strong><code>Base.factor</code></strong> — <em>Method</em>.</p><pre><code>factor(x::fmpz_poly)
</code></pre><blockquote><p>Returns the factorization of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_poly.jl#L613" target="_blank">source</a><br/></p><p><a href="#Base.factor-Tuple{Nemo.nmod_poly}" id="Base.factor-Tuple{Nemo.nmod_poly}">#</a><strong><code>Base.factor</code></strong> — <em>Method</em>.</p><pre><code>factor(x::nmod_poly)
</code></pre><blockquote><p>Return the factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/nmod_poly.jl#L739" target="_blank">source</a><br/></p><p><a href="#Base.factor-Tuple{Nemo.fmpz_mod_poly}" id="Base.factor-Tuple{Nemo.fmpz_mod_poly}">#</a><strong><code>Base.factor</code></strong> — <em>Method</em>.</p><pre><code>factor(x::fmpz_mod_poly)
</code></pre><blockquote><p>Return the factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_mod_poly.jl#L741" target="_blank">source</a><br/></p><p><a href="#Base.factor-Tuple{Nemo.fq_poly}" id="Base.factor-Tuple{Nemo.fq_poly}">#</a><strong><code>Base.factor</code></strong> — <em>Method</em>.</p><pre><code>factor(x::fq_poly)
</code></pre><blockquote><p>Return the factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_poly.jl#L575" target="_blank">source</a><br/></p><p><a href="#Base.factor-Tuple{Nemo.fq_nmod_poly}" id="Base.factor-Tuple{Nemo.fq_nmod_poly}">#</a><strong><code>Base.factor</code></strong> — <em>Method</em>.</p><pre><code>factor(x::fq_nmod_poly)
</code></pre><blockquote><p>Return the factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_nmod_poly.jl#L577" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_squarefree-Tuple{Nemo.nmod_poly}" id="Nemo.factor_squarefree-Tuple{Nemo.nmod_poly}">#</a><strong><code>Nemo.factor_squarefree</code></strong> — <em>Method</em>.</p><pre><code>factor_squarefree(x::nmod_poly)
</code></pre><blockquote><p>Return the squarefree factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/nmod_poly.jl#L764" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_squarefree-Tuple{Nemo.fmpz_mod_poly}" id="Nemo.factor_squarefree-Tuple{Nemo.fmpz_mod_poly}">#</a><strong><code>Nemo.factor_squarefree</code></strong> — <em>Method</em>.</p><pre><code>factor_squarefree(x::fmpz_mod_poly)
</code></pre><blockquote><p>Return the squarefree factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_mod_poly.jl#L766" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_squarefree-Tuple{Nemo.fq_poly}" id="Nemo.factor_squarefree-Tuple{Nemo.fq_poly}">#</a><strong><code>Nemo.factor_squarefree</code></strong> — <em>Method</em>.</p><pre><code>factor_squarefree(x::fq_poly)
</code></pre><blockquote><p>Return the squarefree factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_poly.jl#L604" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_squarefree-Tuple{Nemo.fq_nmod_poly}" id="Nemo.factor_squarefree-Tuple{Nemo.fq_nmod_poly}">#</a><strong><code>Nemo.factor_squarefree</code></strong> — <em>Method</em>.</p><pre><code>factor_squarefree(x::fq_nmod_poly)
</code></pre><blockquote><p>Return the squarefree factorisation of <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_nmod_poly.jl#L606" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_distinct_deg-Tuple{Nemo.nmod_poly}" id="Nemo.factor_distinct_deg-Tuple{Nemo.nmod_poly}">#</a><strong><code>Nemo.factor_distinct_deg</code></strong> — <em>Method</em>.</p><pre><code>factor_distinct_deg(x::nmod_poly)
</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/nmod_poly.jl#L788" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_distinct_deg-Tuple{Nemo.fmpz_mod_poly}" id="Nemo.factor_distinct_deg-Tuple{Nemo.fmpz_mod_poly}">#</a><strong><code>Nemo.factor_distinct_deg</code></strong> — <em>Method</em>.</p><pre><code>factor_distinct_deg(x::fmpz_mod_poly)
</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_mod_poly.jl#L791" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_distinct_deg-Tuple{Nemo.fq_poly}" id="Nemo.factor_distinct_deg-Tuple{Nemo.fq_poly}">#</a><strong><code>Nemo.factor_distinct_deg</code></strong> — <em>Method</em>.</p><pre><code>factor_distinct_deg(x::fq_poly)
</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_poly.jl#L630" target="_blank">source</a><br/></p><p><a href="#Nemo.factor_distinct_deg-Tuple{Nemo.fq_nmod_poly}" id="Nemo.factor_distinct_deg-Tuple{Nemo.fq_nmod_poly}">#</a><strong><code>Nemo.factor_distinct_deg</code></strong> — <em>Method</em>.</p><pre><code>factor_distinct_deg(x::fq_nmod_poly)
</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <script type="math/tex">x</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fq_nmod_poly.jl#L632" target="_blank">source</a><br/></p><p>Here are some examples of factorisation.</p><pre><code>R = ResidueRing(ZZ, 23)
S, x = PolynomialRing(R, "x")

f = x^2 + 2x + 1
g = x^3 + 3x + 1

R = factor(f*g)
S = factor_squarefree(f*g)
T = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))
</code></pre><p><a id="Special-functions-1"></a></p><h2 id="special-functions">Special functions</h2><p>The following special functions can be computed for any polynomial ring. Typically one uses the generator <script type="math/tex">x</script> of a polynomial ring to get the respective special polynomials expressed in terms of that generator.</p><p><a href="#Nemo.chebyshev_t-Tuple{Int64,Nemo.PolyElem}" id="Nemo.chebyshev_t-Tuple{Int64,Nemo.PolyElem}">#</a><strong><code>Nemo.chebyshev_t</code></strong> — <em>Method</em>.</p><pre><code>chebyshev_t(n::Int, x::PolyElem)
</code></pre><blockquote><p>Return the Chebyshev polynomial of the first kind <script type="math/tex">T_n(x)</script>, defined by  <script type="math/tex">T_n(x) = \cos(n \cos^{-1}(x))</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L2154" target="_blank">source</a><br/></p><p><a href="#Nemo.chebyshev_u-Tuple{Int64,Nemo.PolyElem}" id="Nemo.chebyshev_u-Tuple{Int64,Nemo.PolyElem}">#</a><strong><code>Nemo.chebyshev_u</code></strong> — <em>Method</em>.</p><pre><code>chebyshev_u(n::Int, x::PolyElem)
</code></pre><blockquote><p>Return the Chebyshev polynomial of the first kind <script type="math/tex">U_n(x)</script>, defined by  <script type="math/tex">(n+1) U_n(x) = T'_{n+1}(x)</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/generic/Poly.jl#L2194" target="_blank">source</a><br/></p><p>The following special polynomials are only available for certain base rings.</p><p><a href="#Nemo.cyclotomic-Tuple{Int64,Nemo.fmpz_poly}" id="Nemo.cyclotomic-Tuple{Int64,Nemo.fmpz_poly}">#</a><strong><code>Nemo.cyclotomic</code></strong> — <em>Method</em>.</p><pre><code>cyclotomic(n::Int, x::fmpz_poly)
</code></pre><blockquote><p>Return the <script type="math/tex">n</script>th cyclotomic polynomial, defined as <script type="math/tex">\Phi_n(x) = \prod_{\omega} (x-\omega),</script> where <script type="math/tex">\omega</script> runs over all the  <script type="math/tex">n</script>th primitive roots of unity.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_poly.jl#L666" target="_blank">source</a><br/></p><p><a href="#Nemo.swinnerton_dyer-Tuple{Int64,Nemo.fmpz_poly}" id="Nemo.swinnerton_dyer-Tuple{Int64,Nemo.fmpz_poly}">#</a><strong><code>Nemo.swinnerton_dyer</code></strong> — <em>Method</em>.</p><pre><code>swinnerton_dyer(n::Int, x::fmpz_poly)
</code></pre><blockquote><p>Return the Swinnerton-Dyer polynomial <script type="math/tex">S_n</script>, defined as the integer  polynomial <script type="math/tex">S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3} \pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})</script>  where <script type="math/tex">p_n</script> denotes the <script type="math/tex">n</script>-th prime number and all combinations of signs are taken. This polynomial has degree <script type="math/tex">2^n</script> and is irreducible over the integers (it is the minimal polynomial of <script type="math/tex">\sqrt{2} + \ldots + \sqrt{p_n}</script>).</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_poly.jl#L679" target="_blank">source</a><br/></p><p><a href="#Nemo.cos_minpoly-Tuple{Int64,Nemo.fmpz_poly}" id="Nemo.cos_minpoly-Tuple{Int64,Nemo.fmpz_poly}">#</a><strong><code>Nemo.cos_minpoly</code></strong> — <em>Method</em>.</p><pre><code>cos_minpoly(n::Int, x::fmpz_poly)
</code></pre><blockquote><p>Return the minimal polynomial of <script type="math/tex">2 \cos(2 \pi / n)</script>. For suitable choice of  <script type="math/tex">n</script>, this gives the minimal polynomial of <script type="math/tex">2 \cos(a \pi)</script> or <script type="math/tex">2 \sin(a \pi)</script> for any rational <script type="math/tex">a</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_poly.jl#L695" target="_blank">source</a><br/></p><p><a href="#Nemo.theta_qexp-Tuple{Int64,Int64,Nemo.fmpz_poly}" id="Nemo.theta_qexp-Tuple{Int64,Int64,Nemo.fmpz_poly}">#</a><strong><code>Nemo.theta_qexp</code></strong> — <em>Method</em>.</p><pre><code>theta_qexp(e::Int, n::Int, x::fmpz_poly)
</code></pre><blockquote><p>Return the <script type="math/tex">q</script>-expansion to length <script type="math/tex">n</script> of the Jacobi theta function raised to the power <script type="math/tex">r</script>, i.e. <script type="math/tex">\vartheta(q)^r</script> where  <script type="math/tex">\vartheta(q) = 1 + \sum_{k=1}^{\infty} q^{k^2}</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_poly.jl#L708" target="_blank">source</a><br/></p><p><a href="#Nemo.eta_qexp-Tuple{Int64,Int64,Nemo.fmpz_poly}" id="Nemo.eta_qexp-Tuple{Int64,Int64,Nemo.fmpz_poly}">#</a><strong><code>Nemo.eta_qexp</code></strong> — <em>Method</em>.</p><pre><code>eta_qexp(e::Int, n::Int, x::fmpz_poly)
</code></pre><blockquote><p>Return the <script type="math/tex">q</script>-expansion to length <script type="math/tex">n</script> of the Dedekind eta function (without  the leading factor <script type="math/tex">q^{1/24}</script>) raised to the power <script type="math/tex">r</script>, i.e. <script type="math/tex">(q^{-1/24} \eta(q))^r = \prod_{k=1}^{\infty} (1 - q^k)^r</script>. In particular, <script type="math/tex">r = -1</script> gives the generating function of the partition function <script type="math/tex">p(k)</script>, and <script type="math/tex">r = 24</script> gives, after multiplication by <script type="math/tex">q</script>, the modular discriminant <script type="math/tex">\Delta(q)</script> which generates the Ramanujan tau function <script type="math/tex">\tau(k)</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/58e80e13410c968f12caa8f0771d19da9e5ff645/src/flint/fmpz_poly.jl#L721" target="_blank">source</a><br/></p><p>Here are some examples of special functions.</p><pre><code>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = chebyshev_t(20, y)
g = chebyshev_u(15, y)
h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
o = cyclotomic(10, 1 + x + x^2)
</code></pre></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a class="btn btn-neutral float-right" href="../series/" title="Capped relative power series">Next <span class="icon icon-circle-arrow-right"></span></a><a class="btn btn-neutral" href="../constructors/" title="Parent object constructors"><span class="icon icon-circle-arrow-left"></span> Previous</a></div><hr/><div role="contentinfo"></div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer></div></div></section></div><div class="rst-versions" role="note" style="cursor: pointer"><span class="rst-current-version" data-toggle="rst-current-version"><a class="fa fa-github" href="https://github.com/Nemocas/Nemo.jl" style="float: left; color: #fcfcfc"> GitHub</a><span><a href="../constructors/" style="color: #fcfcfc;">« Previous</a></span><span style="margin-left: 15px"><a href="../series/" style="color: #fcfcfc">Next »</a></span></span></div><script src="../js/theme.js"></script><script src="../mathjaxhelper.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script></body></HTML>