export absolute_degree, absolute_norm, absolute_tr, absolute_frobenius,
       absolute_charpoly, prime_field

import AbstractAlgebra: _absolute_basis

################################################################################
#
#  Additional predicate
#
################################################################################

is_absolute(F::FqField) = F.isabsolute

################################################################################
#
#  Base field
#
################################################################################

function base_field(F::FqField)
  # if it is relative, then the base_field will be set
  # otherwise, it is the prime field
  if !isdefined(F, :base_field)
    F.base_field = prime_field(F)
  end

  return F.base_field::FqField
end

################################################################################
#
#  Prime field
#
################################################################################

# Should be cached on the field
function prime_field(F::FqField)
  # We want them to be equal among all finite fields
  return FqField(characteristic(F), 1, Symbol("#"), true)
end

################################################################################
#
#  Internal coercion into base/prime field
#
################################################################################

# Need this for the trace and norm
function _coerce_to_base_field(a::FqFieldElem)
  L = parent(a)
  K = base_field(L)
  if is_absolute(L)
    return K(lift(ZZ, a))
  else
    return L.preimage_basefield(a)
  end
end

function _coerce_to_prime_field(a::FqFieldElem)
  L = parent(a)
  K = prime_field(L)
  return K(lift(ZZ, a))
end

function defining_polynomial(L::FqField)
  if !isdefined(L, :defining_poly)
    @assert is_absolute(L)
    F = polynomial_ring(prime_field(L), "x", cached = false)[1]
    L.defining_poly = F(map(lift, collect(coefficients(modulus(L)))))
  end
  return L.defining_poly::FqPolyRingElem
end

################################################################################
#
#  Degree
#
################################################################################

@doc Markdown.doc"""
    degree(a::FqField)

Return the degree of the given finite field.
"""
function degree(a::FqField)
  if is_absolute(a)
    return _degree(a)
  else
    return degree(a.defining_poly)
  end
end

@doc Markdown.doc"""
    absolute_degree(a::FqField)

Return the degree of the given finite field over the prime field.
"""
function absolute_degree(F::FqField)
  if is_absolute(F)
    return _degree(F)
  else
    return absolute_degree(base_field(F)) * degree(defining_polynomial(F))
  end
end

################################################################################
#
#  Algebra generator
#
################################################################################

@doc Markdown.doc"""
    gen(a::FqField)

Return the generator of the finite field. Note that this is only guaranteed
to be a multiplicative generator if the finite field is generated by a
Conway polynomial automatically.
"""
function gen(L::FqField)
  # should not be cached (for in place stuff etc)
  if is_absolute(L)
    return _gen(L)
  else
    L.forwardmap(gen(parent(defining_polynomial(L))))
  end
end

@doc Markdown.doc"""
    is_gen(a::FqFieldElem)

Return `true` if the given finite field element is the generator of the
finite field, otherwise return `false`.
"""
function is_gen(a::FqFieldElem)
  L = parent(a)
  if is_absolute(L)
    return _is_gen(a)
  else
    return a == L.forwardmap(gen(parent(defining_polynomial(L))))
  end
end

################################################################################
#
#  Write element as polynomial
#
################################################################################

# assumes that we are not absolute, but we are not checking this
function _as_poly(a::FqFieldElem)
  if a.poly !== nothing
    return a.poly::FqPolyRingElem
  else
    g = parent(a).backwardmap(a)
    a.poly = g
    return g::FqPolyRingElem
  end
end

################################################################################
#
#  Coeff
#
################################################################################

@doc Markdown.doc"""
    coeff(x::FqFieldElem, n::Int)

Return the degree $n$ coefficient (as an element of the base field) of the
polynomial representing the given finite field element.
"""
function coeff(x::FqFieldElem, n::Int)
   if is_absolute(parent(x))
     return _coeff(x, n)
   end
   return coeff(_as_poly(x), n)
end

################################################################################
#
#  Frobenius
#
################################################################################

# adjust docstring
@doc Markdown.doc"""
    frobenius(x::FqFieldElem, n = 1)

Return the iterated Frobenius $x^{q^n}$ of an element $x$, where $q$ is the
order of the base field. By default the Frobenius map is applied $n = 1$ times
if $n$ is not specified.
"""
function frobenius(x::FqFieldElem, n = 1)
   # we want x -> x^#base_field
   z = parent(x)()
   if is_absolute(parent(x))
     m = n
   else
     m = n * absolute_degree(base_field(parent(x)))
   end
   return _frobenius(x, m)
end

@doc Markdown.doc"""
    absolute_frobenius(x::FqFieldElem, n = 1)

Return the iterated absolute Frobenius $x^{p^n}$, where $p$ is the
characteristic of the parent of $x$. By default the Frobenius map is applied $n
= 1$ times if $n$ is not specified.
"""
function absolute_frobenius(x::FqFieldElem, n = 1)
  return _frobenius(x, n)
end

################################################################################
#
#  Basis
#
################################################################################

@doc Markdown.doc"""
    basis(F::FqField)

Return the list $1,a,a^2,\dotsc,a^{d-1}$, where $d$ is the degree of $F$ and
$a$ its generator.
"""
function basis(F::FqField)
  return powers(gen(F), degree(F) - 1)
end

# internal for now
function _absolute_basis(F::FqField)
  if is_absolute(F)
    return basis(F)
  else
    res = elem_type(F)[]
    kabs = _absolute_basis(base_field(F))
    for b in basis(F)
      for c in kabs
        push!(res, F(c) * b)
      end
    end
    return res
  end
end

################################################################################
#
#  Minimal polynomial
#
################################################################################

function minpoly(a::FqFieldElem)
  return minpoly(polynomial_ring(base_field(parent(a)), "x", cached = false)[1], a)
end

function minpoly(Rx::FqPolyRing, a::FqFieldElem)
  @assert base_ring(Rx) === base_field(parent(a))
  c = [a]
  fa = frobenius(a)
  while !(fa in c)
    push!(c, fa)
    fa = frobenius(fa)
  end
  St = polynomial_ring(parent(a), "x", cached = false)[1]
  f = prod([gen(St) - x for x = c], init = one(St))
  g = Rx()
  for i = 0:degree(f)
    setcoeff!(g, i, _coerce_to_base_field(coeff(f, i)))
  end
  return g
end

function absolute_minpoly(a::FqFieldElem)
  return absolute_minpoly(polynomial_ring(prime_field(parent(a)), "x", cached = false)[1], a)
end

function absolute_minpoly(Rx::FqPolyRing, a::FqFieldElem)
  @assert base_ring(Rx) === prime_field(parent(a))
  c = [a]
  fa = absolute_frobenius(a)
  while !(fa in c)
    push!(c, fa)
    fa = absolute_frobenius(fa)
  end
  St = polynomial_ring(parent(a), "x", cached = false)[1]
  f = prod([gen(St) - x for x = c], init = one(St))
  g = Rx()
  for i = 0:degree(f)
    setcoeff!(g, i, _coerce_to_prime_field(coeff(f, i)))
  end
  return g
end

################################################################################
#
#  Characteristic polynomial
#
################################################################################

function charpoly(a::FqFieldElem)
  return charpoly(polynomial_ring(base_field(parent(a)), "x", cached = false)[1], a)
end

function charpoly(Rx::FqPolyRing, a::FqFieldElem)
  f = minpoly(Rx, a)
  d = divexact(degree(parent(a)), degree(f))
  return f^d
end

function absolute_charpoly(a::FqFieldElem)
  return absolute_charpoly(polynomial_ring(prime_field(parent(a)), "x", cached = false)[1], a)
end

function absolute_charpoly(Rx::FqPolyRing, a::FqFieldElem)
  f = absolute_minpoly(Rx, a)
  d = divexact(absolute_degree(parent(a)), degree(f))
  return f^d
end

################################################################################
#
#  Norm
#
################################################################################

@doc Markdown.doc"""
    norm(x::FqFieldElem)

Return the norm of $x$. This is an element of the base field.
"""
function norm(a::FqFieldElem)
  # Should probably use resultant, but _as_poly is not that fast at the moment?
  if is_absolute(parent(a))
    return base_field(parent(a))(_norm(a))
  end
  d = degree(parent(a))
  f = charpoly(a)
  return isodd(d) ? -constant_coefficient(f) : constant_coefficient(f)
end

@doc Markdown.doc"""
    absolute_norm(x::FqFieldElem)

Return the absolute norm of $x$. This is an element of the prime field.
"""
function absolute_norm(a::FqFieldElem)
  return prime_field(parent(a))(_norm(a))
end

@doc Markdown.doc"""
    tr(x::FqFieldElem)

Return the trace of $x$. This is an element of the base field.
"""
function tr(a::FqFieldElem)
  if is_absolute(parent(a))
    return base_field(parent(a))(_tr(a))
  end
  d = degree(parent(a))
  f = charpoly(a)
  return -coeff(f, d - 1)
end

@doc Markdown.doc"""
    absolute_Tr(x::FqFieldElem)

Return the absolute trace of $x$. This is an element of the prime field.
"""
function absolute_tr(a::FqFieldElem)
  return prime_field(parent(a))(_tr(a))
end

################################################################################
#
#  Embedding helper
#
################################################################################

# I just need one embedding which I fix once and for all
# This is used to embed K into L \cong K[x]/(f)
# TODO: Improve this or just use embed(K, L) once it works
function _embed(K::FqField, L::FqField)
  if absolute_degree(K) == 1
    return x -> begin
      y = L(coeff(lift(ZZ["x"][1], x), 0))
    end
  else
    # must be absolute minpoly
    g = absolute_minpoly(_gen(K))
    e = _embed(prime_field(K), L)
    a = roots(map_coefficients(e, g))[1]
    return x -> begin
      return sum(_coeff(x, i)*a^i for i in 0:(absolute_degree(K) - 1))
    end
  end
end

################################################################################
#
#  Print the internal presentation for debugging purposes
#
################################################################################

struct _fq_default_dummy
  a
end

function expressify(a::_fq_default_dummy; context = nothing)
   x = a.a.parent.var
   d = _degree(a.a.parent)

   sum = Expr(:call, :+)
   for k in (d - 1):-1:0
        c = _coeff(a.a, k)
        iszero(c) && continue
        xk = k < 1 ? 1 : k == 1 ? x : Expr(:call, :^, x, k)
        push!(sum.args, isone(c) ? Expr(:call, :*, xk) :
                         Expr(:call, :*, expressify(c, context = context), xk))
    end
    return sum
end

show_raw(io::IO, a::FqFieldElem) =
  println(io, AbstractAlgebra.obj_to_string(_fq_default_dummy(a), context = io))

################################################################################
#
#  Constructor for relative extensions
#
################################################################################


const FqDefaultFiniteFieldIDFqDefaultPoly = Dict{Tuple{FqPolyRingElem, Symbol}, FqField}()

function FqField(f::FqPolyRingElem, s::Symbol, cached::Bool = false)
  return get_cached!(FqDefaultFiniteFieldIDFqDefaultPoly, (f, s), cached) do
    K = base_ring(f)
    p = characteristic(K)
    d = absolute_degree(K) * degree(f)
    L = FqField(p, d, s, cached)
    L.isabsolute = false
    L.defining_poly = f
    L.base_field = K
    # We also need to determine the map K[x]/(f) -> L
    # First embed K into L
    e = _embed(K, L)
    # Push f to L
    foverL = map_coefficients(e, f)
    a = roots(foverL)[1]
    # Found the map K[x]/(f) -> L
    forwardmap = y -> evaluate(map_coefficients(e, y), a)
    Kabs = _absolute_basis(K)
    Fp = prime_field(K)
    # We have no natural coercion Fp -> K
    eabs = _embed(Fp, K)
    # Determine inverse of forwardmap using linear algebra
    # First determine the matrix representing forwardmap
    forwardmat = zero_matrix(Fp, d, d)
    l = 1
    x = gen(parent(f))
    xi = powers(x, degree(f) - 1)
    for i in 0:(degree(f) - 1)
      for b in Kabs
        v = forwardmap(b * xi[i + 1])
        for j in 1:_degree(L)
          forwardmat[l, j] = _coeff(v, j - 1)
        end
        l += 1
      end
    end
    forwardmatinv = inv(forwardmat)
    backwardmap = y -> begin
      w = matrix(Fp, 1, d, [_coeff(y, j - 1) for j in 1:d])
      ww = [Fp(_coeff(y, j - 1)) for j in 1:d]
      _abs_gen_rel = zero(parent(f))
      fl, vv = can_solve_with_solution(forwardmat, w, side = :left)
      vvv = ww * forwardmatinv
      @assert fl
      l = 1
      for i in 0:(degree(f) - 1)
        for b in Kabs
          _abs_gen_rel += eabs(vv[1, l]) * b * xi[i + 1]
          l += 1
        end
      end
      return _abs_gen_rel
    end
    backwardmap_basefield = y -> begin
      w = matrix(Fp, 1, d, [_coeff(y, j - 1) for j in 1:d])
      fl, vv = can_solve_with_solution(forwardmat, w, side = :left)
      @assert fl
      @assert all(iszero, (vv[1, i] for i in (absolute_degree(K) + 1):d))
      return sum(eabs(vv[1, i]) * Kabs[i] for i in 1:absolute_degree(K))
    end

    u = rand(K)
    @assert backwardmap_basefield(forwardmap(u*x^0)) == u

    L.forwardmap = forwardmap
    L.backwardmap = backwardmap
    L.image_basefield = e
    L.preimage_basefield = backwardmap_basefield
    return L
  end::FqField
end

################################################################################
#
#  Constructors
#
################################################################################

function NGFiniteField(a::IntegerUnion, s::AbstractString = "o"; cached::Bool = true, check::Bool = true)
  fl, p, e = is_prime_power_with_data(a)
  !fl && error("Order must be a prime power")
  return NGFiniteField(p, e, s; cached = cached, check = false)
end

function NGFiniteField(f::FqPolyRingElem, s::AbstractString = "o"; cached::Bool = true, check::Bool = true)
  (check && isirreducible(f)) || error("Defining polynomial must be irreducible")
  # Should probably have its own cache
  F = FqField(f, Symbol(s), cached)
  return F, gen(F)
end

_FiniteField(a...; kw...) = NGFiniteField(a...; kw...)

function _GF(a::IntegerUnion, s = AbstractString = "o"; cached::Bool = true, check::Bool = true)
  return NGFiniteField(a, s; cached = cached, check = check)[1]
end

function _GF(a::IntegerUnion, b::Int, s = AbstractString = "o"; cached::Bool = true, check::Bool = true)
  return NGFiniteField(a, b, s; cached = cached, check = check)[1]
end

################################################################################
#
#  Fancy coercion
#
################################################################################

function (a::FqField)(b::FqFieldElem)
  k = parent(b)
  if k === a
    return b
  end

  if is_absolute(a)
    da = degree(a)
    dk = degree(k)
    if dk < da
      da % dk != 0 && error("Coercion impossible")
      f = embed(k, a)
      return f(b)
    else
      dk % da != 0 && error("Coercion impossible")
      f = preimage_map(a, k)
      return f(b)
    end
  end

  if k === base_field(a)
    return (a.image_basefield)(b)
  end

  # To make it work in towers
  return a(base_field(a)(b))
end
