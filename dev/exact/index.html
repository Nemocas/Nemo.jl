<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exact real and complex numbers · Nemo.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Nemo.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><a class="tocitem" href="../about/">About Nemo</a></li><li><a class="tocitem" href="../types/">Types in Nemo</a></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in Nemo</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../integer/">Integers</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomials</a></li><li><a class="tocitem" href="../mpolynomial/">Multivariate polynomials</a></li><li><a class="tocitem" href="../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../puiseux/">Puiseux series</a></li><li><a class="tocitem" href="../residue/">Residue rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../fraction/">Fraction fields</a></li><li><a class="tocitem" href="../rational/">Rationals</a></li><li><a class="tocitem" href="../algebraic/">Algebraic numbers</a></li><li class="is-active"><a class="tocitem" href>Exact real and complex numbers</a><ul class="internal"><li><a class="tocitem" href="#Calcium-field-options"><span>Calcium field options</span></a></li><li><a class="tocitem" href="#Basic-examples"><span>Basic examples</span></a></li><li><a class="tocitem" href="#Conversions-and-numerical-evaluation"><span>Conversions and numerical evaluation</span></a></li><li><a class="tocitem" href="#Comparisons-and-properties"><span>Comparisons and properties</span></a></li><li><a class="tocitem" href="#Infinities-and-special-values"><span>Infinities and special values</span></a></li><li><a class="tocitem" href="#Complex-parts"><span>Complex parts</span></a></li><li><a class="tocitem" href="#Elementary-and-special-functions"><span>Elementary and special functions</span></a></li><li><a class="tocitem" href="#Rewriting-and-simplification"><span>Rewriting and simplification</span></a></li></ul></li><li><a class="tocitem" href="../complex/">Arbitrary precision complex balls</a></li><li><a class="tocitem" href="../real/">Arbitrary precision real balls</a></li><li><a class="tocitem" href="../arb/">Fixed precision real balls</a></li><li><a class="tocitem" href="../acb/">Fixed precisioncomplex balls</a></li><li><a class="tocitem" href="../gfp/">Galois fields</a></li><li><a class="tocitem" href="../finitefield/">Finite fields</a></li><li><a class="tocitem" href="../ff_embedding/">Finite field embeddings</a></li><li><a class="tocitem" href="../numberfield/">Number field arithmetic</a></li><li><a class="tocitem" href="../padic/">Padics</a></li><li><a class="tocitem" href="../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../matrix/">Matrices</a></li><li><a class="tocitem" href="../factor/">Factorisation</a></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../developer/introduction/">Introduction to Nemo development</a></li><li><a class="tocitem" href="../developer/conventions/">Conventions</a></li><li><a class="tocitem" href="../developer/typesystem/">The type system</a></li><li><a class="tocitem" href="../developer/parents/">Parent objects</a></li><li><a class="tocitem" href="../developer/interfaces/">Interfaces</a></li><li><a class="tocitem" href="../developer/topics/">Specific topics</a></li><li><a class="tocitem" href="../developer/future/">Future plans</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Fields</a></li><li class="is-active"><a href>Exact real and complex numbers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exact real and complex numbers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/exact.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exact-real-and-complex-numbers"><a class="docs-heading-anchor" href="#Exact-real-and-complex-numbers">Exact real and complex numbers</a><a id="Exact-real-and-complex-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-real-and-complex-numbers" title="Permalink"></a></h1><p>Exact real and complex numbers are provided by Calcium. Internally, a number <span>$z$</span> is represented as an element of an extension field of the rational numbers. That is,</p><p class="math-container">\[z \in \mathbb{Q}(a_1,\ldots,a_n)\]</p><p>where <span>$a_1, \ldots, a_n$</span> are symbolically defined algebraic or transcendental real or complex numbers such as <span>$\pi$</span>, <span>$\sqrt{2}$</span> or <span>$e^{\sqrt{2} \pi i}$</span>. The user does not normally need to worry about the details of the internal representation; Calcium constructs extension numbers and fields automatically as needed to perform operations.</p><p>The user must create a <code>CalciumField</code> instance which represents the mathematical domain <span>$\mathbb{C}$</span>. This parent object holds a cache of extension numbers and fields used to represent individual elements. It also stores various options for evaluation (documented further below).</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Calcium</td><td style="text-align: right"><code>ca</code></td><td style="text-align: right"><code>CalciumField</code></td></tr></table><p>Please note the following:</p><ul><li><p>It is in the nature of exact complex arithmetic that some operations must be implemented using incomplete heuristics. For example, testing whether an element is zero will not always succeed. When Calcium is unable to perform a task, Nemo will throw an exception. This ensures that Calcium fields behave exactly and never silently return wrong results.</p></li><li><p>Calcium elements can optionally hold special non-numerical values:</p><ul><li><p>Unsigned infinity <span>$\hat \infty$</span></p></li><li><p>Signed infinities (<span>$\pm \infty$</span>, <span>$\pm i \infty$</span>, and more generally <span>$e^{i \theta} \cdot \infty$</span>)</p></li><li><p>Undefined</p></li><li><p>Unknown</p></li></ul><p>By default, such special values are disallowed so that a <code>CalciumField</code> represents the mathematical field <span>$\mathbb{C}$</span>, and any operation that would result in a special value (for example, <span>$1 / 0 = \hat \infty$</span>) will throw an exception. To allow special values, pass <code>extended=true</code> to the <code>CalciumField</code> constructor.</p></li><li><p><code>CalciumField</code> instances only support single-threaded use. You must create a separate parent object for each thread to do parallel computation.</p></li><li><p>When performing an operation involving two <code>ca</code> operands with different parent objects, Nemo will arbitrarily coerce the operands (and hence the result) to one of the parents.</p></li></ul><h2 id="Calcium-field-options"><a class="docs-heading-anchor" href="#Calcium-field-options">Calcium field options</a><a id="Calcium-field-options-1"></a><a class="docs-heading-anchor-permalink" href="#Calcium-field-options" title="Permalink"></a></h2><p>The <code>CalciumField</code> parent stores various options that affect simplification power, performance, or appearance. The user can override any of the default values using <code>C = CalciumField(options=dict)</code> where <code>dict</code> is a dictionary with <code>Symbol =&gt; Int</code> pairs. To retrieve the option values as a dictionary (including any default values not set by the user), call <code>options(C)</code>.</p><p>The following options are supported:</p><table><tr><th style="text-align: right">Option</th><th style="text-align: right">Explanation</th></tr><tr><td style="text-align: right"><code>:verbose</code></td><td style="text-align: right">Enable debug output</td></tr><tr><td style="text-align: right"><code>:print_flags</code></td><td style="text-align: right">Flags controlling print style</td></tr><tr><td style="text-align: right"><code>:mpoly_ord</code></td><td style="text-align: right">Monomial order for polynomials</td></tr><tr><td style="text-align: right"><code>:prec_limit</code></td><td style="text-align: right">Precision limit for numerical evaluation</td></tr><tr><td style="text-align: right"><code>:qqbar_deg_limit</code></td><td style="text-align: right">Degree limit for algebraic numbers</td></tr><tr><td style="text-align: right"><code>:low_prec</code></td><td style="text-align: right">Initial precision for numerical evaluation</td></tr><tr><td style="text-align: right"><code>:smooth_limit</code></td><td style="text-align: right">Factor size limit for smooth integer factorization</td></tr><tr><td style="text-align: right"><code>:lll_prec</code></td><td style="text-align: right">Precision for integer relation detection</td></tr><tr><td style="text-align: right"><code>:pow_limit</code></td><td style="text-align: right">Maximum exponent for in-field powering</td></tr><tr><td style="text-align: right"><code>:use_gb</code></td><td style="text-align: right">Enable Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_length_limit</code></td><td style="text-align: right">Maximum ideal basis length during Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_poly_length_limit</code></td><td style="text-align: right">Maximum polynomial length during Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_poly_bits_limit</code></td><td style="text-align: right">Maximum bit size during Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_vieta_limit</code></td><td style="text-align: right">Maximum degree to use Vieta&#39;s formulas</td></tr><tr><td style="text-align: right"><code>:trig_form</code></td><td style="text-align: right">Default form of trigonometric functions</td></tr></table><p>An important function of these options is to control how hard Calcium will try to find an answer before it gives up. For example:</p><ul><li><p>Setting <code>:prec_limit =&gt; 65536</code> will allow Calcium to use up to 65536 bits of precision (instead of the default 4096) to prove inequalities.</p></li><li><p>Setting <code>:qqbar_deg_limit =&gt; typemax(Int)</code> (instead of the default 120) will force most calculations involving algebraic numbers to run to completion, no matter how long this will take.</p></li><li><p>Setting <code>:use_gb =&gt; 0</code> (instead of the default 1) disables use of Gröbner bases. In general, this will negatively impact Calcium&#39;s ability to simplify field elements and prove equalities, but it can speed up calculations where Gröbner bases are unnecessary.</p></li></ul><p>For a detailed explanation, refer to the following section in the Calcium documentation: <a href="https://fredrikj.net/calcium/ca.html#context-options">https://fredrikj.net/calcium/ca.html#context-options</a></p><h2 id="Basic-examples"><a class="docs-heading-anchor" href="#Basic-examples">Basic examples</a><a id="Basic-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-examples" title="Permalink"></a></h2><pre><code class="language-julia hljs">julia&gt; C = CalciumField()
Exact Complex Field

julia&gt; exp(C(pi) * C(1im)) + 1
0

julia&gt; log(C(-1))
3.14159*I {a*b where a = 3.14159 [Pi], b = I [b^2+1=0]}

julia&gt; log(C(-1)) ^ 2
-9.86960 {-a^2 where a = 3.14159 [Pi], b = I [b^2+1=0]}

julia&gt; log(C(10)^23) // log(C(100))
11.5000 {23/2}

julia&gt; 4*atan(C(1)//5) - atan(C(1)//239) == C(pi)//4
true

julia&gt; Cx, x = polynomial_ring(C, &quot;x&quot;)
(Univariate Polynomial Ring in x over Exact Complex Field, x)

julia&gt; (a, b) = (sqrt(C(2)), sqrt(C(3)))
(1.41421 {a where a = 1.41421 [a^2-2=0]}, 1.73205 {a where a = 1.73205 [a^2-3=0]})

julia&gt; (x-a-b)*(x-a+b)*(x+a-b)*(x+a+b)
x^4 + (-10)*x^2 + 1</code></pre><h2 id="Conversions-and-numerical-evaluation"><a class="docs-heading-anchor" href="#Conversions-and-numerical-evaluation">Conversions and numerical evaluation</a><a id="Conversions-and-numerical-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions-and-numerical-evaluation" title="Permalink"></a></h2><p>Calcium numbers can created from integers (<code>ZZ</code>), rationals (<code>QQ</code>) and algebraic numbers (<code>QQbar</code>), and through the application of arithmetic operations and transcendental functions.</p><p>Calcium numbers can be converted to integers, rational and algebraic fields provided that the values are integer, rational or algebraic. An exception is thrown if the value does not belong to the target domain, if Calcium is unable to prove that the value belongs to the target domain, or if Calcium is unable to compute the explicit value because of evaluation limits.</p><pre><code class="language-julia hljs">julia&gt; QQ(C(1))
1

julia&gt; QQBar(sqrt(C(2)) // 2)
Root 0.707107 of 2x^2 - 1

julia&gt; QQ(C(pi))
ERROR: unable to convert to a rational number

julia&gt; QQ(C(10) ^ C(10^9))
ERROR: unable to convert to a rational number</code></pre><p>To compute arbitrary-precision numerical enclosures, convert to <code>ArbField</code> or <code>AcbField</code>:</p><pre><code class="language-julia hljs">julia&gt; CC = AcbField(64);

julia&gt; CC(exp(C(1im)))
[0.54030230586813971740 +/- 9.37e-22] + [0.84147098480789650665 +/- 2.51e-21]*im</code></pre><p>The constructor</p><pre><code class="language-julia hljs">(R::AcbField)(a::ca; parts::Bool=false)</code></pre><p>returns an enclosure of the complex number <em>a</em>. It attempts to obtain a relative accuracy of <em>prec</em> bits where <em>prec</em> is the precision of the target field, but it is not guaranteed that this goal is achieved.</p><p>If <em>parts</em> is set to <em>true</em>, it attempts to achieve the target accuracy for both real and imaginary parts. This can be significantly more expensive if one part is smaller than the other, or if the number is nontrivially purely real or purely imaginary (in which case an exact proof attempt is made).</p><pre><code class="language-julia hljs">julia&gt; x = sin(C(1), form=:exponential)
0.841471 + 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}

julia&gt; AcbField(64)(x)
[0.84147098480789650665 +/- 2.51e-21] + [+/- 4.77e-29]*im

julia&gt; AcbField(64)(x, parts=true)
[0.84147098480789650665 +/- 2.51e-21]</code></pre><p>The constructor</p><pre><code class="language-julia hljs">(R::ArbField)(a::ca; check::Bool=true)</code></pre><p>returns a real enclosure. If <em>check</em> is set to <em>true</em> (default), the number <em>a</em> is verified to be real, and an exception is thrown if this cannot be determined. With <em>check</em> set to <em>false</em>, this function returns an enclosure of the real part of <em>a</em> without checking that the imaginary part is zero. This can be significantly faster.</p><h2 id="Comparisons-and-properties"><a class="docs-heading-anchor" href="#Comparisons-and-properties">Comparisons and properties</a><a id="Comparisons-and-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Comparisons-and-properties" title="Permalink"></a></h2><p>Except where otherwise noted, predicate functions such as <code>iszero</code>, <code>==</code>, <code>&lt;</code> and <code>isreal</code> act on the mathematical values of Calcium field elements. For example, although evaluating <span>$x = \sqrt{2} \sqrt{3}$</span> and <span>$y = \sqrt{6}$</span> results in different internal representations (<span>$x \in \mathbb{Q}(\sqrt{3}, \sqrt{2})$</span> and <span>$y \in \mathbb{Q}(\sqrt{6})$</span>), the numbers compare as equal:</p><pre><code class="language-julia hljs">julia&gt; x = sqrt(C(2)) * sqrt(C(3))
2.44949 {a*b where a = 1.73205 [a^2-3=0], b = 1.41421 [b^2-2=0]}

julia&gt; y = sqrt(C(6))
2.44949 {a where a = 2.44949 [a^2-6=0]}

julia&gt; x == y
true

julia&gt; iszero(x - y)
true

julia&gt; isinteger(x - y)
true</code></pre><p>Predicate functions return <em>true</em> if the property is provably true and <em>false</em> if the property if provably false. If Calcium is unable to prove the truth value, an exception is thrown. For example, with default settings, Calcium is currently able to prove that <span>$e^{e^{-1000}} \ne 1$</span>, but it fails to prove <span>$e^{e^{-3000}} \ne 1$</span>:</p><pre><code class="language-julia hljs">julia&gt; x = exp(exp(C(-1000)))
1.00000 {a where a = 1.00000 [Exp(5.07596e-435 {b})], b = 5.07596e-435 [Exp(-1000)]}

julia&gt; x == 1
false

julia&gt; x = exp(exp(C(-3000)))
1.00000 {a where a = 1.00000 [Exp(1.30784e-1303 {b})], b = 1.30784e-1303 [Exp(-3000)]}

julia&gt; x == 1
ERROR: Unable to perform operation (failed deciding truth of a predicate): isequal
...</code></pre><p>In this case, we can get an answer by allowing a higher working precision:</p><pre><code class="language-julia hljs">julia&gt; C2 = CalciumField(options=Dict(:prec_limit =&gt; 10^5));

julia&gt; exp(exp(C2(-3000))) == 1
false</code></pre><p>Real numbers can be ordered and sorted the usual way. We illustrate finding square roots that are well-approximated by integers:</p><pre><code class="language-julia hljs">julia&gt; sort([sqrt(C(n)) for n=0:10], by=x -&gt; abs(x - floor(x + C(1)//2)))
11-element Vector{ca}:
 0
 1
 2
 3
 3.16228 {a where a = 3.16228 [a^2-10=0]}
 2.82843 {2*a where a = 1.41421 [a^2-2=0]}
 2.23607 {a where a = 2.23607 [a^2-5=0]}
 1.73205 {a where a = 1.73205 [a^2-3=0]}
 2.64575 {a where a = 2.64575 [a^2-7=0]}
 1.41421 {a where a = 1.41421 [a^2-2=0]}
 2.44949 {a where a = 2.44949 [a^2-6=0]}</code></pre><p>As currently implemented, order comparisons involving nonreal numbers yield <em>false</em> (in both directions) rather than throwing an exception:</p><pre><code class="language-julia hljs">julia&gt; C(1im) &lt; C(1im)
false

julia&gt; C(1im) &gt; C(1im)
false</code></pre><p>This behavior may be changed or may become configurable in the future.</p><p><strong>Interface</strong></p><article class="docstring"><header><a class="docstring-binding" id="Base.iszero-Tuple{ca}" href="#Base.iszero-Tuple{ca}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iszero(a::ca)</code></pre><p>Return whether <code>a</code> is the number 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isone-Tuple{ca}" href="#Base.isone-Tuple{ca}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isone(a::ca)</code></pre><p>Return whether <code>a</code> is the number 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_algebraic-Tuple{ca}" href="#Nemo.is_algebraic-Tuple{ca}"><code>Nemo.is_algebraic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_algebraic(a::ca)</code></pre><p>Return whether <code>a</code> is an algebraic number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_rational-Tuple{ca}" href="#Nemo.is_rational-Tuple{ca}"><code>Nemo.is_rational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_rational(a::ca)</code></pre><p>Return whether <code>a</code> is a rational number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isinteger-Tuple{ca}" href="#Base.isinteger-Tuple{ca}"><code>Base.isinteger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinteger(a::ca)</code></pre><p>Return whether <code>a</code> is an integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isreal-Tuple{ca}" href="#Base.isreal-Tuple{ca}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreal(a::ca)</code></pre><p>Return whether <code>a</code> is a real number. This returns <code>false</code> if <code>a</code> is a pure real infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_imaginary-Tuple{ca}" href="#Nemo.is_imaginary-Tuple{ca}"><code>Nemo.is_imaginary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_imaginary(a::ca)</code></pre><p>Return whether <code>a</code> is an imaginary number. This returns <code>false</code> if <code>a</code> is a pure imaginary infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L279">source</a></section></article><h2 id="Infinities-and-special-values"><a class="docs-heading-anchor" href="#Infinities-and-special-values">Infinities and special values</a><a id="Infinities-and-special-values-1"></a><a class="docs-heading-anchor-permalink" href="#Infinities-and-special-values" title="Permalink"></a></h2><p>By default, <code>CalciumField</code> does not permit creating values that are not numbers, and any non-number value (unsigned infinity, signed infinity, Undefined) will result in an exception. This also applies to the special value Unknown, used in situations where Calcium is unable to prove that a value is a number. To enable special values, use <code>extended=true</code>.</p><pre><code class="language-julia hljs">julia&gt; C = CalciumField()
Exact Complex Field

julia&gt; 1 // C(0)
ERROR: DomainError with UnsignedInfinity:
Non-number result
...

julia&gt; Cext = CalciumField(extended=true)
Exact Complex Field (Extended)

julia&gt; 1 // Cext(0)
UnsignedInfinity</code></pre><p>Note that special values do not satisfy the properties of a mathematical ring or field. You will likely get meaningless results if you put infinities in matrices or polynomials.</p><article class="docstring"><header><a class="docstring-binding" id="Nemo.unsigned_infinity-Tuple{CalciumField}" href="#Nemo.unsigned_infinity-Tuple{CalciumField}"><code>Nemo.unsigned_infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsigned_infinity(C::CalciumField)</code></pre><p>Return unsigned infinity (<span>$\hat \infty$</span>) as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.infinity-Tuple{CalciumField}" href="#Nemo.infinity-Tuple{CalciumField}"><code>Nemo.infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infinity(C::CalciumField)</code></pre><p>Return positive infinity (<span>$+\infty$</span>) as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.infinity-Tuple{ca}" href="#Nemo.infinity-Tuple{ca}"><code>Nemo.infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infinity(a::ca)</code></pre><p>Return the signed infinity (<span>$a \cdot \infty$</span>). This throws an exception if the parent of <code>a</code> does not allow special values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.undefined-Tuple{CalciumField}" href="#Nemo.undefined-Tuple{CalciumField}"><code>Nemo.undefined</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">undefined(C::CalciumField)</code></pre><p>Return the special value Undefined as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.unknown-Tuple{CalciumField}" href="#Nemo.unknown-Tuple{CalciumField}"><code>Nemo.unknown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unknown(C::CalciumField)</code></pre><p>Return the special meta-value Unknown as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L786">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_number-Tuple{ca}" href="#Nemo.is_number-Tuple{ca}"><code>Nemo.is_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_number(a::ca)</code></pre><p>Return whether <code>a</code> is a number, i.e. not an infinity or undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_undefined-Tuple{ca}" href="#Nemo.is_undefined-Tuple{ca}"><code>Nemo.is_undefined</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_undefined(a::ca)</code></pre><p>Return whether <code>a</code> is the special value <em>Undefined</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isinf-Tuple{ca}" href="#Base.isinf-Tuple{ca}"><code>Base.isinf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinf(a::ca)</code></pre><p>Return whether <code>a</code> is any infinity (signed or unsigned).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_uinf-Tuple{ca}" href="#Nemo.is_uinf-Tuple{ca}"><code>Nemo.is_uinf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_uinf(a::ca)</code></pre><p>Return whether <code>a</code> is unsigned infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_signed_inf-Tuple{ca}" href="#Nemo.is_signed_inf-Tuple{ca}"><code>Nemo.is_signed_inf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_signed_inf(a::ca)</code></pre><p>Return whether <code>a</code> is any signed infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.is_unknown-Tuple{ca}" href="#Nemo.is_unknown-Tuple{ca}"><code>Nemo.is_unknown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_unknown(a::ca)</code></pre><p>Return whether <code>a</code> is the special value <em>Unknown</em>. This is a representation property and not a mathematical predicate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L340">source</a></section></article><h2 id="Complex-parts"><a class="docs-heading-anchor" href="#Complex-parts">Complex parts</a><a id="Complex-parts-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-parts" title="Permalink"></a></h2><p>Functions for computing components of real and complex numbers will perform automatic symbolic simplifications in special cases. In general, such operations will introduce new extension numbers.</p><pre><code class="language-julia hljs">julia&gt; real(C(2+3im))
2

julia&gt; sign(C(2im))
1.00000*I {a where a = I [a^2+1=0]}

julia&gt; sign(C(2+3im))
0.554700 + 0.832050*I {a where a = 0.554700 + 0.832050*I [13*a^4+10*a^2+13=0]}

julia&gt; angle(C(2+2im))
0.785398 {(a)/4 where a = 3.14159 [Pi]}

julia&gt; angle(C(2+3im))
0.982794 {a where a = 0.982794 [Arg(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}

julia&gt; angle(C(2+3im)) == atan(C(3)//2)
true

julia&gt; floor(C(pi) ^ 100)
5.18785e+49 {51878483143196131920862615246303013562686760680405}

julia&gt; ZZ(floor(C(pi) ^ 100))
51878483143196131920862615246303013562686760680405</code></pre><p><strong>Interface</strong></p><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{ca}" href="#Base.real-Tuple{ca}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(a::ca)</code></pre><p>Return the real part of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.imag-Tuple{ca}" href="#Base.imag-Tuple{ca}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imag(a::ca)</code></pre><p>Return the imaginary part of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{ca}" href="#Base.angle-Tuple{ca}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle(a::ca)</code></pre><p>Return the complex argument of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.csgn-Tuple{ca}" href="#Nemo.csgn-Tuple{ca}"><code>Nemo.csgn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">csgn(a::ca)</code></pre><p>Return the extension of the real sign function taking the value 1 strictly in the right half plane, -1 strictly in the left half plane, and the sign of the imaginary part when on the imaginary axis. Equivalently, <span>$\operatorname{csgn}(x) = x / \sqrt{x^2}$</span> except that the value is 0 at zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L848">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Tuple{ca}" href="#Base.sign-Tuple{ca}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(a::ca)</code></pre><p>Return the complex sign of <code>a</code>, defined as zero if <code>a</code> is zero and as <span>$a / |a|$</span> for any other complex number. This function also extracts the sign when <code>a</code> is a signed infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Tuple{ca}" href="#Base.abs-Tuple{ca}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs(a::ca)</code></pre><p>Return the absolute value of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{ca}" href="#Base.conj-Tuple{ca}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(a::ca; form::Symbol=:default)</code></pre><p>Return the complex conjugate of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:shallow</code> form, <span>$\overline{a}$</span> is introduced as a new extension number if it no straightforward simplifications are possible. In <code>:deep</code> form, complex conjugation is performed recursively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Tuple{ca}" href="#Base.floor-Tuple{ca}"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor(a::ca)</code></pre><p>Return the floor function of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L924">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ceil-Tuple{ca}" href="#Base.ceil-Tuple{ca}"><code>Base.ceil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil(a::ca)</code></pre><p>Return the ceiling function of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L938">source</a></section></article><h2 id="Elementary-and-special-functions"><a class="docs-heading-anchor" href="#Elementary-and-special-functions">Elementary and special functions</a><a id="Elementary-and-special-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Elementary-and-special-functions" title="Permalink"></a></h2><p>Elementary and special functions generally create new extension numbers. In special cases, simplifications occur automatically.</p><pre><code class="language-julia hljs">julia&gt; exp(C(1))
2.71828 {a where a = 2.71828 [Exp(1)]}

julia&gt; exp(C(0))
1

julia&gt; atan(C(1))
0.785398 {(a)/4 where a = 3.14159 [Pi]}

julia&gt; cos(C(1))^2 + sin(C(1))^2
1

julia&gt; log(1 // exp(sqrt(C(2))+1)) == -sqrt(C(2)) - 1
true

julia&gt; gamma(C(2+3im))
-0.0823953 + 0.0917743*I {a where a = -0.0823953 + 0.0917743*I [Gamma(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}

julia&gt; gamma(C(5) // 2)
1.32934 {(3*a)/4 where a = 1.77245 [Sqrt(3.14159 {b})], b = 3.14159 [Pi]}

julia&gt; erf(C(1))
0.842701 {a where a = 0.842701 [Erf(1)]}

julia&gt; erf(C(1)) + erfc(C(1))
1</code></pre><p>Some functions allow representing the result in different forms:</p><pre><code class="language-julia hljs">julia&gt; s1 = sin(C(1))
0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}

julia&gt; s2 = sin(C(1), form=:direct)
0.841471 {a where a = 0.841471 [Sin(1)]}

julia&gt; s3 = sin(C(1), form=:exponential)
0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}

julia&gt; s4 = sin(C(1), form=:tangent)
0.841471 {(2*a)/(a^2+1) where a = 0.546302 [Tan(0.500000 {1/2})]}

julia&gt; s1 == s2 == s3 == s4
true

julia&gt; isreal(s1) &amp;&amp; isreal(s2) &amp;&amp; isreal(s3) &amp;&amp; isreal(s4)
true</code></pre><p>The exponential form is currently used by default since it tends to be the most useful for symbolic simplification. The <code>:direct</code> and <code>:tangent</code> forms are likely to be better for numerical evaluation. The default behavior of trigonometric functions can be changed using the <code>:trig_form</code> option of <code>CalciumField</code>.</p><p>Proving equalities involving transcendental function values is a difficult problem in general. Calcium will sometimes fail even in elementary cases. Here is an example of two constant trigonometric identities where the first succeeds and the second fails:</p><pre><code class="language-julia hljs">julia&gt; a = sqrt(C(2)) + 1;

julia&gt; cos(a) + cos(2*a) + cos(3*a) == sin(7*a//2)//(2*sin(a//2)) - C(1)//2
true

julia&gt; sin(3*a) == 4 * sin(a) * sin(C(pi)//3 - a) * sin(C(pi)//3 + a)
ERROR: Unable to perform operation (failed deciding truth of a predicate): isequal</code></pre><p>A possible workaround is to fall back on a numerical comparison:</p><pre><code class="language-julia hljs">julia&gt; abs(cos(a) + cos(2*a) + cos(3*a) - (sin(7*a//2)//(2*sin(a//2)) - C(1)//2)) &lt;= C(10)^-100
true</code></pre><p>Of course, this is not a rigorous proof that the numbers are equal, and <code>CalciumField</code> is overkill here; it would be far more efficient to use <code>ArbField</code> directly to check that the numbers are approximately equal.</p><p><strong>Interface</strong></p><article class="docstring"><header><a class="docstring-binding" id="Nemo.const_pi-Tuple{CalciumField}" href="#Nemo.const_pi-Tuple{CalciumField}"><code>Nemo.const_pi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">const_pi(C::CalciumField)</code></pre><p>Return the constant <span>$\pi$</span> as an element of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.const_euler-Tuple{CalciumField}" href="#Nemo.const_euler-Tuple{CalciumField}"><code>Nemo.const_euler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">const_euler(C::CalciumField)</code></pre><p>Return Euler&#39;s constant <span>$\gamma$</span> as an element of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.onei-Tuple{CalciumField}" href="#Nemo.onei-Tuple{CalciumField}"><code>Nemo.onei</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onei(C::CalciumField)</code></pre><p>Return the imaginary unit <span>$i$</span> as an element of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sqrt-Tuple{ca}" href="#Base.sqrt-Tuple{ca}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.sqrt(a::ca; check::Bool=true)</code></pre><p>Return the principal square root of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{ca}" href="#Base.exp-Tuple{ca}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(a::ca)</code></pre><p>Return the exponential function of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{ca}" href="#Base.log-Tuple{ca}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(a::ca)</code></pre><p>Return the natural logarithm of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.pow-Tuple{ca, Int64}" href="#Nemo.pow-Tuple{ca, Int64}"><code>Nemo.pow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pow(a::ca, b::Int; form::Symbol=:default)</code></pre><p>Return <em>a</em> raised to the integer power <code>b</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, this is equivalent to <code>a ^ b</code>, which may create a new extension number <span>$a^b$</span> if the exponent <code>b</code> is too large (as determined by the parent option <code>:pow_limit</code> or <code>:prec_limit</code> depending on the case). In <code>:arithmetic</code> form, the exponentiation is performed arithmetically in the field of <code>a</code>, regardless of the size of the exponent <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1000">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sin-Tuple{ca}" href="#Base.sin-Tuple{ca}"><code>Base.sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sin(a::ca; form::Symbol=:default)</code></pre><p>Return the sine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:exponential</code> form, the value is represented using complex exponentials. In <code>:tangent</code> form, the value is represented using tangents. In <code>:direct</code> form, the value is represented directly using a sine or cosine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cos-Tuple{ca}" href="#Base.cos-Tuple{ca}"><code>Base.cos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cos(a::ca; form::Symbol=:default)</code></pre><p>Return the cosine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:exponential</code> form, the value is represented using complex exponentials. In <code>:tangent</code> form, the value is represented using tangents. In <code>:direct</code> form, the value is represented directly using a sine or cosine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1060">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.tan-Tuple{ca}" href="#Base.tan-Tuple{ca}"><code>Base.tan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tan(a::ca; form::Symbol=:default)</code></pre><p>Return the tangent of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:exponential</code> form, the value is represented using complex exponentials. In <code>:direct</code> or <code>:tangent</code> form, the value is represented directly using tangents. In <code>:sine_cosine</code> form, the value is represented using sines or cosines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.atan-Tuple{ca}" href="#Base.atan-Tuple{ca}"><code>Base.atan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atan(a::ca; form::Symbol=:default)</code></pre><p>Return the inverse tangent of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:logarithm</code> form, the value is represented using complex logarithms. In <code>:direct</code> or <code>:arctangent</code> form, the value is represented directly using arctangents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.asin-Tuple{ca}" href="#Base.asin-Tuple{ca}"><code>Base.asin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asin(a::ca; form::Symbol=:default)</code></pre><p>Return the inverse sine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:logarithm</code> form, the value is represented using complex logarithms. In <code>:direct</code> form, the value is represented directly using an inverse sine or cosine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.acos-Tuple{ca}" href="#Base.acos-Tuple{ca}"><code>Base.acos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acos(a::ca; form::Symbol=:default)</code></pre><p>Return the inverse cosine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:logarithm</code> form, the value is represented using complex logarithms. In <code>:direct</code> form, the value is represented directly using an inverse sine or cosine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.gamma-Tuple{ca}" href="#Nemo.gamma-Tuple{ca}"><code>Nemo.gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gamma(a::ca)</code></pre><p>Return the gamma function of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.erf-Tuple{ca}" href="#Nemo.erf-Tuple{ca}"><code>Nemo.erf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erf(a::ca)</code></pre><p>Return the error function of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.erfi-Tuple{ca}" href="#Nemo.erfi-Tuple{ca}"><code>Nemo.erfi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erfi(a::ca)</code></pre><p>Return the imaginary error function of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.erfc-Tuple{ca}" href="#Nemo.erfc-Tuple{ca}"><code>Nemo.erfc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erfc(a::ca)</code></pre><p>Return the complementary error function of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1255">source</a></section></article><h2 id="Rewriting-and-simplification"><a class="docs-heading-anchor" href="#Rewriting-and-simplification">Rewriting and simplification</a><a id="Rewriting-and-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-and-simplification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Nemo.complex_normal_form-Tuple{ca}" href="#Nemo.complex_normal_form-Tuple{ca}"><code>Nemo.complex_normal_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex_normal_form(a::ca, deep::Bool=true)</code></pre><p>Returns the input rewritten using standardizing transformations over the complex numbers:</p><ul><li><p>Elementary functions are rewritten in terms of exponentials, roots and logarithms.</p></li><li><p>Complex parts are rewritten using logarithms, square roots, and (deep) complex conjugates.</p></li><li><p>Algebraic numbers are rewritten in terms of cyclotomic fields where applicable.</p></li></ul><p>If deep is set, the rewriting is applied recursively to the tower of extension numbers; otherwise, the rewriting is only applied to the top-level extension numbers.</p><p>The result is not a normal form in the strong sense (the same number can have many possible representations even after applying this transformation), but this transformation can nevertheless be a useful heuristic for simplification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/d4e14838bdbfc22cb26de0f907f4cae153fbaeac/src/calcium/ca.jl#L1275">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algebraic/">« Algebraic numbers</a><a class="docs-footer-nextpage" href="../complex/">Arbitrary precision complex balls »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 February 2023 16:43">Thursday 23 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
