var documenterSearchIndex = {"docs":
[{"location":"arb/","page":"Real balls","title":"Real balls","text":"CurrentModule = Nemo","category":"page"},{"location":"arb/#Real-balls","page":"Real balls","title":"Real balls","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Arbitrary precision real ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Real numbers are  represented in mid-rad interval form m pm r = m-r m+r.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"The Arb real field is constructed using the ArbField constructor. This constructs the parent object for the Arb real field.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"However, we define","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RealField = ArbField","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"so that one can construct the Arb real field parent object using RealField instead of ArbField.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"The types of real balls in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Library Field Element type Parent type\nArb mathbbR (balls) arb ArbField","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"All the real field types belong to the Field abstract type and the types of elements in this field, i.e. balls in this case, belong to the FieldElem abstract type.","category":"page"},{"location":"arb/#Real-ball-functionality","page":"Real balls","title":"Real ball functionality","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Real balls in Nemo provide all the field functionality described in AbstractAlgebra:","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Below, we document the additional functionality provided for real balls.","category":"page"},{"location":"arb/#Constructors","page":"Real balls","title":"Constructors","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"In order to construct real balls in Nemo, one must first construct the Arb real field itself. This is accomplished with the following constructor.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"ArbField(prec::Int)","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Return the Arb field with precision in bits prec used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"We define","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RealField = ArbField","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"so that one can use RealField in place of ArbField.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Here is an example of creating an Arb real field and using the resulting parent object to coerce values into the resulting field.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = RR(\"0.25\")\nb = RR(\"0.1 +/- 0.001\")\nc = RR(0.5)\nd = RR(12)","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Note that whilst one can coerce double precision floating point values into an Arb real field, unless those values can be represented exactly in double precision the resulting ball can't be any more precise than the double precision supplied.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"If instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb field.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"If the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function isexact below for more information.","category":"page"},{"location":"arb/#Real-ball-constructors","page":"Real balls","title":"Real ball constructors","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"ball(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.ball-Tuple{arb, arb}","page":"Real balls","title":"Nemo.ball","text":"ball(x::arb, y::arb)\n\nConstructs an Arb ball enclosing x_m pm (x_r + y_m + y_r), given the pair (x y) = (x_m pm x_r y_m pm y_r).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\nc = ball(RR(3), RR(\"0.0001\"))","category":"page"},{"location":"arb/#Conversions","page":"Real balls","title":"Conversions","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"convert(::Type{Float64}, ::arb)","category":"page"},{"location":"arb/#Base.convert-Tuple{Type{Float64}, arb}","page":"Real balls","title":"Base.convert","text":"convert(::Type{Float64}, x::arb)\n\nReturn the midpoint of x rounded down to a machine double.\n\n\n\n","category":"method"},{"location":"arb/#Basic-manipulation","page":"Real balls","title":"Basic manipulation","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isnonzero(::arb)","category":"page"},{"location":"arb/#Nemo.isnonzero-Tuple{arb}","page":"Real balls","title":"Nemo.isnonzero","text":"isnonzero(x::arb)\n\nReturn true if x is certainly not equal to zero, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isfinite(::arb)","category":"page"},{"location":"arb/#Base.isfinite-Tuple{arb}","page":"Real balls","title":"Base.isfinite","text":"isfinite(x::arb)\n\nReturn true if x is finite, i.e. having finite midpoint and radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isexact(::arb)","category":"page"},{"location":"arb/#Nemo.isexact-Tuple{arb}","page":"Real balls","title":"Nemo.isexact","text":"isexact(x::arb)\n\nReturn true if x is exact, i.e. has zero radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isint(::arb)","category":"page"},{"location":"arb/#Nemo.isint-Tuple{arb}","page":"Real balls","title":"Nemo.isint","text":"isint(x::arb)\n\nReturn true if x is an exact integer, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"ispositive(::arb)","category":"page"},{"location":"arb/#Nemo.ispositive-Tuple{arb}","page":"Real balls","title":"Nemo.ispositive","text":"ispositive(x::arb)\n\nReturn true if x is certainly positive, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isnonnegative(::arb)","category":"page"},{"location":"arb/#Nemo.isnonnegative-Tuple{arb}","page":"Real balls","title":"Nemo.isnonnegative","text":"isnonnegative(x::arb)\n\nReturn true if x is certainly nonnegative, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isnegative(::arb)","category":"page"},{"location":"arb/#AbstractAlgebra.isnegative-Tuple{arb}","page":"Real balls","title":"AbstractAlgebra.isnegative","text":"isnegative(x::arb)\n\nReturn true if x is certainly negative, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isnonpositive(::arb)","category":"page"},{"location":"arb/#Nemo.isnonpositive-Tuple{arb}","page":"Real balls","title":"Nemo.isnonpositive","text":"isnonpositive(x::arb)\n\nReturn true if x is certainly nonpositive, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"midpoint(::arb)","category":"page"},{"location":"arb/#Nemo.midpoint-Tuple{arb}","page":"Real balls","title":"Nemo.midpoint","text":"midpoint(x::arb)\n\nReturn the midpoint of the ball x as an Arb ball.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"radius(::arb)","category":"page"},{"location":"arb/#Nemo.radius-Tuple{arb}","page":"Real balls","title":"Nemo.radius","text":"radius(x::arb)\n\nReturn the radius of the ball x as an Arb ball.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"accuracy_bits(::arb)","category":"page"},{"location":"arb/#Nemo.accuracy_bits-Tuple{arb}","page":"Real balls","title":"Nemo.accuracy_bits","text":"accuracy_bits(x::arb)\n\nReturn the relative accuracy of x measured in bits, capped between typemax(Int) and -typemax(Int).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = RR(\"1.2 +/- 0.001\")\nb = RR(3)\n\nispositive(a)\nisfinite(b)\nisint(b)\nisnegative(a)\nc = radius(a)\nd = midpoint(b)\nf = accuracy_bits(a)","category":"page"},{"location":"arb/#Printing","page":"Real balls","title":"Printing","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Printing real balls can at first sight be confusing. Lets look at the following example:","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = RR(1)\nb = RR(2)\nc = RR(12)\n\nx = ball(a, b)\ny = ball(c, b)\n\nmid = midpoint(x)\nrad = radius(x)\n\nprint(x, \"\\n\", y, \"\\n\", mid, \"\\n\", rad)","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"which generates","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"[+/- 3.01]\n[1e+1 +/- 4.01]\n1.0000000000000000000\n[2.0000000037252902985 +/- 3.81e-20]","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"The first reason that c does not get printed as [1 +/- 2] is because the midpoint does not have a greater exponent than the radius in its scientific notation. By similair reasons we also have that y does not get printed as [12 +/- 2].","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"The second reason is that we get an additional error term after our addition. As we see, radius(c) is not equal to 2, which when printing rounds it up to a reasonable decimal place for printing. This is because real balls keep track of rounding errors of basic arithmetic.","category":"page"},{"location":"arb/#Containment","page":"Real balls","title":"Containment","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"It is often necessary to determine whether a given exact value or ball is contained in a given real ball or whether two balls overlap. The following functions are provided for this purpose.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"overlaps(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.overlaps-Tuple{arb, arb}","page":"Real balls","title":"Nemo.overlaps","text":"overlaps(x::arb, y::arb)\n\nReturns true if any part of the ball x overlaps any part of the ball y, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"contains(::arb, ::arb)","category":"page"},{"location":"arb/#Base.contains-Tuple{arb, arb}","page":"Real balls","title":"Base.contains","text":"contains(x::arb, y::arb)\n\nReturns true if the ball x contains the ball y, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"contains(::arb, ::Integer)\ncontains(::arb, ::fmpz)\ncontains(::arb, ::fmpq)\ncontains{T <: Integer}(::arb, ::Rational{T})\ncontains(::arb, ::BigFloat)","category":"page"},{"location":"arb/#Base.contains-Tuple{arb, Integer}","page":"Real balls","title":"Base.contains","text":"contains(x::arb, y::Integer)\n\nReturns true if the ball x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/#Base.contains-Tuple{arb, fmpz}","page":"Real balls","title":"Base.contains","text":"contains(x::arb, y::fmpz)\n\nReturns true if the ball x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/#Base.contains-Tuple{arb, fmpq}","page":"Real balls","title":"Base.contains","text":"contains(x::arb, y::fmpq)\n\nReturns true if the ball x contains the given rational value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/#Base.contains-Union{Tuple{T}, Tuple{arb, Rational{T}}} where T<:Integer","page":"Real balls","title":"Base.contains","text":"contains(x::arb, y::Rational{T}) where {T <: Integer}\n\nReturns true if the ball x contains the given rational value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/#Base.contains-Tuple{arb, BigFloat}","page":"Real balls","title":"Base.contains","text":"contains(x::arb, y::BigFloat)\n\nReturns true if the ball x contains the given floating point value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"The following functions are also provided for determining if a ball intersects a certain part of the real number line.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"contains_zero(::arb)","category":"page"},{"location":"arb/#Nemo.contains_zero-Tuple{arb}","page":"Real balls","title":"Nemo.contains_zero","text":"contains_zero(x::arb)\n\nReturns true if the ball x contains zero, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"contains_negative(::arb)","category":"page"},{"location":"arb/#Nemo.contains_negative-Tuple{arb}","page":"Real balls","title":"Nemo.contains_negative","text":"contains_negative(x::arb)\n\nReturns true if the ball x contains any negative value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"contains_positive(::arb)","category":"page"},{"location":"arb/#Nemo.contains_positive-Tuple{arb}","page":"Real balls","title":"Nemo.contains_positive","text":"contains_positive(x::arb)\n\nReturns true if the ball x contains any positive value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"contains_nonnegative(::arb)","category":"page"},{"location":"arb/#Nemo.contains_nonnegative-Tuple{arb}","page":"Real balls","title":"Nemo.contains_nonnegative","text":"contains_nonnegative(x::arb)\n\nReturns true if the ball x contains any nonnegative value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"contains_nonpositive(::arb)","category":"page"},{"location":"arb/#Nemo.contains_nonpositive-Tuple{arb}","page":"Real balls","title":"Nemo.contains_nonpositive","text":"contains_nonpositive(x::arb)\n\nReturns true if the ball x contains any nonpositive value, otherwise return false.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"1 +/- 0.001\")\ny = RR(\"3\")\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)\ncontains_positive(y)","category":"page"},{"location":"arb/#Comparison","page":"Real balls","title":"Comparison","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Nemo provides a full range of comparison operations for Arb balls. Note that a ball is considered less than another ball if every value in the first ball is less than every value in the second ball, etc.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"In addition to the standard comparison operators, we introduce an exact equality. This is distinct from arithmetic equality implemented by ==, which merely compares up to the minimum of the precisions of its operands.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"isequal(::arb, ::arb)","category":"page"},{"location":"arb/#Base.isequal-Tuple{arb, arb}","page":"Real balls","title":"Base.isequal","text":"isequal(x::arb, y::arb)\n\nReturn true if the balls x and y are precisely equal, i.e. have the same midpoints and radii.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"We also provide a full range of ad hoc comparison operators. These are implemented directly in Julia, but we document them as though isless and == were provided.","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Function\n==(x::arb, y::Integer)\n==(x::Integer, y::arb)\n==(x::arb, y::fmpz)\n==(x::fmpz, y::arb)\n==(x::arb, y::Float64)\n==(x::Float64, y::arb)\nisless(x::arb, y::Integer)\nisless(x::Integer, y::arb)\nisless(x::arb, y::fmpz)\nisless(x::fmpz, y::arb)\nisless(x::arb, y::Float64)\nisless(x::Float64, y::arb)\nisless(x::arb, y::BigFloat)\nisless(x::BigFloat, y::arb)\nisless(x::arb, y::fmpq)\nisless(x::fmpq, y::arb)","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"1 +/- 0.001\")\ny = RR(\"3\")\nz = RR(\"4\")\n\nisequal(x, deepcopy(x))\nx == 3\nZZ(3) < z\nx != 1.23","category":"page"},{"location":"arb/#Absolute-value","page":"Real balls","title":"Absolute value","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"abs(::arb)","category":"page"},{"location":"arb/#Base.abs-Tuple{arb}","page":"Real balls","title":"Base.abs","text":"abs(x::arb)\n\nReturn the absolute value of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"-1 +/- 0.001\")\n\na = abs(x)","category":"page"},{"location":"arb/#Shifting","page":"Real balls","title":"Shifting","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"ldexp(x::arb, y::Int)\nldexp(x::arb, y::fmpz)","category":"page"},{"location":"arb/#Base.Math.ldexp-Tuple{arb, Int64}","page":"Real balls","title":"Base.Math.ldexp","text":"ldexp(x::arb, y::Int)\n\nReturn 2^yx. Note that y can be positive, zero or negative.\n\n\n\n","category":"method"},{"location":"arb/#Base.Math.ldexp-Tuple{arb, fmpz}","page":"Real balls","title":"Base.Math.ldexp","text":"ldexp(x::arb, y::fmpz)\n\nReturn 2^yx. Note that y can be positive, zero or negative.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"-3 +/- 0.001\")\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))","category":"page"},{"location":"arb/#Miscellaneous-operations","page":"Real balls","title":"Miscellaneous operations","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"trim(::arb)","category":"page"},{"location":"arb/#Nemo.trim-Tuple{arb}","page":"Real balls","title":"Nemo.trim","text":"trim(x::arb)\n\nReturn an arb interval containing x but which may be more economical, by rounding off insignificant bits from the midpoint.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"unique_integer(::arb)","category":"page"},{"location":"arb/#Nemo.unique_integer-Tuple{arb}","page":"Real balls","title":"Nemo.unique_integer","text":"unique_integer(x::arb)\n\nReturn a pair where the first value is a boolean and the second is an fmpz integer. The boolean indicates whether the interval x contains a unique integer. If this is the case, the second return value is set to this unique integer.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"setunion(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.setunion-Tuple{arb, arb}","page":"Real balls","title":"Nemo.setunion","text":"setunion(x::arb, y::arb)\n\nReturn an arb containing the union of the intervals represented by x and y.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"-3 +/- 0.001\")\ny = RR(\"2 +/- 0.5\")\n\na = trim(x)\nb, c = unique_integer(x)\nd = setunion(x, y)","category":"page"},{"location":"arb/#Constants","page":"Real balls","title":"Constants","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_pi(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_pi-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_pi","text":"const_pi(r::ArbField)\n\nReturn pi = 314159ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_e(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_e-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_e","text":"const_e(r::ArbField)\n\nReturn e = 271828ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_log2(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_log2-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_log2","text":"const_log2(r::ArbField)\n\nReturn log(2) = 069314ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_log10(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_log10-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_log10","text":"const_log10(r::ArbField)\n\nReturn log(10) = 2302585ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_euler(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_euler-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_euler","text":"const_euler(r::ArbField)\n\nReturn Euler's constant gamma = 0577215ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_catalan(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_catalan-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_catalan","text":"const_catalan(r::ArbField)\n\nReturn Catalan's constant C = 0915965ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_khinchin(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_khinchin-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_khinchin","text":"const_khinchin(r::ArbField)\n\nReturn Khinchin's constant K = 2685452ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"const_glaisher(::ArbField)","category":"page"},{"location":"arb/#Nemo.const_glaisher-Tuple{ArbField}","page":"Real balls","title":"Nemo.const_glaisher","text":"const_glaisher(r::ArbField)\n\nReturn Glaisher's constant A = 1282427ldots as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(200)\n\na = const_pi(RR)\nb = const_e(RR)\nc = const_euler(RR)\nd = const_glaisher(RR)","category":"page"},{"location":"arb/#Mathematical-and-special-functions","page":"Real balls","title":"Mathematical and special functions","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"floor(::arb)","category":"page"},{"location":"arb/#Base.floor-Tuple{arb}","page":"Real balls","title":"Base.floor","text":"floor(x::arb)\n\nReturn floor of x, i.e. the greatest integer not exceeding x, as an Arb.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"ceil(::arb)","category":"page"},{"location":"arb/#Base.ceil-Tuple{arb}","page":"Real balls","title":"Base.ceil","text":"ceil(x::arb)\n\nReturn ceiling of x, i.e. the least integer not less than x, as an Arb.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Base.sqrt(::arb)","category":"page"},{"location":"arb/#Base.sqrt-Tuple{arb}","page":"Real balls","title":"Base.sqrt","text":"sqrt(x::arb; check::Bool=true)\n\nReturn the square root of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"rsqrt(::arb)","category":"page"},{"location":"arb/#Nemo.rsqrt-Tuple{arb}","page":"Real balls","title":"Nemo.rsqrt","text":"rsqrt(x::arb)\n\nReturn the reciprocal of the square root of x, i.e. 1sqrtx.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sqrt1pm1(::arb)","category":"page"},{"location":"arb/#Nemo.sqrt1pm1-Tuple{arb}","page":"Real balls","title":"Nemo.sqrt1pm1","text":"sqrt1pm1(x::arb)\n\nReturn sqrt1+x-1, evaluated accurately for small x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sqrtpos(::arb)","category":"page"},{"location":"arb/#Nemo.sqrtpos-Tuple{arb}","page":"Real balls","title":"Nemo.sqrtpos","text":"sqrtpos(x::arb)\n\nReturn the sqrt root of x, assuming that x represents a nonnegative number. Thus any negative number in the input interval is discarded.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"log(::arb)","category":"page"},{"location":"arb/#Base.log-Tuple{arb}","page":"Real balls","title":"Base.log","text":"log(x::arb)\n\nReturn the principal branch of the logarithm of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"log1p(::arb)","category":"page"},{"location":"arb/#Base.log1p-Tuple{arb}","page":"Real balls","title":"Base.log1p","text":"log1p(x::arb)\n\nReturn log(1+x), evaluated accurately for small x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Base.exp(::arb)","category":"page"},{"location":"arb/#Base.exp-Tuple{arb}","page":"Real balls","title":"Base.exp","text":"exp(x::arb)\n\nReturn the exponential of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"expm1(::arb)","category":"page"},{"location":"arb/#Base.expm1-Tuple{arb}","page":"Real balls","title":"Base.expm1","text":"expm1(x::arb)\n\nReturn exp(x)-1, using a more accurate method when x approx 0.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sin(::arb)","category":"page"},{"location":"arb/#Base.sin-Tuple{arb}","page":"Real balls","title":"Base.sin","text":"sin(x::arb)\n\nReturn the sine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"cos(::arb)","category":"page"},{"location":"arb/#Base.cos-Tuple{arb}","page":"Real balls","title":"Base.cos","text":"cos(x::arb)\n\nReturn the cosine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sinpi(::arb)","category":"page"},{"location":"arb/#Base.Math.sinpi-Tuple{arb}","page":"Real balls","title":"Base.Math.sinpi","text":"sinpi(x::arb)\n\nReturn the sine of pi x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"cospi(::arb)","category":"page"},{"location":"arb/#Base.Math.cospi-Tuple{arb}","page":"Real balls","title":"Base.Math.cospi","text":"cospi(x::arb)\n\nReturn the cosine of pi x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"tan(::arb)","category":"page"},{"location":"arb/#Base.tan-Tuple{arb}","page":"Real balls","title":"Base.tan","text":"tan(x::arb)\n\nReturn the tangent of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"cot(::arb)","category":"page"},{"location":"arb/#Base.Math.cot-Tuple{arb}","page":"Real balls","title":"Base.Math.cot","text":"cot(x::arb)\n\nReturn the cotangent of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"tanpi(::arb)","category":"page"},{"location":"arb/#Nemo.tanpi-Tuple{arb}","page":"Real balls","title":"Nemo.tanpi","text":"tanpi(x::arb)\n\nReturn the tangent of pi x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"cotpi(::arb)","category":"page"},{"location":"arb/#Nemo.cotpi-Tuple{arb}","page":"Real balls","title":"Nemo.cotpi","text":"cotpi(x::arb)\n\nReturn the cotangent of pi x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sinh(::arb)","category":"page"},{"location":"arb/#Base.sinh-Tuple{arb}","page":"Real balls","title":"Base.sinh","text":"sinh(x::arb)\n\nReturn the hyperbolic sine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"cosh(::arb)","category":"page"},{"location":"arb/#Base.cosh-Tuple{arb}","page":"Real balls","title":"Base.cosh","text":"cosh(x::arb)\n\nReturn the hyperbolic cosine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"tanh(::arb)","category":"page"},{"location":"arb/#Base.tanh-Tuple{arb}","page":"Real balls","title":"Base.tanh","text":"tanh(x::arb)\n\nReturn the hyperbolic tangent of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"coth(::arb)","category":"page"},{"location":"arb/#Base.Math.coth-Tuple{arb}","page":"Real balls","title":"Base.Math.coth","text":"coth(x::arb)\n\nReturn the hyperbolic cotangent of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"atan(::arb)","category":"page"},{"location":"arb/#Base.atan-Tuple{arb}","page":"Real balls","title":"Base.atan","text":"atan(x::arb)\n\nReturn the arctangent of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"asin(::arb)","category":"page"},{"location":"arb/#Base.asin-Tuple{arb}","page":"Real balls","title":"Base.asin","text":"asin(x::arb)\n\nReturn the arcsine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"acos(::arb)","category":"page"},{"location":"arb/#Base.acos-Tuple{arb}","page":"Real balls","title":"Base.acos","text":"acos(x::arb)\n\nReturn the arccosine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"atanh(::arb)","category":"page"},{"location":"arb/#Base.atanh-Tuple{arb}","page":"Real balls","title":"Base.atanh","text":"atanh(x::arb)\n\nReturn the hyperbolic arctangent of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"asinh(::arb)","category":"page"},{"location":"arb/#Base.asinh-Tuple{arb}","page":"Real balls","title":"Base.asinh","text":"asinh(x::arb)\n\nReturn the hyperbolic arcsine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"acosh(::arb)","category":"page"},{"location":"arb/#Base.acosh-Tuple{arb}","page":"Real balls","title":"Base.acosh","text":"acosh(x::arb)\n\nReturn the hyperbolic arccosine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"gamma(::arb)","category":"page"},{"location":"arb/#Nemo.gamma-Tuple{arb}","page":"Real balls","title":"Nemo.gamma","text":"gamma(x::arb)\n\nReturn the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"lgamma(::arb)","category":"page"},{"location":"arb/#Nemo.lgamma-Tuple{arb}","page":"Real balls","title":"Nemo.lgamma","text":"lgamma(x::arb)\n\nReturn the logarithm of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"rgamma(::arb)","category":"page"},{"location":"arb/#Nemo.rgamma-Tuple{arb}","page":"Real balls","title":"Nemo.rgamma","text":"rgamma(x::arb)\n\nReturn the reciprocal of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"digamma(::arb)","category":"page"},{"location":"arb/#Nemo.digamma-Tuple{arb}","page":"Real balls","title":"Nemo.digamma","text":"digamma(x::arb)\n\nReturn the  logarithmic derivative of the gamma function evaluated at x, i.e. psi(x).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"gamma(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.gamma-Tuple{arb, arb}","page":"Real balls","title":"Nemo.gamma","text":"gamma(s::arb, x::arb)\n\nReturn the upper incomplete gamma function Gamma(sx).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"gamma_regularized(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.gamma_regularized-Tuple{arb, arb}","page":"Real balls","title":"Nemo.gamma_regularized","text":"gamma_regularized(s::arb, x::arb)\n\nReturn the regularized upper incomplete gamma function Gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"gamma_lower(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.gamma_lower-Tuple{arb, arb}","page":"Real balls","title":"Nemo.gamma_lower","text":"gamma_lower(s::arb, x::arb)\n\nReturn the lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"gamma_lower_regularized(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.gamma_lower_regularized-Tuple{arb, arb}","page":"Real balls","title":"Nemo.gamma_lower_regularized","text":"gamma_lower_regularized(s::arb, x::arb)\n\nReturn the regularized lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"zeta(::arb)","category":"page"},{"location":"arb/#Nemo.zeta-Tuple{arb}","page":"Real balls","title":"Nemo.zeta","text":"zeta(x::arb)\n\nReturn the Riemann zeta function evaluated at x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sincos(::arb)","category":"page"},{"location":"arb/#Base.Math.sincos-Tuple{arb}","page":"Real balls","title":"Base.Math.sincos","text":"sincos(x::arb)\n\nReturn a tuple s c consisting of the sine s and cosine c of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sincospi(::arb)","category":"page"},{"location":"arb/#Base.Math.sincospi-Tuple{arb}","page":"Real balls","title":"Base.Math.sincospi","text":"sincospi(x::arb)\n\nReturn a tuple s c consisting of the sine s and cosine c of pi x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sinpi(::fmpq, ::ArbField)","category":"page"},{"location":"arb/#Base.Math.sinpi-Tuple{fmpq, ArbField}","page":"Real balls","title":"Base.Math.sinpi","text":"sinpi(x::fmpq, r::ArbField)\n\nReturn the sine of pi x in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"cospi(::fmpq, ::ArbField)","category":"page"},{"location":"arb/#Base.Math.cospi-Tuple{fmpq, ArbField}","page":"Real balls","title":"Base.Math.cospi","text":"cospi(x::fmpq, r::ArbField)\n\nReturn the cosine of pi x in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sincospi(::fmpq, ::ArbField)","category":"page"},{"location":"arb/#Base.Math.sincospi-Tuple{fmpq, ArbField}","page":"Real balls","title":"Base.Math.sincospi","text":"sincospi(x::fmpq, r::ArbField)\n\nReturn a tuple s c consisting of the sine and cosine of pi x in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"sinhcosh(::arb)","category":"page"},{"location":"arb/#Nemo.sinhcosh-Tuple{arb}","page":"Real balls","title":"Nemo.sinhcosh","text":"sinhcosh(x::arb)\n\nReturn a tuple s c consisting of the hyperbolic sine and cosine of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"atan2(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.atan2-Tuple{arb, arb}","page":"Real balls","title":"Nemo.atan2","text":"atan2(y::arb, x::arb)\n\nReturn operatornameatan2(yx) = arg(x+yi).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"agm(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.agm-Tuple{arb, arb}","page":"Real balls","title":"Nemo.agm","text":"agm(x::arb, y::arb)\n\nReturn the arithmetic-geometric mean of x and y\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"zeta(::arb, ::arb)","category":"page"},{"location":"arb/#Nemo.zeta-Tuple{arb, arb}","page":"Real balls","title":"Nemo.zeta","text":"zeta(s::arb, a::arb)\n\nReturn the Hurwitz zeta function zeta(sa).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"hypot(::arb, ::arb)","category":"page"},{"location":"arb/#Base.Math.hypot-Tuple{arb, arb}","page":"Real balls","title":"Base.Math.hypot","text":"hypot(x::arb, y::arb)\n\nReturn sqrtx^2 + y^2.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"root(::arb, ::Int)","category":"page"},{"location":"arb/#AbstractAlgebra.root-Tuple{arb, Int64}","page":"Real balls","title":"AbstractAlgebra.root","text":"root(x::arb, n::Int)\n\nReturn the n-th root of x. We require x geq 0.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"factorial(::arb)","category":"page"},{"location":"arb/#Base.factorial-Tuple{arb}","page":"Real balls","title":"Base.factorial","text":"factorial(x::arb)\n\nReturn the factorial of x.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"factorial(::Int, ::ArbField)","category":"page"},{"location":"arb/#Base.factorial-Tuple{Int64, ArbField}","page":"Real balls","title":"Base.factorial","text":"factorial(n::Int, r::ArbField)\n\nReturn the factorial of n in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"binomial(::arb, ::UInt)","category":"page"},{"location":"arb/#Base.binomial-Tuple{arb, UInt64}","page":"Real balls","title":"Base.binomial","text":"binomial(x::arb, n::UInt)\n\nReturn the binomial coefficient x choose n.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"binomial(::UInt, ::UInt, ::ArbField)","category":"page"},{"location":"arb/#Base.binomial-Tuple{UInt64, UInt64, ArbField}","page":"Real balls","title":"Base.binomial","text":"binomial(n::UInt, k::UInt, r::ArbField)\n\nReturn the binomial coefficient n choose k in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"fibonacci(::fmpz, ::ArbField)","category":"page"},{"location":"arb/#Nemo.fibonacci-Tuple{fmpz, ArbField}","page":"Real balls","title":"Nemo.fibonacci","text":"fibonacci(n::fmpz, r::ArbField)\n\nReturn the n-th Fibonacci number in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"fibonacci(::Int, ::ArbField)","category":"page"},{"location":"arb/#Nemo.fibonacci-Tuple{Int64, ArbField}","page":"Real balls","title":"Nemo.fibonacci","text":"fibonacci(n::Int, r::ArbField)\n\nReturn the n-th Fibonacci number in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"gamma(::fmpz, ::ArbField)","category":"page"},{"location":"arb/#Nemo.gamma-Tuple{fmpz, ArbField}","page":"Real balls","title":"Nemo.gamma","text":"gamma(x::fmpz, r::ArbField)\n\nReturn the Gamma function evaluated at x in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"gamma(::fmpq, ::ArbField)","category":"page"},{"location":"arb/#Nemo.gamma-Tuple{fmpq, ArbField}","page":"Real balls","title":"Nemo.gamma","text":"gamma(x::fmpq, r::ArbField)\n\nReturn the Gamma function evaluated at x in the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"zeta(::Int, ::ArbField)","category":"page"},{"location":"arb/#Nemo.zeta-Tuple{Int64, ArbField}","page":"Real balls","title":"Nemo.zeta","text":"zeta(n::Int, r::ArbField)\n\nReturn the Riemann zeta function zeta(n) as an element of the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"bernoulli(::Int, ::ArbField)","category":"page"},{"location":"arb/#Nemo.bernoulli-Tuple{Int64, ArbField}","page":"Real balls","title":"Nemo.bernoulli","text":"bernoulli(n::Int, r::ArbField)\n\nReturn the n-th Bernoulli number as an element of the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"rising_factorial(::arb, ::Int)","category":"page"},{"location":"arb/#Nemo.rising_factorial-Tuple{arb, Int64}","page":"Real balls","title":"Nemo.rising_factorial","text":"rising_factorial(x::arb, n::Int)\n\nReturn the rising factorial x(x + 1)ldots (x + n - 1) as an Arb.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"rising_factorial(::fmpq, ::Int, ::ArbField)","category":"page"},{"location":"arb/#Nemo.rising_factorial-Tuple{fmpq, Int64, ArbField}","page":"Real balls","title":"Nemo.rising_factorial","text":"rising_factorial(x::fmpq, n::Int, r::ArbField)\n\nReturn the rising factorial x(x + 1)ldots (x + n - 1) as an element of the given Arb field.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"rising_factorial2(::arb, ::Int)","category":"page"},{"location":"arb/#Nemo.rising_factorial2-Tuple{arb, Int64}","page":"Real balls","title":"Nemo.rising_factorial2","text":"rising_factorial2(x::arb, n::Int)\n\nReturn a tuple containing the rising factorial x(x + 1)ldots (x + n - 1) and its derivative.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"polylog(::Union{arb,Int}, ::arb)","category":"page"},{"location":"arb/#Nemo.polylog-Tuple{Union{Int64, arb}, arb}","page":"Real balls","title":"Nemo.polylog","text":"polylog(s::Union{arb,Int}, a::arb)\n\nReturn the polylogarithm Li_s(a).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"chebyshev_t(::Int, ::arb)","category":"page"},{"location":"arb/#AbstractAlgebra.chebyshev_t-Tuple{Int64, arb}","page":"Real balls","title":"AbstractAlgebra.chebyshev_t","text":"chebyshev_t(n::Int, x::arb)\n\nReturn the value of the Chebyshev polynomial T_n(x).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"chebyshev_u(::Int, ::arb)","category":"page"},{"location":"arb/#AbstractAlgebra.chebyshev_u-Tuple{Int64, arb}","page":"Real balls","title":"AbstractAlgebra.chebyshev_u","text":"chebyshev_u(n::Int, x::arb)\n\nReturn the value of the Chebyshev polynomial U_n(x).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"chebyshev_t2(::Int, ::arb)","category":"page"},{"location":"arb/#Nemo.chebyshev_t2-Tuple{Int64, arb}","page":"Real balls","title":"Nemo.chebyshev_t2","text":"chebyshev_t2(n::Int, x::arb)\n\nReturn the tuple (T_n(x) T_n-1(x)).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"chebyshev_u2(::Int, ::arb)","category":"page"},{"location":"arb/#Nemo.chebyshev_u2-Tuple{Int64, arb}","page":"Real balls","title":"Nemo.chebyshev_u2","text":"chebyshev_u2(n::Int, x::arb)\n\nReturn the tuple (U_n(x) U_n-1(x))\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"bell(::fmpz, ::ArbField)","category":"page"},{"location":"arb/#Nemo.bell-Tuple{fmpz, ArbField}","page":"Real balls","title":"Nemo.bell","text":"bell(n::fmpz, r::ArbField)\n\nReturn the Bell number B_n as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"bell(::Int, ::ArbField)","category":"page"},{"location":"arb/#Nemo.bell-Tuple{Int64, ArbField}","page":"Real balls","title":"Nemo.bell","text":"bell(n::Int, r::ArbField)\n\nReturn the Bell number B_n as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"numpart(::fmpz, ::ArbField)","category":"page"},{"location":"arb/#Nemo.numpart-Tuple{fmpz, ArbField}","page":"Real balls","title":"Nemo.numpart","text":"numpart(n::fmpz, r::ArbField)\n\nReturn the number of partitions p(n) as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"numpart(::Int, ::ArbField)","category":"page"},{"location":"arb/#Nemo.numpart-Tuple{Int64, ArbField}","page":"Real balls","title":"Nemo.numpart","text":"numpart(n::Int, r::ArbField)\n\nReturn the number of partitions p(n) as an element of r.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"airy_ai(::arb)","category":"page"},{"location":"arb/#Nemo.airy_ai-Tuple{arb}","page":"Real balls","title":"Nemo.airy_ai","text":"airy_ai(x::arb)\n\nReturn the Airy function operatornameAi(x).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"airy_ai_prime(::arb)","category":"page"},{"location":"arb/#Nemo.airy_ai_prime-Tuple{arb}","page":"Real balls","title":"Nemo.airy_ai_prime","text":"airy_ai_prime(x::arb)\n\nReturn the derivative of the Airy function operatornameAi^prime(x).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"airy_bi(::arb)","category":"page"},{"location":"arb/#Nemo.airy_bi-Tuple{arb}","page":"Real balls","title":"Nemo.airy_bi","text":"airy_bi(x::arb)\n\nReturn the Airy function operatornameBi(x).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"airy_bi_prime(::arb)","category":"page"},{"location":"arb/#Nemo.airy_bi_prime-Tuple{arb}","page":"Real balls","title":"Nemo.airy_bi_prime","text":"airy_bi_prime(x::arb)\n\nReturn the derivative of the Airy function operatornameBi^prime(x).\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = floor(exp(RR(1)))\nb = sinpi(QQ(5,6), RR)\nc = gamma(QQ(1,3), RealField(256))\nd = bernoulli(1000, RealField(53))\nf = polylog(3, RR(-10))","category":"page"},{"location":"arb/#Linear-dependence","page":"Real balls","title":"Linear dependence","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"lindep(::Vector{arb}, n::Int)","category":"page"},{"location":"arb/#Nemo.lindep-Tuple{Vector{arb}, Int64}","page":"Real balls","title":"Nemo.lindep","text":"lindep(A::Vector{arb}, bits::Int)\n\nFind a small linear combination of the entries of the array A that is small (using LLL). The entries are first scaled by the given number of bits before truncating to integers for use in LLL. This function can be used to find linear dependence between a list of real numbers. The algorithm is heuristic only and returns an array of Nemo integers representing the linear combination.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(128)\n\na = RR(-0.33198902958450931620250069492231652319)\n\nV = [RR(1), a, a^2, a^3, a^4, a^5]\nW = lindep(V, 20)","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"simplest_rational_inside(::arb)","category":"page"},{"location":"arb/#Nemo.simplest_rational_inside-Tuple{arb}","page":"Real balls","title":"Nemo.simplest_rational_inside","text":"  simplest_rational_inside(x::arb)\n\nReturn the simplest fraction inside the ball x. A canonical fraction a_1b_1 is defined to be simpler than a_2b_2 iff b_1  b_2 or b_1 = b_2 and a_1  a_2.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nsimplest_rational_inside(const_pi(RR))","category":"page"},{"location":"arb/#Random-generation","page":"Real balls","title":"Random generation","text":"","category":"section"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"rand(::ArbField)","category":"page"},{"location":"arb/#Base.rand-Tuple{ArbField}","page":"Real balls","title":"Base.rand","text":"rand(r::ArbField; randtype::Symbol=:urandom)\n\nReturn a random element in given Arb field.\n\nThe randtype default is :urandom which return an arb contained in 01.\n\nThe rest of the methods return non-uniformly distributed values in order to exercise corner cases. The option :randtest will return a finite number, and :randtest_exact the same but with a zero radius. The option :randtest_precise return an arb with a radius around 2^-mathrmprec the magnitude of the midpoint, while :randtest_wide return a radius that might be big relative to its midpoint. The :randtest_special-option might return a midpoint and radius whose values are NaN or inf.\n\n\n\n","category":"method"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(100)\n\na = rand(RR)\nb = rand(RR; randtype = :null_exact)\nc = rand(RR; randtype = :exact)\nd = rand(RR; randtype = :special)","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"CurrentModule = Nemo","category":"page"},{"location":"polynomial/#Univariate-polynomials","page":"Univariate polynomials","title":"Univariate polynomials","text":"","category":"section"},{"location":"polynomial/#Introduction","page":"Univariate polynomials","title":"Introduction","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Nemo allow the creation of dense, univariate polynomials over any computable ring R. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"The following table shows each of the polynomial types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Poly{T} Generic.PolyRing{T}\nmathbbZ Flint fmpz_poly FmpzPolyRing\nmathbbZnmathbbZ (small n) Flint nmod_poly NmodPolyRing\nmathbbZnmathbbZ (large n) Flint fmpz_mod_poly FmpzModPolyRing\nmathbbQ Flint fmpq_poly FmpqPolyRing\nmathbbZpmathbbZ (small prime p) Flint gfp_poly GFPPolyRing\nmathbbZpmathbbZ (large prime p) Flint gfp_fmpz_poly GFPFmpzPolyRing\nmathbbF_p^n (small p) Flint fq_nmod_poly FqNmodPolyRing\nmathbbF_p^n (large p) Flint fq_poly FqPolyRing\nmathbbR Arb arb_poly ArbPolyRing\nmathbbC Arb acb_poly AcbPolyRing","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"The string representation of the variable and the base ring R of a generic polynomial is stored in its parent object. ","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"All polynomial element types belong to the abstract type PolyElem and all of the polynomial ring types belong to the abstract type PolyRing. This enables one to write generic functions that can accept any Nemo univariate polynomial type.","category":"page"},{"location":"polynomial/#Polynomial-functionality","page":"Univariate polynomials","title":"Polynomial functionality","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"All univariate polynomial types in Nemo provide the AbstractAlgebra univariate polynomial functionality:","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/polynomial","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Generic polynomials are also available.","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"We describe here only functions that are in addition to that guaranteed by AbstractAlgebra.jl, for specific coefficient rings.","category":"page"},{"location":"polynomial/#Remove-and-valuation","page":"Univariate polynomials","title":"Remove and valuation","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"evaluate2(::arb_poly, ::Integer)\nevaluate2(::arb_poly, ::Float64)\nevaluate2(::arb_poly, ::fmpz)\nevaluate2(::arb_poly, ::fmpq)\nevaluate2(::arb_poly, ::arb)\nevaluate2(::arb_poly, ::acb)","category":"page"},{"location":"polynomial/#Nemo.evaluate2-Tuple{arb_poly, Integer}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::arb_poly, y::Integer)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{arb_poly, Float64}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::arb_poly, y::Float64)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{arb_poly, fmpz}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::arb_poly, y::fmpz)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{arb_poly, fmpq}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::arb_poly, y::fmpq)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{arb_poly, arb}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::arb_poly, y::arb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{arb_poly, acb}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::arb_poly, y::acb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"evaluate2(::acb_poly, ::Integer)\nevaluate2(::acb_poly, ::Float64)\nevaluate2(::acb_poly, ::fmpz)\nevaluate2(::acb_poly, ::fmpq)\nevaluate2(::acb_poly, ::arb)\nevaluate2(::acb_poly, ::acb)","category":"page"},{"location":"polynomial/#Nemo.evaluate2-Tuple{acb_poly, Integer}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::acb_poly, y::Integer)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{acb_poly, Float64}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::acb_poly, y::Float64)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{acb_poly, fmpz}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::acb_poly, y::fmpz)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{acb_poly, fmpq}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::acb_poly, y::fmpq)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{acb_poly, arb}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::acb_poly, y::arb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.evaluate2-Tuple{acb_poly, acb}","page":"Univariate polynomials","title":"Nemo.evaluate2","text":"evaluate2(x::acb_poly, y::acb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"RR = RealField(64)\nT, z = PolynomialRing(RR, \"z\")\n   \nh = z^2 + 2z + 1\n\ns, t = evaluate2(h, RR(\"2.0 +/- 0.1\"))","category":"page"},{"location":"polynomial/#Signature","page":"Univariate polynomials","title":"Signature","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"signature(::fmpz_poly)\nsignature(::fmpq_poly)","category":"page"},{"location":"polynomial/#Nemo.signature-Tuple{fmpz_poly}","page":"Univariate polynomials","title":"Nemo.signature","text":"signature(f::fmpz_poly)\n\nReturn the signature of the polynomial f, i.e. a tuple (r s) such that r is the number of real roots of f and s is half the number of complex roots.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.signature-Tuple{fmpq_poly}","page":"Univariate polynomials","title":"Nemo.signature","text":"signature(f::fmpq_poly)\n\nReturn the signature of f, i.e. a tuple (r s) where r is the number of real roots of f and s is half the number of complex roots.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R, x = PolynomialRing(ZZ, \"x\")\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)","category":"page"},{"location":"polynomial/#Root-finding","page":"Univariate polynomials","title":"Root finding","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"roots(::acb_poly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.roots-Tuple{acb_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.Generic.roots","text":"roots(x::acb_poly; target=0, isolate_real=false, initial_prec=0, max_prec=0, max_iter=0)\n\nAttempts to isolate the complex roots of the complex polynomial x by iteratively refining balls in which they lie.\n\nThis is done by increasing the working precision, starting at initial_prec. The maximal number of iterations can be set using max_iter and the maximal precision can be set using max_prec.\n\nIf isolate_real is set and x is strictly real, then the real roots will be isolated from the non-real roots. Every root will have either zero, positive or negative real part.\n\nIt is assumed that x is squarefree.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"CC = ComplexField(64)\nC, y = PolynomialRing(CC, \"y\")\n\nm = y^2 + 2y + 3\nn = m + CC(\"0 +/- 0.0001\", \"0 +/- 0.0001\")\n\nr = roots(n)\n\np = y^7 - 1\n\nr = roots(n, isolate_real = true)","category":"page"},{"location":"polynomial/#Construction-from-roots","page":"Univariate polynomials","title":"Construction from roots","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"from_roots(::ArbPolyRing, ::Vector{arb})\nfrom_roots(::AcbPolyRing, ::Vector{acb})","category":"page"},{"location":"polynomial/#Nemo.from_roots-Tuple{ArbPolyRing, Vector{arb}}","page":"Univariate polynomials","title":"Nemo.from_roots","text":"from_roots(R::ArbPolyRing, b::Vector{arb})\n\nConstruct a polynomial in the given polynomial ring from a list of its roots.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.from_roots-Tuple{AcbPolyRing, Vector{acb}}","page":"Univariate polynomials","title":"Nemo.from_roots","text":"from_roots(R::AcbPolyRing, b::Vector{acb})\n\nConstruct a polynomial in the given polynomial ring from a list of its roots.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"RR = RealField(64)\nR, x = PolynomialRing(RR, \"x\")\n\nxs = arb[inv(RR(i)) for i=1:5]\nf = from_roots(R, xs)","category":"page"},{"location":"polynomial/#Bounding-absolute-values-of-roots","page":"Univariate polynomials","title":"Bounding absolute values of roots","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"roots_upper_bound(::arb_poly)\nroots_upper_bound(::acb_poly)","category":"page"},{"location":"polynomial/#Nemo.roots_upper_bound-Tuple{arb_poly}","page":"Univariate polynomials","title":"Nemo.roots_upper_bound","text":"roots_upper_bound(x::arb_poly) -> arb\n\nReturns an upper bound for the absolute value of all complex roots of x.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.roots_upper_bound-Tuple{acb_poly}","page":"Univariate polynomials","title":"Nemo.roots_upper_bound","text":"roots_upper_bound(x::acb_poly) -> arb\n\nReturns an upper bound for the absolute value of all complex roots of x.\n\n\n\n","category":"method"},{"location":"polynomial/#Lifting","page":"Univariate polynomials","title":"Lifting","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from mathbbZnmathbbZ to mathbbZ.","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"lift(::FmpzPolyRing, ::nmod_poly)\nlift(::FmpzPolyRing, ::gfp_poly)\nlift(::FmpzPolyRing, ::fmpz_mod_poly)\nlift(::FmpzPolyRing, ::gfp_fmpz_poly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.lift-Tuple{FmpzPolyRing, nmod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.lift","text":"function lift(R::FmpzPolyRing, y::nmod_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.lift-Tuple{FmpzPolyRing, gfp_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.lift","text":"lift(R::FmpzPolyRing, y::gfp_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.lift-Tuple{FmpzPolyRing, fmpz_mod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.lift","text":"function lift(R::FmpzPolyRing, y::fmpz_mod_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.lift-Tuple{FmpzPolyRing, gfp_fmpz_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.lift","text":"function lift(R::FmpzPolyRing, y::gfp_fmpz_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R, \"x\")\nT, y = PolynomialRing(ZZ, \"y\")\n\nf = x^2 + 2x + 1\n\na = lift(T, f)","category":"page"},{"location":"polynomial/#Overlapping-and-containment","page":"Univariate polynomials","title":"Overlapping and containment","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Occasionally it is useful to be able to tell when inexact polynomials overlap or contain other exact or inexact polynomials. The following functions are provided for this purpose.","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"overlaps(::arb_poly, ::arb_poly)\noverlaps(::acb_poly, ::acb_poly)","category":"page"},{"location":"polynomial/#Nemo.overlaps-Tuple{arb_poly, arb_poly}","page":"Univariate polynomials","title":"Nemo.overlaps","text":"overlaps(x::arb_poly, y::arb_poly)\n\nReturn true if the coefficient balls of x overlap the coefficient balls of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.overlaps-Tuple{acb_poly, acb_poly}","page":"Univariate polynomials","title":"Nemo.overlaps","text":"overlaps(x::acb_poly, y::acb_poly)\n\nReturn true if the coefficient boxes of x overlap the coefficient boxes of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"contains(::arb_poly, ::arb_poly)\ncontains(::acb_poly, ::acb_poly)","category":"page"},{"location":"polynomial/#Base.contains-Tuple{arb_poly, arb_poly}","page":"Univariate polynomials","title":"Base.contains","text":"contains(x::arb_poly, y::arb_poly)\n\nReturn true if the coefficient balls of x contain the corresponding coefficient balls of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Base.contains-Tuple{acb_poly, acb_poly}","page":"Univariate polynomials","title":"Base.contains","text":"contains(x::acb_poly, y::acb_poly)\n\nReturn true if the coefficient boxes of x contain the corresponding coefficient boxes of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"contains(::arb_poly, ::fmpz_poly)\ncontains(::arb_poly, ::fmpq_poly)\ncontains(::acb_poly, ::fmpz_poly)\ncontains(::acb_poly, ::fmpq_poly)","category":"page"},{"location":"polynomial/#Base.contains-Tuple{arb_poly, fmpz_poly}","page":"Univariate polynomials","title":"Base.contains","text":"contains(x::arb_poly, y::fmpz_poly)\n\nReturn true if the coefficient balls of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Base.contains-Tuple{arb_poly, fmpq_poly}","page":"Univariate polynomials","title":"Base.contains","text":"contains(x::arb_poly, y::fmpq_poly)\n\nReturn true if the coefficient balls of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Base.contains-Tuple{acb_poly, fmpz_poly}","page":"Univariate polynomials","title":"Base.contains","text":"contains(x::acb_poly, y::fmpz_poly)\n\nReturn true if the coefficient boxes of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Base.contains-Tuple{acb_poly, fmpq_poly}","page":"Univariate polynomials","title":"Base.contains","text":"contains(x::acb_poly, y::fmpq_poly)\n\nReturn true if the coefficient boxes of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"It is sometimes also useful to be able to determine if there is a unique integer contained in the coefficient of an inexact constant polynomial.","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"unique_integer(::arb_poly)\nunique_integer(::acb_poly)","category":"page"},{"location":"polynomial/#Nemo.unique_integer-Tuple{arb_poly}","page":"Univariate polynomials","title":"Nemo.unique_integer","text":"unique_integer(x::arb_poly)\n\nReturn a tuple (t, z) where t is true if there is a unique integer contained in each of the coefficients of x, otherwise sets t to false. In the former case, z is set to the integer polynomial.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.unique_integer-Tuple{acb_poly}","page":"Univariate polynomials","title":"Nemo.unique_integer","text":"unique_integer(x::acb_poly)\n\nReturn a tuple (t, z) where t is true if there is a unique integer contained in the (constant) polynomial x, along with that integer z in case it is, otherwise sets t to false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"We also have the following functions.","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"isreal(::acb_poly)","category":"page"},{"location":"polynomial/#Base.isreal-Tuple{acb_poly}","page":"Univariate polynomials","title":"Base.isreal","text":"isreal(x::acb_poly)\n\nReturn true if all the coefficients of x are real, i.e. have exact zero imaginary parts.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"RR = RealField(64)\nCC = ComplexField(64)\nR, x = PolynomialRing(RR, \"x\")\nC, y = PolynomialRing(CC, \"y\")\nZx, zx = PolynomialRing(ZZ, \"x\")\nQx, qx = PolynomialRing(QQ, \"x\")\n\nf = x^2 + 2x + 1\nh = f + RR(\"0 +/- 0.0001\")\nk = f + RR(\"0 +/- 0.0001\") * x^4\nm = y^2 + 2y + 1\nn = m + CC(\"0 +/- 0.0001\", \"0 +/- 0.0001\")\n\ncontains(h, f)\noverlaps(f, k)\ncontains(n, m)\nt, z = unique_integer(k)\nisreal(n)","category":"page"},{"location":"polynomial/#Factorisation","page":"Univariate polynomials","title":"Factorisation","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Polynomials can be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"isirreducible(::nmod_poly)\nisirreducible(::gfp_poly)\nisirreducible(::fmpz_mod_poly)\nisirreducible(::gfp_fmpz_poly)\nisirreducible(::fq_poly)\nisirreducible(::fq_nmod_poly)","category":"page"},{"location":"polynomial/#Nemo.isirreducible-Tuple{nmod_poly}","page":"Univariate polynomials","title":"Nemo.isirreducible","text":"isirreducible(x::nmod_poly)\n\nReturn true if x is irreducible, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.isirreducible-Tuple{gfp_poly}","page":"Univariate polynomials","title":"Nemo.isirreducible","text":"isirreducible(x::gfp_poly)\n\nReturn true if x is irreducible, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.isirreducible-Tuple{fmpz_mod_poly}","page":"Univariate polynomials","title":"Nemo.isirreducible","text":"isirreducible(x::fmpz_mod_poly)\n\nReturn true if x is irreducible, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.isirreducible-Tuple{gfp_fmpz_poly}","page":"Univariate polynomials","title":"Nemo.isirreducible","text":"isirreducible(x::gfp_fmpz_poly)\n\nReturn true if x is irreducible, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.isirreducible-Tuple{fq_poly}","page":"Univariate polynomials","title":"Nemo.isirreducible","text":"isirreducible(x::fq_poly)\n\nReturn true if x is irreducible, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.isirreducible-Tuple{fq_nmod_poly}","page":"Univariate polynomials","title":"Nemo.isirreducible","text":"isirreducible(x::fq_nmod_poly)\n\nReturn true if x is irreducible, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"issquarefree(::nmod_poly)\nissquarefree(::gfp_poly)\nissquarefree(::fmpz_mod_poly)\nissquarefree(::gfp_fmpz_poly)\nissquarefree(::fq_poly)\nissquarefree(::fq_nmod_poly)","category":"page"},{"location":"polynomial/#Nemo.issquarefree-Tuple{nmod_poly}","page":"Univariate polynomials","title":"Nemo.issquarefree","text":"issquarefree(x::nmod_poly)\n\nReturn true if x is squarefree, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.issquarefree-Tuple{gfp_poly}","page":"Univariate polynomials","title":"Nemo.issquarefree","text":"issquarefree(x::gfp_poly)\n\nReturn true if x is squarefree, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.issquarefree-Tuple{fmpz_mod_poly}","page":"Univariate polynomials","title":"Nemo.issquarefree","text":"issquarefree(x::fmpz_mod_poly)\n\nReturn true if x is squarefree, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.issquarefree-Tuple{gfp_fmpz_poly}","page":"Univariate polynomials","title":"Nemo.issquarefree","text":"issquarefree(x::gfp_fmpz_poly)\n\nReturn true if x is squarefree, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.issquarefree-Tuple{fq_poly}","page":"Univariate polynomials","title":"Nemo.issquarefree","text":"issquarefree(x::fq_poly)\n\nReturn true if x is squarefree, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.issquarefree-Tuple{fq_nmod_poly}","page":"Univariate polynomials","title":"Nemo.issquarefree","text":"issquarefree(x::fq_nmod_poly)\n\nReturn true if x is squarefree, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"factor(::fmpz_poly)\nfactor(::nmod_poly)\nfactor(::gfp_poly)\nfactor(::fmpz_mod_poly)\nfactor(::gfp_fmpz_poly)\nfactor(::fq_poly)\nfactor(::fq_nmod_poly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{fmpz_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::fmpz_poly)\n\nReturns the factorization of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{nmod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::nmod_poly)\n\nReturn the factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{gfp_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::gfp_poly)\n\nReturn the factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{fmpz_mod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::fmpz_mod_poly)\n\nReturn the factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{gfp_fmpz_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::gfp_fmpz_poly)\n\nReturn the factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{fq_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::fq_poly)\n\nReturn the factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{fq_nmod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::fq_nmod_poly)\n\nReturn the factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"factor_squarefree(::nmod_poly)\nfactor_squarefree(::gfp_poly)\nfactor_squarefree(::fmpz_mod_poly)\nfactor_squarefree(::gfp_fmpz_poly)\nfactor_squarefree(::fq_poly)\nfactor_squarefree(::fq_nmod_poly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.factor_squarefree-Tuple{nmod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor_squarefree","text":"factor_squarefree(x::nmod_poly)\n\nReturn the squarefree factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor_squarefree-Tuple{gfp_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor_squarefree","text":"factor_squarefree(x::gfp_poly)\n\nReturn the squarefree factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor_squarefree-Tuple{fmpz_mod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor_squarefree","text":"factor_squarefree(x::fmpz_mod_poly)\n\nReturn the squarefree factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor_squarefree-Tuple{gfp_fmpz_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor_squarefree","text":"factor_squarefree(x::gfp_fmpz_poly)\n\nReturn the squarefree factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor_squarefree-Tuple{fq_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor_squarefree","text":"factor_squarefree(x::fq_poly)\n\nReturn the squarefree factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.factor_squarefree-Tuple{fq_nmod_poly}","page":"Univariate polynomials","title":"AbstractAlgebra.factor_squarefree","text":"factor_squarefree(x::fq_nmod_poly)\n\nReturn the squarefree factorisation of x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"factor_distinct_deg(::nmod_poly)\nfactor_distinct_deg(::gfp_poly)\nfactor_distinct_deg(::fmpz_mod_poly)\nfactor_distinct_deg(::gfp_fmpz_poly)\nfactor_distinct_deg(::fq_poly)\nfactor_distinct_deg(::fq_nmod_poly)","category":"page"},{"location":"polynomial/#Nemo.factor_distinct_deg-Tuple{nmod_poly}","page":"Univariate polynomials","title":"Nemo.factor_distinct_deg","text":"factor_distinct_deg(x::nmod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.factor_distinct_deg-Tuple{gfp_poly}","page":"Univariate polynomials","title":"Nemo.factor_distinct_deg","text":"factor_distinct_deg(x::gfp_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.factor_distinct_deg-Tuple{fmpz_mod_poly}","page":"Univariate polynomials","title":"Nemo.factor_distinct_deg","text":"factor_distinct_deg(x::fmpz_mod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.factor_distinct_deg-Tuple{gfp_fmpz_poly}","page":"Univariate polynomials","title":"Nemo.factor_distinct_deg","text":"factor_distinct_deg(x::fmpz_mod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.factor_distinct_deg-Tuple{fq_poly}","page":"Univariate polynomials","title":"Nemo.factor_distinct_deg","text":"factor_distinct_deg(x::fq_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"polynomial/#Nemo.factor_distinct_deg-Tuple{fq_nmod_poly}","page":"Univariate polynomials","title":"Nemo.factor_distinct_deg","text":"factor_distinct_deg(x::fq_nmod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R, \"x\")\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))","category":"page"},{"location":"polynomial/#Special-functions","page":"Univariate polynomials","title":"Special functions","text":"","category":"section"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"cyclotomic(::Int, ::fmpz_poly)","category":"page"},{"location":"polynomial/#Nemo.cyclotomic-Tuple{Int64, fmpz_poly}","page":"Univariate polynomials","title":"Nemo.cyclotomic","text":"cyclotomic(n::Int, x::fmpz_poly)\n\nReturn the nth cyclotomic polynomial, defined as Phi_n(x) = prod_omega (x-omega) where omega runs over all the nth primitive roots of unity.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"swinnerton_dyer(::Int, ::fmpz_poly)","category":"page"},{"location":"polynomial/#Nemo.swinnerton_dyer-Tuple{Int64, fmpz_poly}","page":"Univariate polynomials","title":"Nemo.swinnerton_dyer","text":"swinnerton_dyer(n::Int, x::fmpz_poly)\n\nReturn the Swinnerton-Dyer polynomial S_n, defined as the integer polynomial S_n = prod (x pm sqrt2 pm sqrt3 pm sqrt5 pm ldots pm sqrtp_n) where p_n denotes the n-th prime number and all combinations of signs are taken. This polynomial has degree 2^n and is irreducible over the integers (it is the minimal polynomial of sqrt2 + ldots + sqrtp_n).\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"cos_minpoly(::Int, ::fmpz_poly)","category":"page"},{"location":"polynomial/#Nemo.cos_minpoly-Tuple{Int64, fmpz_poly}","page":"Univariate polynomials","title":"Nemo.cos_minpoly","text":"cos_minpoly(n::Int, x::fmpz_poly)\n\nReturn the minimal polynomial of 2 cos(2 pi  n). For suitable choice of n, this gives the minimal polynomial of 2 cos(a pi) or 2 sin(a pi) for any rational a.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"theta_qexp(::Int, ::Int, ::fmpz_poly)","category":"page"},{"location":"polynomial/#Nemo.theta_qexp-Tuple{Int64, Int64, fmpz_poly}","page":"Univariate polynomials","title":"Nemo.theta_qexp","text":"theta_qexp(e::Int, n::Int, x::fmpz_poly)\n\nReturn the q-expansion to length n of the Jacobi theta function raised to the power r, i.e. vartheta(q)^r where vartheta(q) = 1 + sum_k=1^infty q^k^2.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"eta_qexp(::Int, ::Int, ::fmpz_poly)","category":"page"},{"location":"polynomial/#Nemo.eta_qexp-Tuple{Int64, Int64, fmpz_poly}","page":"Univariate polynomials","title":"Nemo.eta_qexp","text":"eta_qexp(e::Int, n::Int, x::fmpz_poly)\n\nReturn the q-expansion to length n of the Dedekind eta function (without the leading factor q^124) raised to the power r, i.e. (q^-124 eta(q))^r = prod_k=1^infty (1 - q^k)^r. In particular, r = -1 gives the generating function of the partition function p(k), and r = 24 gives, after multiplication by q, the modular discriminant Delta(q) which generates the Ramanujan tau function tau(k).\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\n\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"CurrentModule = Nemo","category":"page"},{"location":"developer/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"developer/interfaces/#Functionality-for-Generic-and-Abstract-Types","page":"Interfaces","title":"Functionality for Generic and Abstract Types","text":"","category":"section"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"As previously mentioned, Nemo provides various generic types, e.g. Poly{T} for generic univariate polynomials and Mat{T} for generic matrices over a base ring. These and other polynomial and matrix types belong in turn to abstract types or unions thereof, e.g. PolyElem{T} is an abstract type representing all univariate polynomial types and MatrixElem{T} is a union of all Nemo matrix types.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"When implementing generic functionality, one should usually implement it for the abstract types and unions thereof, since the new functionality will then work for all types of the specified kind, instead of just the generic types.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"In order for this to work in practice, such implementations can only use functions in the relevant official interface. These are the functions required to be implemented by all types of that kind. For example, matrix implementations make heavy use of addeq! and mul! to accumulate entries, but they cannot make use of functions such as subeq! as it is not part of the official interface.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"In addition to implementations for abstract types and their unions, one may also like to provide specialised implementations for the generic types e.g. Poly{T} and Mat{T} as one would for other specialised types. The generic types are based on Julia arrays internally, and so it makes perfect sense to implement lower level functionality for these types specifically, as this may lead to performance gains. Such specialised implementations can make use of any functions provided for the generic types, whether in the interface or not.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"For convenience we list the most important abstract types and their unions for which one should usually prefer to write generic implementations.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"PolyElem{T} : all univariate polynomial types\nMPolyElem{T} : all multivariate polynomial types (see note below)\nMatrixElem{T} : union of all matrix types including matrix algebras\nMatElem{T} : all matrix types not including matrix algebras\nAbsSeriesElem{T} : all abstract series types\nRelSeriesElem{T} : all relative series types\nLaurentSeriesElem{T} : union of all Laurent series over rings and fields\nPuiseuxSeriesElem{T} : union of all Puiseux series over rings and fields\nFPModule{T} : all finitely presented modules over a Euclidean domain\nFPModuleElem{T} : all elems of fin. presented modules over a Euc. domain\nFracElem{T} : all fractions\nResElem{T} : all elements of a residue ring\nResFieldElem{T} : all elements of a residue field\nMap{D, C} : all maps (see Maps developer docs for a description)","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"N.B: inside the Generic submodule of AbstractAlgebra some abstract types Blah are only accessible by writing AbstractAlgebra.Blah. The unions are directly accessible. There may be generic types and abstract types with the same name, so this is more than just a convention.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Note that multivariate polynomials tend to require very specialised implementations depending heavily on implementation details of the specific multivariate type. Therefore it is rare to write implementations for the abstract type MPolyElem{T}. Instead, implementations tend to be done for each concrete multivariate type separately.","category":"page"},{"location":"developer/interfaces/#Generic-interfaces","page":"Interfaces","title":"Generic interfaces","text":"","category":"section"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"As mentioned above, the generic implementations in Nemo depend on carefully written interfaces for each of the abstract types provided by the system.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"These interfaces are spelled out in the AbstractAlgebra documentation. Note that a generic implementation may depend on functions in both the required and optional interfaces as the optional functions are all implemented with generic fallbacks in terms of the required functions.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"For convenience we provide here a list of interfaces that can be relied on in generic implementations, along with a description.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Ring : all commutative rings in the system\nField : all fields in the system\nNCRing : all rings in the system (not necessarily commutative)\nEuclidean Ring : Euclidean rings (see notes below)\nUnivariate Polynomial Ring : all dense univariate polynomials\nMultivariate Polynomial Ring : all sparse distributed multivariate polys.\nSeries Ring : all series, relative and absolute\nResidue Ring : all quotients of gcd domains with gcdx by a principal ideal\nFraction Field : all fractions over a gcd domain with gcdx\nModule : all finitely presented modules over a Euclidean domain\nMatrix : all matrices over a commutative ring\nMap : all (set) maps in the system","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Although we allow Z/nZ in our definition of Euclidean ring, much of the functionality in Nemo can be expected to misbehave (impossible inverses, etc.) when working with Euclidean rings that are not domains. In some cases the algorithms just don't exist, and in other cases we simply haven't implemented the required functionality to support all Euclidean rings for which computations can be done.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Whether a ring is a Euclidean domain or not cannot be encoded in the type. Thus there is no abstract type for Euclidean domains or their elements. Instead, generic functions rely on the existence of certain functions such as gcdx to implement functionality for Euclidean domains.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"There is also currently no way to define a Euclidean function for a given ring (which is known to be Euclidean) and have the system recognise the ring as such. This kind of Euclidean interface may be provided in a future version of Nemo.","category":"page"},{"location":"developer/interfaces/#Julia-interfaces-we-support","page":"Interfaces","title":"Julia interfaces we support","text":"","category":"section"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Many Julia interfaces rely on being able to create zero and one elements given the type only. As we use the parent/element model (see developer notes on this topic) we cannot support all Julia interfaces fully.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"We do however partially implement some Julia interfaces.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Iteration : iterators are currently provided for multivariate polynomials to iterate over the coefficients, terms and monomials. Nemo matrices can also be iterated over. Iteration proceeds down each column in turn. One can also iterate over all permutations and partitions. Finally, all finite field types can be iterated over.\nViews : because C libraries cannot be expected to implement the full range of Julia view types, views of matrices in Nemo can only be constructed for submatrices consisting of contiguous blocks in the original matrix.\nmap and similar : we implement the map and similar interfaces with the caveat that we generally use parent objects where Julia would use types. See the specific documentation for the module of interest to see details.\nzero and one : these are implemented for parent types, which is not what Julia typically expects. Exceptions include the Flint fmpz and fmpq types, as their parents are not parameterised, which makes it possible to implement these functions for the types as well as the parents.\nrand : we have a Nemo specific rand interface, which passes the tail of a given rand invocation to the rand function for the base ring, e.g. to create random matrix elements or polynomial coefficients and so on. In addition to this custom rand interface, we also support much of the Julia rand interface, with the usual caveat that we use parent objects instead of types where necessary.\nserialisation : unfortunately this is currently NOT implemented by Nemo, but we would certainly like to see that done in the future. It's not automatic because of the C objects that underly many of our constructions.\nNumber : Nemo number types do NOT belong to Julia's Number hierarchy, as we must make all our ring element types belong to our RingElem abstract type. To make some Julia Number types cooperate with Nemo, we define the unions RingElement and FieldElement which include some Julia types, such as BigInt and Rational{BigInt}, etc. Note that fixed precision integer types cannot be expected to be well-behaved when they overflow. We recommend using Nemo integer types if one wants good performance for small machine word sized integers, but no overflow when the integer becomes large (Nemo integers are based on Flint's multiprecision fmpz type).\nhash : we implement hash functions for all major element types in Nemo.\ngetindex/setindex!/typed_hvcat : we implement these to access elements of Nemo matrices, however see the note below on row major representation. In  addition, we allow creation of matrices using the notation R[a b; c d] etc. This is done by overloading typed_hvcat for the parent object R instead of a type as Julia would normally expect. This produces a Nemo matrix rather than a Julia one. Note that when passed a type, Julia's typed_hvcat can only construct Julia matrices for Nemo types such as fmpz and fmpq where elements can be constructed from types alone.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Many other Julia interfaces are either not yet implemented or only very partially implemented.","category":"page"},{"location":"developer/interfaces/#Column-major-vs-row-major-matrices","page":"Interfaces","title":"Column major vs row major matrices","text":"","category":"section"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Whereas Julia uses column major representation for its matrices, Nemo follows the convention of the C libraries it wraps and uses row major representation. Although Julia 2-D arrays are used internally in Nemo's generic matrix type, the interface from the perspective of the user is still the Nemo row major convention, not the Julia column major convention.","category":"page"},{"location":"developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"In row major representation, some row operations may be able to be performed more cheaply than similar column operations. In column major representation the converse is true. This may mean that some Julia matrix implementations may perform more slowly if naively ported to Nemo matrices, unless suitably modified.","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"CurrentModule = Nemo","category":"page"},{"location":"residue/#Residue-rings","page":"Residue rings","title":"Residue rings","text":"","category":"section"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"Nemo allows the creation of residue rings of the form R(a) for an element a of a ring R.","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"We don't require (a) to be a prime or maximal ideal. Instead, we allow the creation of the residue ring R(a) for any nonzero a and simply raise an exception if an impossible inverse is encountered during computations  involving elements of R(a). Of course, a GCD function must be available for the base ring R.","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"There is a generic implementation of residue rings of this form in AbstractAlgebra.jl, which accepts any ring R as base ring.","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"The associated types of parent object and elements for each kind of residue rings in Nemo are given in the following table.","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Res{T} Generic.ResRing{T}\nmathbbZ (Int modulus) Flint nmod NmodRing\nmathbbZ (ZZ modulus) Flint fmpz_mod FmpzModRing","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"The modulus a of a residue ring is stored in its parent object.","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"All residue element types belong to the abstract type ResElem and all the residue ring parent object types belong to the abstract type ResRing. This enables one to write generic functions that accept any Nemo residue type.","category":"page"},{"location":"residue/#Residue-functionality","page":"Residue rings","title":"Residue functionality","text":"","category":"section"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"All the residue rings in Nemo provide the functionality described in AbstractAlgebra for residue rings:","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/residue","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"In addition, generic residue rings are available.","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"We describe Nemo specific residue ring functionality below.","category":"page"},{"location":"residue/#GCD","page":"Residue rings","title":"GCD","text":"","category":"section"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"gcdx(::nmod, ::nmod)\ngcdx(::fmpz_mod, ::fmpz_mod)","category":"page"},{"location":"residue/#Base.gcdx-Tuple{nmod, nmod}","page":"Residue rings","title":"Base.gcdx","text":"gcdx(a::nmod, b::nmod)\n\nCompute the extended gcd with the Euclidean structure inherited from mathbbZ.\n\n\n\n","category":"method"},{"location":"residue/#Base.gcdx-Tuple{fmpz_mod, fmpz_mod}","page":"Residue rings","title":"Base.gcdx","text":"gcdx(a::fmpz_mod, b::fmpz_mod)\n\nCompute the extended gcd with the Euclidean structure inherited from mathbbZ.\n\n\n\n","category":"method"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"Examples","category":"page"},{"location":"residue/","page":"Residue rings","title":"Residue rings","text":"R = ResidueRing(ZZ, 123456789012345678949)\n\ng, s, t = gcdx(R(123), R(456))","category":"page"},{"location":"factor/","page":"Factorisation","title":"Factorisation","text":"CurrentModule = Nemo\nDocTestSetup = quote\n  using Nemo\nend","category":"page"},{"location":"factor/#Factorisation","page":"Factorisation","title":"Factorisation","text":"","category":"section"},{"location":"factor/","page":"Factorisation","title":"Factorisation","text":"Nemo provides a unified interface to handle factorisations using the Fact objects. These can only be constructed using the factor function for the respective ring elements. This is best illustrated by an example.","category":"page"},{"location":"factor/","page":"Factorisation","title":"Factorisation","text":"julia> fac = factor(ZZ(-6000361807272228723606))\n-1 * 2 * 229^3 * 43669^3 * 3\n\njulia> unit(fac)\n-1\n\njulia> -6000361807272228723606 == unit(fac) * prod([ p^e for (p, e) in fac])\ntrue\n\njulia> for (p, e) in fac; println(\"$p $e\"); end\n2 1\n229 3\n43669 3\n3 1\n\njulia> 229 in fac\ntrue\n\njulia> fac[229]\n3","category":"page"},{"location":"factor/#Basic-functionality","page":"Factorisation","title":"Basic functionality","text":"","category":"section"},{"location":"factor/","page":"Factorisation","title":"Factorisation","text":"Objects of type Fac are iterable, that is, if a is an object of type Fac, then for (p, e) in a will iterate through all pairs (p, e), where p is a factor and e the corresponding exponent.","category":"page"},{"location":"factor/","page":"Factorisation","title":"Factorisation","text":"in(::fmpz, ::Fac{fmpz})\ngetindex(::Fac{fmpz}, ::fmpz)\nlength(::Fac{fmpz})\nunit(::Fac{fmpz})","category":"page"},{"location":"factor/#Base.in-Tuple{fmpz, Fac{fmpz}}","page":"Factorisation","title":"Base.in","text":"in(a, b::Fac)\n\nTest whether a is a factor of b.\n\n\n\n","category":"method"},{"location":"factor/#Base.getindex-Tuple{Fac{fmpz}, fmpz}","page":"Factorisation","title":"Base.getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n","category":"method"},{"location":"factor/#Base.length-Tuple{Fac{fmpz}}","page":"Factorisation","title":"Base.length","text":"length(a::Fac) -> Int\n\nReturn the number of factors of a, not including the unit.\n\n\n\n","category":"method"},{"location":"factor/#AbstractAlgebra.unit-Tuple{Fac{fmpz}}","page":"Factorisation","title":"AbstractAlgebra.unit","text":"unit(a::Fac{T}) -> T\n\nReturn the unit of the factorization.\n\n\n\n","category":"method"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"CurrentModule = Nemo","category":"page"},{"location":"developer/future/#Future-plans","page":"Future plans","title":"Future plans","text":"","category":"section"},{"location":"developer/future/#Ring-and-CommRing","page":"Future plans","title":"Ring and CommRing","text":"","category":"section"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"Currently all commutative ring types belong to Ring and their elements to RingElem (and RingElement) and we have separate types for noncommutative rings and elements thereof, i.e. NCRing and NCRingElem etc.","category":"page"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"However, it would be more logical to use Ring for not necessarily commutative rings and CommRing, CRing or CommutativeRing (the name has not been decided on yet) for commutative rings.","category":"page"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"This is a big change and should happen with plenty of warning for the community. It would be convenient if a script could be made available to automate this.","category":"page"},{"location":"developer/future/#Mono-repository","page":"Future plans","title":"Mono repository","text":"","category":"section"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"There is currently a proposal to place all Oscar related repositories, or some subset of them in a single repository called OscarMono.jl. The details are not finalised and it is not known what impact this will have on Nemo. However, Nemo developers should be aware that this may happen at some point in the fairly near future.","category":"page"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"Users of Nemo should be unaffected, as Nemo will continue to exist as a separate package in the OscarMono.jl repository, even if it does become part of this repository. Julia supports multiple packages in the same repository nowadays.","category":"page"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"The possibility will always exist to separate the repositories again if the experiment is unsuccessful or serves its purpose and is no longer needed.","category":"page"},{"location":"developer/future/#Moving-implementations-from-Hecke","page":"Future plans","title":"Moving implementations from Hecke","text":"","category":"section"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"In the Hecke.jl project there are a vast number of implementations that were intended for AbstractAlgebra.jl and Nemo.jl. They exist in the src/Misc directory of that project.","category":"page"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"These implementations will eventually all be moved over to the correct repositories. Code, documentation and performance improvements will be added.","category":"page"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"A number of things must be taken into account when making such moves:","category":"page"},{"location":"developer/future/","page":"Future plans","title":"Future plans","text":"Substantial chunks of code should be moved at a time. The code can be initially placed in a src/Misc directory in AbstractAlgebra or Nemo until it can finally be integrated fully into the correct place in those projects.\nSome of the code calls full parent object constructors in generic code. Such calls should be removed where possible.\nSome functions such as exp and the like require Base to be prepended, as we do not import these functions from Base into Generic.\nSome of the code calls back into convenience functions found only in Hecke. These have to be rewritten in terms of AbstractAlgebra/Nemo functions.\nSome of the code relies on fmpz being available, but would otherwise be suitable for AbstractAlgebra. This code can hopefully be rewritten to be agnostic about the integer type.\nTodos, questions and so on should be moved to tickets.\nSometimes exception types differ between Hecke and Nemo, meaning that tests will fail due to the wrong type of exception being raised. Either the tests will have to be adjusted, or the Nemo exception types changed.\nRingElem is often used where RingElement is intended, etc. Also types are often unconstrained where Nemo would constrain them to RingElement.\nSome Hecke functions try to support generic types and specific concrete Nemo types in the same implementation. These will unfortunately have to either be split between AbstractAlgebra and Nemo or a completely generic implementation for abstract types will have to be made.\nSome Hecke implementations assume sub! and friends are available in generic code. These will have to be rewritten, usually by adding a single unary minus outside of a loop and switching to add! and friends inside the loops.\nTest code, docstrings and documentation will have to be added where they do not already exist.\nExports of the new functionality will have to be added.\nSome functions should be accompanied by similar functions that don't yet exist. For example if there is a blah_rows there probably should be a blah_cols function as well, etc.","category":"page"},{"location":"rational/","page":"Rationals","title":"Rationals","text":"CurrentModule = Nemo","category":"page"},{"location":"rational/#Rationals","page":"Rationals","title":"Rationals","text":"","category":"section"},{"location":"rational/","page":"Rationals","title":"Rationals","text":"Nemo provides much functionality for the rational numbers. See the section on Fraction Fields where all the basic functionality is documented, along with the extra functionality only available for the rational numbers themselves.","category":"page"},{"location":"constructors/#Constructing-mathematical-objects-in-Nemo","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"","category":"section"},{"location":"constructors/#Constructing-objects-in-Julia","page":"Constructing mathematical objects in Nemo","title":"Constructing objects in Julia","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function with the same name as the type itself. For example, to construct a BigInt object in Julia, we simply call the BigInt constructor:","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"n = BigInt(\"1234567898765434567898765434567876543456787654567890\")","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Julia also uses constructors to convert between types. For example, to convert an Int to a BigInt:","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"m = BigInt(123)","category":"page"},{"location":"constructors/#How-we-construct-objects-in-Nemo","page":"Constructing mathematical objects in Nemo","title":"How we construct objects in Nemo","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Julia types don't contain enough information to properly model groups, rings and fields, especially if they are parameterised by values. For example, the ring of integers modulo n for a multiprecision modulus n cannot be modeled using types alone.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Instead of using types to construct objects in Nemo, we use special objects that we refer to as parent objects. They behave a lot like Julia types.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Consider the following simple example, to create a Flint multiprecision integer:","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"n = ZZ(\"12345678765456787654567890987654567898765678909876567890\")","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Here ZZ is not a Julia type, but a callable object. However, for most purposes one can think of such a parent object ZZ as though it were a type.","category":"page"},{"location":"constructors/#Constructing-parent-objects","page":"Constructing mathematical objects in Nemo","title":"Constructing parent objects","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"For more complicated groups, rings, fields, etc., one first needs to construct the parent object before one can use it to construct element objects.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Nemo provides a set of functions for constructing such parent objects. For example, to create a parent object for polynomials over the integers, we use the PolynomialRing parent object constructor.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"R, x = PolynomialRing(ZZ, \"x\")\nf = x^3 + 3x + 1\ng = R(12)","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"In this example, R is the parent object and we use it to convert the Int value 12 to an element of the polynomial ring mathbbZx.","category":"page"},{"location":"constructors/#List-of-parent-object-constructors","page":"Constructing mathematical objects in Nemo","title":"List of parent object constructors","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"For convenience, we provide a list of all the parent object constructors in Nemo and explain what domains they represent.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Mathematics Nemo constructor\nR = mathbbZ R = ZZ\nR = mathbbQ R = QQ\nR = mathbbF_p^n R, a = FiniteField(p, n, \"a\")\nR = mathbbZnmathbbZ R = ResidueRing(ZZ, n)\nS = Rx S, x = PolynomialRing(R, \"x\")\nS = Rx y S, (x, y) = PolynomialRing(R, [\"x\", \"y\"])\nS = Rx (to precision n) S, x = PowerSeriesRing(R, n, \"x\")\nS = R((x)) (to precision n) S, x = LaurentSeriesRing(R, n, \"x\")\nS = mathrmFrac_R S = FractionField(R)\nS = R(f) S = ResidueRing(R, f)\nS = mathrmMat_mtimes n(R) S = MatrixSpace(R, m, n)\nS = mathbbQx(f) S, a = NumberField(f, \"a\")\nS = mathbbQ_p (to precision N) S = PadicField(p, n)\nS = mathbbR (to precision n) S = RealField(n)\nS = mathbbC (to precision n) S = ComplexField(n)","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"CurrentModule = Nemo","category":"page"},{"location":"matrix/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Nemo allow the creation of dense matrices over any computable ring R. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of matrices over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The following table shows each of the matrix types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of matrix (the type information is mainly of concern to developers).","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Mat{T} Generic.MatSpace{T}\nmathbbZ Flint fmpz_mat FmpzMatSpace\nmathbbZnmathbbZ (small n) Flint nmod_mat NmodMatSpace\nmathbbZnmathbbZ (large n) Flint fmpz_mod_mat FmpzModMatSpace\nmathbbQ Flint fmpq_mat FmpqMatSpace\nmathbbZpmathbbZ (small p) Flint gfp_mat GFPMatSpace\nmathbbF_p^n (small p) Flint fq_nmod_mat FqNmodMatSpace\nmathbbF_p^n (large p) Flint fq_mat `FqMatSpace\nmathbbR Arb arb_mat ArbMatSpace\nmathbbC Arb acb_mat AcbMatSpace","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The dimensions and base ring R of a generic matrix are stored in its parent object.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"All matrix element types belong to the abstract type MatElem and all of the matrix space types belong to the abstract type MatSpace. This enables one to write generic functions that can accept any Nemo matrix type.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Note that the preferred way to create matrices is not to use the type constructors but to use the matrix function, see also the Matrix element constructors section of the AbstractAlgebra manual.","category":"page"},{"location":"matrix/#Matrix-functionality","page":"Matrices","title":"Matrix functionality","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"All matrix spaces in Nemo provide the matrix functionality of AbstractAlgebra:","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/matrix","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Some of this functionality is provided in Nemo by C libraries, such as Flint, for various specific rings.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"In the following, we list the functionality which is provided in addition to the generic matrix functionality, for specific rings in Nemo.","category":"page"},{"location":"matrix/#Comparison-operators","page":"Matrices","title":"Comparison operators","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"overlaps(::arb_mat, ::arb_mat)","category":"page"},{"location":"matrix/#Nemo.overlaps-Tuple{arb_mat, arb_mat}","page":"Matrices","title":"Nemo.overlaps","text":"overlaps(x::arb_mat, y::arb_mat)\n\nReturns true if all entries of x overlap with the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"overlaps(::acb_mat, ::acb_mat)","category":"page"},{"location":"matrix/#Nemo.overlaps-Tuple{acb_mat, acb_mat}","page":"Matrices","title":"Nemo.overlaps","text":"overlaps(x::acb_mat, y::acb_mat)\n\nReturns true if all entries of x overlap with the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"contains(::arb_mat, ::arb_mat)","category":"page"},{"location":"matrix/#Base.contains-Tuple{arb_mat, arb_mat}","page":"Matrices","title":"Base.contains","text":"contains(x::arb_mat, y::arb_mat)\n\nReturns true if all entries of x contain the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"contains(::acb_mat, ::acb_mat)","category":"page"},{"location":"matrix/#Base.contains-Tuple{acb_mat, acb_mat}","page":"Matrices","title":"Base.contains","text":"contains(x::acb_mat, y::acb_mat)\n\nReturns true if all entries of x contain the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"In addition we have the following ad hoc comparison operators.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"C = RR[1 2; 3 4]\nD = RR[\"1 +/- 0.1\" \"2 +/- 0.1\"; \"3 +/- 0.1\" \"4 +/- 0.1\"]\noverlaps(C, D)\ncontains(D, C)","category":"page"},{"location":"matrix/#Scaling","page":"Matrices","title":"Scaling","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"<<(::fmpz_mat, ::Int)","category":"page"},{"location":"matrix/#Base.:<<-Tuple{fmpz_mat, Int64}","page":"Matrices","title":"Base.:<<","text":"<<(x::fmpz_mat, y::Int)\n\nReturn 2^yx.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":">>(::fmpz_mat, ::Int)","category":"page"},{"location":"matrix/#Base.:>>-Tuple{fmpz_mat, Int64}","page":"Matrices","title":"Base.:>>","text":">>(x::fmpz_mat, y::Int)\n\nReturn x2^y where rounding is towards zero.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nB = A<<5\nC = B>>2","category":"page"},{"location":"matrix/#Determinant","page":"Matrices","title":"Determinant","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"det_divisor(::fmpz_mat)","category":"page"},{"location":"matrix/#Nemo.det_divisor-Tuple{fmpz_mat}","page":"Matrices","title":"Nemo.det_divisor","text":"det_divisor(x::fmpz_mat)\n\nReturn some positive divisor of the determinant of x, if the determinant is nonzero, otherwise return zero.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"det_given_divisor(::fmpz_mat, ::Integer, ::Bool)\ndet_given_divisor(::fmpz_mat, ::fmpz, ::Bool)","category":"page"},{"location":"matrix/#Nemo.det_given_divisor-Tuple{fmpz_mat, Integer, Bool}","page":"Matrices","title":"Nemo.det_given_divisor","text":"det_given_divisor(x::fmpz_mat, d::Integer, proved=true)\n\nReturn the determinant of x given a positive divisor of its determinant. If proved == true (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.\n\n\n\n","category":"method"},{"location":"matrix/#Nemo.det_given_divisor-Tuple{fmpz_mat, fmpz, Bool}","page":"Matrices","title":"Nemo.det_given_divisor","text":"det_given_divisor(x::fmpz_mat, d::fmpz, proved=true)\n\nReturn the determinant of x given a positive divisor of its determinant. If proved == true (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nc = det_divisor(A)\nd = det_given_divisor(A, c)","category":"page"},{"location":"matrix/#Linear-solving","page":"Matrices","title":"Linear solving","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"cansolve(::fmpz_mat, ::fmpz_mat)","category":"page"},{"location":"matrix/#Nemo.cansolve-Tuple{fmpz_mat, fmpz_mat}","page":"Matrices","title":"Nemo.cansolve","text":"cansolve(a::fmpz_mat, b::fmpz_mat) -> Bool, fmpz_mat\n\nReturn true and a matrix x such that ax = b, or false and some matrix in case x does not exist.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"solve_dixon(::fmpz_mat, ::fmpz_mat)\nsolve_dixon(::fmpq_mat, ::fmpq_mat)","category":"page"},{"location":"matrix/#Nemo.solve_dixon-Tuple{fmpz_mat, fmpz_mat}","page":"Matrices","title":"Nemo.solve_dixon","text":"solve_dixon(a::fmpz_mat, b::fmpz_mat)\n\nReturn a tuple (x m) consisting of a column vector x such that ax = b pmodm. The element  b must be a column vector with the same number > of rows as a and a must be a square matrix. If these conditions are not met or (x d) does not exist, an exception is raised.\n\n\n\n","category":"method"},{"location":"matrix/#Nemo.solve_dixon-Tuple{fmpq_mat, fmpq_mat}","page":"Matrices","title":"Nemo.solve_dixon","text":"solve_dixon(a::fmpq_mat, b::fmpq_mat)\n\nSolve ax = b by clearing denominators and using Dixon's algorithm. This is usually faster for large systems.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\nT = MatrixSpace(ZZ, 3, 1)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])\nB = T([fmpz(4), 5, 7])\n\nX, m = solve_dixon(A, B)","category":"page"},{"location":"matrix/#Pseudo-inverse","page":"Matrices","title":"Pseudo inverse","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"pseudo_inv(::fmpz_mat)","category":"page"},{"location":"matrix/#AbstractAlgebra.pseudo_inv-Tuple{fmpz_mat}","page":"Matrices","title":"AbstractAlgebra.pseudo_inv","text":"pseudo_inv(x::fmpz_mat)\n\nReturn a tuple (z d) consisting of a matrix z and denominator d such that zd is the inverse of x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([1 0 1; 2 3 1; 5 6 7])\n\nB, d = pseudo_inv(A)","category":"page"},{"location":"matrix/#Nullspace","page":"Matrices","title":"Nullspace","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"nullspace_right_rational(x::fmpz_mat)","category":"page"},{"location":"matrix/#Nemo.nullspace_right_rational-Tuple{fmpz_mat}","page":"Matrices","title":"Nemo.nullspace_right_rational","text":"nullspace_right_rational(x::fmpz_mat)\n\nReturn a tuple (r U) consisting of a matrix U such that the first r columns form the right rational nullspace of x, i.e. a set of vectors over mathbbZ giving a mathbbQ-basis  for the nullspace of x considered as a matrix over mathbbQ.\n\n\n\n","category":"method"},{"location":"matrix/#Modular-reduction","page":"Matrices","title":"Modular reduction","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"reduce_mod(::fmpz_mat, ::Integer)\nreduce_mod(::fmpz_mat, ::fmpz)","category":"page"},{"location":"matrix/#Nemo.reduce_mod-Tuple{fmpz_mat, Integer}","page":"Matrices","title":"Nemo.reduce_mod","text":"reduce_mod(x::fmpz_mat, y::Integer)\n\nReduce the entries of x modulo y and return the result.\n\n\n\n","category":"method"},{"location":"matrix/#Nemo.reduce_mod-Tuple{fmpz_mat, fmpz}","page":"Matrices","title":"Nemo.reduce_mod","text":"reduce_mod(x::fmpz_mat, y::fmpz)\n\nReduce the entries of x modulo y and return the result.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])\n\nreduce_mod(A, ZZ(5))\nreduce_mod(A, 2)","category":"page"},{"location":"matrix/#Lifting","page":"Matrices","title":"Lifting","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lift(::nmod_mat)\nlift(::gfp_mat)","category":"page"},{"location":"matrix/#AbstractAlgebra.lift-Tuple{nmod_mat}","page":"Matrices","title":"AbstractAlgebra.lift","text":"lift(a::T) where {T <: Zmodn_mat}\n\nReturn a lift of the matrix a to a matrix over mathbbZ, i.e. where the entries of the returned matrix are those of a lifted to mathbbZ.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.lift-Tuple{gfp_mat}","page":"Matrices","title":"AbstractAlgebra.lift","text":"lift(a::gfp_mat)\n\nReturn a lift of the matrix a to a matrix over mathbbZ, i.e. where the entries of the returned matrix are those of a lifted to mathbbZ.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"R = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 3, 3)\n\na = S([4 5 6; 7 3 2; 1 4 5])\n\n b = lift(a)","category":"page"},{"location":"matrix/#Special-matrices","page":"Matrices","title":"Special matrices","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"hadamard(::FmpzMatSpace)","category":"page"},{"location":"matrix/#Nemo.hadamard-Tuple{FmpzMatSpace}","page":"Matrices","title":"Nemo.hadamard","text":"hadamard(R::FmpzMatSpace)\n\nReturn the Hadamard matrix for the given matrix space. The number of rows and columns must be equal.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"ishadamard(::fmpz_mat)","category":"page"},{"location":"matrix/#Nemo.ishadamard-Tuple{fmpz_mat}","page":"Matrices","title":"Nemo.ishadamard","text":"ishadamard(x::fmpz_mat)\n\nReturn true if the given matrix is Hadamard, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"hilbert(::FmpqMatSpace)","category":"page"},{"location":"matrix/#Nemo.hilbert-Tuple{FmpqMatSpace}","page":"Matrices","title":"Nemo.hilbert","text":"hilbert(R::FmpqMatSpace)\n\nReturn the Hilbert matrix in the given matrix space. This is the matrix with entries H_ij = 1(i + j - 1).\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"R = MatrixSpace(ZZ, 3, 3)\nS = MatrixSpace(QQ, 3, 3)\n\nA = hadamard(R)\nishadamard(A)\nB = hilbert(R)","category":"page"},{"location":"matrix/#Hermite-Normal-Form","page":"Matrices","title":"Hermite Normal Form","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"hnf(::fmpz_mat)","category":"page"},{"location":"matrix/#AbstractAlgebra.hnf-Tuple{fmpz_mat}","page":"Matrices","title":"AbstractAlgebra.hnf","text":"hnf(x::fmpz_mat)\n\nReturn the Hermite Normal Form of x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"hnf_with_transform(::fmpz_mat)","category":"page"},{"location":"matrix/#AbstractAlgebra.hnf_with_transform-Tuple{fmpz_mat}","page":"Matrices","title":"AbstractAlgebra.hnf_with_transform","text":"hnf_with_transform(x::fmpz_mat)\n\nCompute a tuple (H T) where H is the Hermite normal form of x and T is a transformation matrix so that H = Tx.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"hnf_modular(::fmpz_mat, ::fmpz)","category":"page"},{"location":"matrix/#Nemo.hnf_modular-Tuple{fmpz_mat, fmpz}","page":"Matrices","title":"Nemo.hnf_modular","text":"hnf_modular(x::fmpz_mat, d::fmpz)\n\nCompute the Hermite normal form of x given that d is a multiple of the determinant of the nonzero rows of x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"hnf_modular_eldiv(::fmpz_mat, ::fmpz)","category":"page"},{"location":"matrix/#Nemo.hnf_modular_eldiv-Tuple{fmpz_mat, fmpz}","page":"Matrices","title":"Nemo.hnf_modular_eldiv","text":"hnf_modular_eldiv(x::fmpz_mat, d::fmpz)\n\nCompute the Hermite normal form of x given that d is a multiple of the largest elementary divisor of x. The matrix x must have full rank.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"ishnf(::fmpz_mat)","category":"page"},{"location":"matrix/#AbstractAlgebra.ishnf-Tuple{fmpz_mat}","page":"Matrices","title":"AbstractAlgebra.ishnf","text":"ishnf(x::fmpz_mat)\n\nReturn true if the given matrix is in Hermite Normal Form, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = hnf(A)\nH, T = hnf_with_transform(A)\nM = hnf_modular(A, fmpz(27))\nN = hnf_modular_eldiv(A, fmpz(27))\nishnf(M)","category":"page"},{"location":"matrix/#Lattice-basis-reduction","page":"Matrices","title":"Lattice basis reduction","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Nemo provides LLL lattice basis reduction. Optionally one can specify the setup using a context object created by the following function.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll_ctx(delta::Float64, eta::Float64, rep=:zbasis, gram=:approx)","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Return a LLL context object specifying LLL parameters delta and eta and specifying the representation as either :zbasis or :gram and the Gram type as either :approx or :exact.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"Nemo.lll","text":"lll(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nReturn the LLL reduction of the matrix x. By default the matrix x is a mathbbZ-basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters delta = 099 and eta = 051. All of these defaults can be overridden by specifying an optional context object.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll_with_transform(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll_with_transform-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"Nemo.lll_with_transform","text":"lll_with_transform(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nCompute a tuple (L T) where L is the LLL reduction of a and T is a transformation matrix so that L = Ta. All the default parameters can be overridden by supplying an optional context object.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll_gram(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll_gram-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"Nemo.lll_gram","text":"lll_gram(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51, :gram))\n\nGiven the Gram matrix x of a matrix, compute the Gram matrix of its LLL reduction.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll_gram_with_transform(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll_gram_with_transform-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"Nemo.lll_gram_with_transform","text":"lll_gram_with_transform(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51, :gram))\n\nGiven the Gram matrix x of a matrix M, compute a tuple (L T) where L is the gram matrix of the LLL reduction of the matrix and T is a transformation matrix so that L = TM.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll_with_removal(::fmpz_mat, ::fmpz, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll_with_removal-Tuple{fmpz_mat, fmpz, lll_ctx}","page":"Matrices","title":"Nemo.lll_with_removal","text":"lll_with_removal(x::fmpz_mat, b::fmpz, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nCompute the LLL reduction of x and throw away rows whose norm exceeds the given bound b. Return a tuple (r L) where the first r rows of L are the rows remaining after removal.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll_with_removal_transform(::fmpz_mat, ::fmpz, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll_with_removal_transform-Tuple{fmpz_mat, fmpz, lll_ctx}","page":"Matrices","title":"Nemo.lll_with_removal_transform","text":"lll_with_removal_transform(x::fmpz_mat, b::fmpz, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nCompute a tuple (r L T) where the first r rows of L are those remaining from the LLL reduction after removal of vectors with norm exceeding the bound b and T is a transformation matrix so that L = Tx.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll!(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll!-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"Nemo.lll!","text":"lll!(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nPerform the LLL reduction of the matrix x inplace. By default the matrix x is a > mathbbZ-basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters delta = 099 and eta = 051. All of these defaults can be overridden by specifying an optional context object.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"lll_gram!(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"matrix/#Nemo.lll_gram!-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"Nemo.lll_gram!","text":"lll_gram!(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51, :gram))\n\nGiven the Gram matrix x of a matrix, compute the Gram matrix of its LLL reduction inplace.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nL = lll(A, lll_ctx(0.95, 0.55, :zbasis, :approx)\nL, T = lll_with_transform(A)\n\nG == lll_gram(gram(A))\nG, T = lll_gram_with_transform(gram(A))\n\nr, L = lll_with_removal(A, fmpz(100))\nr, L, T = lll_with_removal_transform(A, fmpz(100))","category":"page"},{"location":"matrix/#Smith-Normal-Form","page":"Matrices","title":"Smith Normal Form","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"snf(::fmpz_mat)","category":"page"},{"location":"matrix/#AbstractAlgebra.snf-Tuple{fmpz_mat}","page":"Matrices","title":"AbstractAlgebra.snf","text":"snf(x::fmpz_mat)\n\nCompute the Smith normal form of x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"snf_diagonal(::fmpz_mat)","category":"page"},{"location":"matrix/#Nemo.snf_diagonal-Tuple{fmpz_mat}","page":"Matrices","title":"Nemo.snf_diagonal","text":"snf_diagonal(x::fmpz_mat)\n\nGiven a diagonal matrix x compute the Smith normal form of x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"issnf(::fmpz_mat)","category":"page"},{"location":"matrix/#AbstractAlgebra.issnf-Tuple{fmpz_mat}","page":"Matrices","title":"AbstractAlgebra.issnf","text":"issnf(x::fmpz_mat)\n\nReturn true if x is in Smith normal form, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = snf(A)\nissnf(B) == true\n\nB = S([fmpz(2) 0 0; 0 4 0; 0 0 7])\n\nC = snf_diagonal(B)","category":"page"},{"location":"matrix/#Strong-Echelon-Form","page":"Matrices","title":"Strong Echelon Form","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"strong_echelon_form(::nmod_mat)\nstrong_echelon_form(::gfp_mat)","category":"page"},{"location":"matrix/#Nemo.strong_echelon_form-Tuple{nmod_mat}","page":"Matrices","title":"Nemo.strong_echelon_form","text":"strong_echelon_form(a::nmod_mat)\n\nReturn the strong echeleon form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"matrix/#Nemo.strong_echelon_form-Tuple{gfp_mat}","page":"Matrices","title":"Nemo.strong_echelon_form","text":"strong_echelon_form(a::gfp_mat)\n\nReturn the strong echeleon form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"R = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = strong_echelon_form(A)","category":"page"},{"location":"matrix/#Howell-Form","page":"Matrices","title":"Howell Form","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"howell_form(::nmod_mat)\nhowell_form(::gfp_mat)","category":"page"},{"location":"matrix/#Nemo.howell_form-Tuple{nmod_mat}","page":"Matrices","title":"Nemo.howell_form","text":"howell_form(a::nmod_mat)\n\nReturn the Howell normal form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"matrix/#Nemo.howell_form-Tuple{gfp_mat}","page":"Matrices","title":"Nemo.howell_form","text":"howell_form(a::gfp_mat)\n\nReturn the Howell normal form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"R = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = howell_form(A)","category":"page"},{"location":"matrix/#Gram-Schmidt-Orthogonalisation","page":"Matrices","title":"Gram-Schmidt Orthogonalisation","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"gso(::fmpq_mat)","category":"page"},{"location":"matrix/#Nemo.gso-Tuple{fmpq_mat}","page":"Matrices","title":"Nemo.gso","text":"gso(x::fmpq_mat)\n\nReturn the Gram-Schmidt Orthogonalisation of the matrix x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(QQ, 3, 3)\n\nA = S([4 7 3; 2 9 1; 0 5 3])\n\nB = gso(A)","category":"page"},{"location":"matrix/#Exponential","page":"Matrices","title":"Exponential","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Base.exp(::arb_mat)","category":"page"},{"location":"matrix/#Base.exp-Tuple{arb_mat}","page":"Matrices","title":"Base.exp","text":"exp(x::arb_mat)\n\nReturns the exponential of the matrix x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Base.exp(::acb_mat)","category":"page"},{"location":"matrix/#Base.exp-Tuple{acb_mat}","page":"Matrices","title":"Base.exp","text":"exp(x::acb_mat)\n\nReturns the exponential of the matrix x.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"A = RR[2 0 0; 0 3 0; 0 0 1]\n\nB = exp(A)","category":"page"},{"location":"matrix/#Norm","page":"Matrices","title":"Norm","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"bound_inf_norm(::arb_mat)","category":"page"},{"location":"matrix/#Nemo.bound_inf_norm-Tuple{arb_mat}","page":"Matrices","title":"Nemo.bound_inf_norm","text":"bound_inf_norm(x::arb_mat)\n\nReturns a nonnegative element z of type arb, such that z is an upper bound for the infinity norm for every matrix in x\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"bound_inf_norm(::acb_mat)","category":"page"},{"location":"matrix/#Nemo.bound_inf_norm-Tuple{acb_mat}","page":"Matrices","title":"Nemo.bound_inf_norm","text":"bound_inf_norm(x::acb_mat)\n\nReturns a nonnegative element z of type acb, such that z is an upper bound for the infinity norm for every matrix in x\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"A = RR[1 2 3; 4 5 6; 7 8 9]\n\nd = bound_inf_norm(A)","category":"page"},{"location":"matrix/#Shifting","page":"Matrices","title":"Shifting","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"ldexp(::arb_mat, ::Int)","category":"page"},{"location":"matrix/#Base.Math.ldexp-Tuple{arb_mat, Int64}","page":"Matrices","title":"Base.Math.ldexp","text":"ldexp(x::arb_mat, y::Int)\n\nReturn 2^yx. Note that y can be positive, zero or negative.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"ldexp(::acb_mat, ::Int)","category":"page"},{"location":"matrix/#Base.Math.ldexp-Tuple{acb_mat, Int64}","page":"Matrices","title":"Base.Math.ldexp","text":"ldexp(x::acb_mat, y::Int)\n\nReturn 2^yx. Note that y can be positive, zero or negative.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"A = RR[1 2 3; 4 5 6; 7 8 9]\n\nB = ldexp(A, 4)\n\noverlaps(16*A, B)","category":"page"},{"location":"matrix/#Predicates","page":"Matrices","title":"Predicates","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"isreal(::acb_mat)","category":"page"},{"location":"matrix/#Base.isreal-Tuple{acb_mat}","page":"Matrices","title":"Base.isreal","text":"isreal(x::acb_mat)\n\nReturns whether every entry of x has vanishing imaginary part.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"A = CC[1 2 3; 4 5 6; 7 8 9]\n\nisreal(A)\n\nisreal(onei(CC)*A)","category":"page"},{"location":"matrix/#Conversion-to-Julia-matrices","page":"Matrices","title":"Conversion to Julia matrices","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Julia matrices use a different data structure than Nemo matrices. Conversion to Julia matrices is usually only required for interfacing with other packages. It isn't necessary to convert Nemo matrices to Julia matrices in order to manipulate them.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"This conversion can be performed with standard Julia syntax, such as the following, where A is an fmpz_mat:","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Matrix{Int}(A)\nMatrix{BigInt}(A)","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"In case the matrix cannot be converted without loss, an InexactError is thrown: in this case, cast to a matrix of BigInts rather than Ints.","category":"page"},{"location":"matrix/#Eigenvalues-and-Eigenvectors-(experimental)","page":"Matrices","title":"Eigenvalues and Eigenvectors (experimental)","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"eigvals(::acb_mat)\neigvals_simple(a::acb_mat)","category":"page"},{"location":"matrix/#LinearAlgebra.eigvals-Tuple{acb_mat}","page":"Matrices","title":"LinearAlgebra.eigvals","text":"eigvals(A::acb_mat)\n\nReturns the eigenvalues of A as a vector of tuples (acb, Int). Each tuple (z, k) corresponds to a cluser of k eigenvalues of A.\n\nThis function is experimental.\n\n\n\n","category":"method"},{"location":"matrix/#Nemo.eigvals_simple-Tuple{acb_mat}","page":"Matrices","title":"Nemo.eigvals_simple","text":"eigvals_simple(A::acb_mat, alg = :default)\n\nReturns the eigenvalues of A as a vector of acb. It is assumed that A has only simple eigenvalues.\n\nThe algorithm used can be changed by setting the alg keyword to :vdhoeven_mourrain or :rump.\n\nThis function is experimental.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"A = CC[1 2 3; 0 4 5; 0 0 6]\neigvals_simple(A)\nA = CC[2 2 3; 0 2 5; 0 0 2])\neigvals(A)","category":"page"},{"location":"about/#About-Nemo","page":"About Nemo","title":"About Nemo","text":"","category":"section"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"Nemo is a library for fast basic arithmetic in various commonly used rings, for the Julia programming language. Our aim is to provide a highly performant package covering","category":"page"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"Commutative Algebra\nNumber Theory\nGroup Theory","category":"page"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"Nemo consists of wrappers of specialised C/C++ libraries:","category":"page"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"Flint    http://flintlib.org/\nArb      https://arblib.org/\nAntic    https://github.com/wbhart/antic/\nCalcium  https://fredrikj.net/calcium/","category":"page"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"Nemo also uses AbstractAlgebra.jl to provide generic constructions over the basic rings provided by the above packages.","category":"page"},{"location":"about/#Why-Julia?","page":"About Nemo","title":"Why Julia?","text":"","category":"section"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"Julia is a sophisticated, modern programming language which is designed to be both performant and flexible. It was written by mathematicians, for mathematicians.","category":"page"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"The benefits of Julia include","category":"page"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"Familiar imperative syntax\nJIT compilation (provides near native performance, even for highly generic code)\nREPL console (cuts down on development time)\nParametric types (allows for fast generic constructions over other data types)\nPowerful metaprogramming facilities\nOperator overloading\nMultiple dispatch (dispatch on every argument of a function)\nEfficient native C interface (little or no wrapper overhead)\nExperimental C++ interface\nDynamic type inference\nBuilt-in bignums\nAble to be embedded in C programs\nHigh performance collection types (dictionaries, iterators, arrays, etc.)\nJupyter support (for web based notebooks)","category":"page"},{"location":"about/","page":"About Nemo","title":"About Nemo","text":"The main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to model many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter speeds up the runtime performance, even of highly generic mathematical procedures.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CurrentModule = Nemo","category":"page"},{"location":"acb/#Complex-balls","page":"Complex balls","title":"Complex balls","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Arbitrary precision complex ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Complex numbers are  represented in rectangular form a+bi where ab are arb balls.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"The Arb complex field is constructed using the AcbField constructor. This constructs the parent object for the Arb complex field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"We define","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"ComplexField = AcbField","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"so that one can construct the Arb complex field parent using ComplexField instead of AcbField.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"The types of complex boxes in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Library Field Element type Parent type\nArb mathbbC (boxes) acb AcbField","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"All the complex field types belong to the Field abstract type and the types of elements in this field, i.e. complex boxes in this case, belong to the FieldElem abstract type.","category":"page"},{"location":"acb/#Complex-ball-functionality","page":"Complex balls","title":"Complex ball functionality","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"The complex balls in Nemo provide all the field functionality defined by AbstractAlgebra:.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Below, we document the additional functionality provided for complex balls.","category":"page"},{"location":"acb/#Complex-field-constructors","page":"Complex balls","title":"Complex field constructors","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"In order to construct complex boxes in Nemo, one must first construct the Arb complex field itself. This is accomplished with the following constructor.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"AcbField(prec::Int)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Return the Arb complex field with precision in bits prec used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Here is an example of creating an Arb complex field and using the resulting parent object to coerce values into the resulting field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\na = CC(\"0.25\")\nb = CC(\"0.1\")\nc = CC(0.5)\nd = CC(12)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Note that whilst one can coerce double precision floating point values into an Arb complex field, unless those values can be represented exactly in double precision the resulting ball can't be any more precise than the double precision supplied.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"If instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb complex field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"If the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function isexact below for more information.","category":"page"},{"location":"acb/#Constructors","page":"Complex balls","title":"Constructors","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"onei(::AcbField)","category":"page"},{"location":"acb/#Nemo.onei-Tuple{AcbField}","page":"Complex balls","title":"Nemo.onei","text":"onei(r::AcbField)\n\nReturn exact one times i in the given Arb complex field.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\nc = onei(CC)","category":"page"},{"location":"acb/#Basic-functionality","page":"Complex balls","title":"Basic functionality","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"The following basic functionality is provided by the default Arb complex field implementation in Nemo, to support construction of generic rings over complex fields. Any custom complex field implementation in Nemo should provide analogues of these functions along with the usual arithmetic operations.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"parent_type(::Type{acb})","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Gives the type of the parent object of an Arb complex field element.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"elem_type(R::AcbField)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Given the parent object for an Arb complex field, return the type of elements of the field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"mul!(c::acb, a::acb, b::acb)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Multiply a by b and set the existing Arb complex field element c to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"addeq!(c::acb, a::acb)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"In-place addition adds a to c and sets c to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"deepcopy(a::acb)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Return a copy of the Arb complex field element a, recursively copying the internal data. Arb complex field elements are mutable in Nemo so a shallow copy is not sufficient.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Given the parent object R for an Arb complex field, the following coercion functions are provided to coerce various elements into the Arb complex field. Developers provide these by overloading the call operator for the complex field parent objects.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"R()","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Coerce zero into the Arb complex field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"R(n::Integer)\nR(f::fmpz)\nR(q::fmpq)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Coerce an integer or rational value into the Arb complex field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"R(f::Float64)\nR(f::BigFloat)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Coerce the given floating point number into the Arb complex field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"R(f::AbstractString)\nR(f::AbstractString, g::AbstractString)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Coerce the decimal number, given as a string, into the Arb complex field. In each case f is the real part and g is the imaginary part.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"R(f::arb)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Coerce the given Arb real ball into the Arb complex field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"R(f::acb)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Take an Arb complex field element that is already in an Arb field and simply return it. A copy of the original is not made.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Here are some examples of coercing elements into the Arb complex field.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"RR = RealField(64)\nCC = ComplexField(64)\n\na = CC(3)\nb = CC(QQ(2,3))\nc = CC(\"3 +/- 0.0001\")\nd = CC(\"-1.24e+12345\")\nf = CC(\"nan +/- inf\")\ng = CC(RR(3))","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"In addition to the above, developers of custom complex field types must ensure that they provide the equivalent of the function base_ring(R::AcbField) which should return Union{}. In addition to this they should ensure that each complex field element contains a field parent specifying the parent object of the complex field element, or at least supply the equivalent of the function parent(a::acb) to return the parent object of a complex field element.","category":"page"},{"location":"acb/#Basic-manipulation","page":"Complex balls","title":"Basic manipulation","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"isfinite(::acb)","category":"page"},{"location":"acb/#Base.isfinite-Tuple{acb}","page":"Complex balls","title":"Base.isfinite","text":"isfinite(x::acb)\n\nReturn true if x is finite, i.e. its real and imaginary parts have finite midpoint and radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"isexact(::acb)","category":"page"},{"location":"acb/#Nemo.isexact-Tuple{acb}","page":"Complex balls","title":"Nemo.isexact","text":"isexact(x::acb)\n\nReturn true if x is exact, i.e. has its real and imaginary parts have zero radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"isint(::acb)","category":"page"},{"location":"acb/#Nemo.isint-Tuple{acb}","page":"Complex balls","title":"Nemo.isint","text":"isint(x::acb)\n\nReturn true if x is an exact integer, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"isreal(::acb)","category":"page"},{"location":"acb/#Base.isreal-Tuple{acb}","page":"Complex balls","title":"Base.isreal","text":"isreal(x::acb)\n\nReturn true if x is purely real, i.e. having zero imaginary part, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"real(::acb)","category":"page"},{"location":"acb/#Base.real-Tuple{acb}","page":"Complex balls","title":"Base.real","text":"real(x::acb)\n\nReturn the real part of x as an arb.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"imag(::acb)","category":"page"},{"location":"acb/#Base.imag-Tuple{acb}","page":"Complex balls","title":"Base.imag","text":"imag(x::acb)\n\nReturn the imaginary part of x as an arb.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"accuracy_bits(::acb)","category":"page"},{"location":"acb/#Nemo.accuracy_bits-Tuple{acb}","page":"Complex balls","title":"Nemo.accuracy_bits","text":"accuracy_bits(x::acb)\n\nReturn the relative accuracy of x measured in bits, capped between typemax(Int) and -typemax(Int).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\na = CC(\"1.2 +/- 0.001\")\nb = CC(3)\n\nisreal(a)\nisfinite(b)\nisint(b)\nc = real(a)\nd = imag(b)\nf = accuracy_bits(a)","category":"page"},{"location":"acb/#Containment","page":"Complex balls","title":"Containment","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"It is often necessary to determine whether a given exact value or box is contained in a given complex box or whether two boxes overlap. The following functions are provided for this purpose.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"overlaps(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.overlaps-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.overlaps","text":"overlaps(x::acb, y::acb)\n\nReturns true if any part of the box x overlaps any part of the box y, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"contains(::acb, ::acb)","category":"page"},{"location":"acb/#Base.contains-Tuple{acb, acb}","page":"Complex balls","title":"Base.contains","text":"contains(x::acb, y::acb)\n\nReturns true if the box x contains the box y, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"contains(::acb, ::Integer)\ncontains(::acb, ::fmpz)\ncontains(::acb, ::fmpq)","category":"page"},{"location":"acb/#Base.contains-Tuple{acb, Integer}","page":"Complex balls","title":"Base.contains","text":"contains(x::acb, y::Integer)\n\nReturns true if the box x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/#Base.contains-Tuple{acb, fmpz}","page":"Complex balls","title":"Base.contains","text":"contains(x::acb, y::fmpz)\n\nReturns true if the box x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/#Base.contains-Tuple{acb, fmpq}","page":"Complex balls","title":"Base.contains","text":"contains(x::acb, y::fmpq)\n\nReturns true if the box x contains the given rational value, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"The following functions are also provided for determining if a box intersects a certain part of the complex number plane.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"contains_zero(::acb)","category":"page"},{"location":"acb/#Nemo.contains_zero-Tuple{acb}","page":"Complex balls","title":"Nemo.contains_zero","text":"contains_zero(x::acb)\n\nReturns true if the box x contains zero, otherwise return false.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"1 +/- 0.001\")\ny = CC(\"3\")\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)","category":"page"},{"location":"acb/#Comparison","page":"Complex balls","title":"Comparison","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Nemo provides a full range of comparison operations for Arb complex boxes. ","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"In addition to the standard comparisons, we introduce an exact equality. This is distinct from arithmetic equality implemented by ==, which merely compares up to the minimum of the precisions of its operands.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"isequal(::acb, ::acb)","category":"page"},{"location":"acb/#Base.isequal-Tuple{acb, acb}","page":"Complex balls","title":"Base.isequal","text":"isequal(x::acb, y::acb)\n\nReturn true if the boxes x and y are precisely equal, i.e. their real and imaginary parts have the same midpoints and radii.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"A full range of ad hoc comparison operators is provided. These are implemented directly in Julia, but we document them as though only == were provided.","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Function\n==(x::acb, y::Integer)\n==(x::Integer, y::acb)\n==(x::acb, y::fmpz)\n==(x::fmpz, y::acb)\n==(x::arb, y::fmpz)\n==(x::fmpz, y::arb)\n==(x::acb, y::Float64)\n==(x::Float64, y::acb)","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"1 +/- 0.001\")\ny = CC(\"3\")\nz = CC(\"4\")\n\nisequal(x, deepcopy(x))\nx == 3\nZZ(3) == z\nx != 1.23","category":"page"},{"location":"acb/#Absolute-value","page":"Complex balls","title":"Absolute value","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"abs(::acb)","category":"page"},{"location":"acb/#Base.abs-Tuple{acb}","page":"Complex balls","title":"Base.abs","text":"abs(x::acb)\n\nReturn the complex absolute value of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"-1 +/- 0.001\")\n\na = abs(x)","category":"page"},{"location":"acb/#Shifting","page":"Complex balls","title":"Shifting","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"ldexp(x::acb, y::Int)\nldexp(x::acb, y::fmpz)","category":"page"},{"location":"acb/#Base.Math.ldexp-Tuple{acb, Int64}","page":"Complex balls","title":"Base.Math.ldexp","text":"ldexp(x::acb, y::Int)\n\nReturn 2^yx. Note that y can be positive, zero or negative.\n\n\n\n","category":"method"},{"location":"acb/#Base.Math.ldexp-Tuple{acb, fmpz}","page":"Complex balls","title":"Base.Math.ldexp","text":"ldexp(x::acb, y::fmpz)\n\nReturn 2^yx. Note that y can be positive, zero or negative.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"-3 +/- 0.001\")\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))","category":"page"},{"location":"acb/#Miscellaneous-operations","page":"Complex balls","title":"Miscellaneous operations","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"trim(::acb)","category":"page"},{"location":"acb/#Nemo.trim-Tuple{acb}","page":"Complex balls","title":"Nemo.trim","text":"trim(x::acb)\n\nReturn an acb box containing x but which may be more economical, by rounding off insignificant bits from midpoints.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"unique_integer(::acb)","category":"page"},{"location":"acb/#Nemo.unique_integer-Tuple{acb}","page":"Complex balls","title":"Nemo.unique_integer","text":"unique_integer(x::acb)\n\nReturn a pair where the first value is a boolean and the second is an fmpz integer. The boolean indicates whether the box x contains a unique integer. If this is the case, the second return value is set to this unique integer.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"conj(::acb)","category":"page"},{"location":"acb/#Base.conj-Tuple{acb}","page":"Complex balls","title":"Base.conj","text":"conj(x::acb)\n\nReturn the complex conjugate of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"angle(::acb)","category":"page"},{"location":"acb/#Base.angle-Tuple{acb}","page":"Complex balls","title":"Base.angle","text":"angle(x::acb)\n\nReturn complex argument of x, the angle in radians that the complex vector x makes with the positive real axis in a counterclockwise direction. It has a discontinuity on the non-positive real axis, with the special values arg(0) = 0 and arg(a + 0 i) = pi for a  0.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"-3 +/- 0.001\", \"0.1\")\n\na = trim(x)\nb, c = unique_integer(x)\nd = conj(x)\nf = angle(x)","category":"page"},{"location":"acb/#Constants","page":"Complex balls","title":"Constants","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"const_pi(::AcbField)","category":"page"},{"location":"acb/#Nemo.const_pi-Tuple{AcbField}","page":"Complex balls","title":"Nemo.const_pi","text":"const_pi(r::AcbField)\n\nReturn pi = 314159ldots as an element of r.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(200)\n\na = const_pi(CC)","category":"page"},{"location":"acb/#Mathematical-and-special-functions","page":"Complex balls","title":"Mathematical and special functions","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Base.sqrt(::acb)","category":"page"},{"location":"acb/#Base.sqrt-Tuple{acb}","page":"Complex balls","title":"Base.sqrt","text":"Base.sqrt(x::acb; check::Bool=true)\n\nReturn the square root of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"rsqrt(::acb)","category":"page"},{"location":"acb/#Nemo.rsqrt-Tuple{acb}","page":"Complex balls","title":"Nemo.rsqrt","text":"rsqrt(x::acb)\n\nReturn the reciprocal of the square root of x, i.e. 1sqrtx.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"log(::acb)","category":"page"},{"location":"acb/#Base.log-Tuple{acb}","page":"Complex balls","title":"Base.log","text":"log(x::acb)\n\nReturn the principal branch of the logarithm of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"log1p(::acb)","category":"page"},{"location":"acb/#Base.log1p-Tuple{acb}","page":"Complex balls","title":"Base.log1p","text":"log1p(x::acb)\n\nReturn log(1+x), evaluated accurately for small x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Base.exp(::acb)","category":"page"},{"location":"acb/#Base.exp-Tuple{acb}","page":"Complex balls","title":"Base.exp","text":"exp(x::acb)\n\nReturn the exponential of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"expm1(::acb)","category":"page"},{"location":"acb/#Base.expm1-Tuple{acb}","page":"Complex balls","title":"Base.expm1","text":"expm1(x::acb)\n\nReturn exp(x)-1, using a more accurate method when x approx 0.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"exppii(::acb)","category":"page"},{"location":"acb/#Nemo.exppii-Tuple{acb}","page":"Complex balls","title":"Nemo.exppii","text":"exppii(x::acb)\n\nReturn the exponential of pi i x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"root_of_unity(::AcbField, k::Int)","category":"page"},{"location":"acb/#Nemo.root_of_unity-Tuple{AcbField, Int64}","page":"Complex balls","title":"Nemo.root_of_unity","text":"root_of_unity(C::AcbField, k::Int)\n\nReturn exp(2pi ik).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sin(::acb)","category":"page"},{"location":"acb/#Base.sin-Tuple{acb}","page":"Complex balls","title":"Base.sin","text":"sin(x::acb)\n\nReturn the sine of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"cos(::acb)","category":"page"},{"location":"acb/#Base.cos-Tuple{acb}","page":"Complex balls","title":"Base.cos","text":"cos(x::acb)\n\nReturn the cosine of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sinpi(::acb)","category":"page"},{"location":"acb/#Base.Math.sinpi-Tuple{acb}","page":"Complex balls","title":"Base.Math.sinpi","text":"sinpi(x::acb)\n\nReturn the sine of pi x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"cospi(::acb)","category":"page"},{"location":"acb/#Base.Math.cospi-Tuple{acb}","page":"Complex balls","title":"Base.Math.cospi","text":"cospi(x::acb)\n\nReturn the cosine of pi x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"tan(::acb)","category":"page"},{"location":"acb/#Base.tan-Tuple{acb}","page":"Complex balls","title":"Base.tan","text":"tan(x::acb)\n\nReturn the tangent of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"cot(::acb)","category":"page"},{"location":"acb/#Base.Math.cot-Tuple{acb}","page":"Complex balls","title":"Base.Math.cot","text":"cot(x::acb)\n\nReturn the cotangent of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"tanpi(::acb)","category":"page"},{"location":"acb/#Nemo.tanpi-Tuple{acb}","page":"Complex balls","title":"Nemo.tanpi","text":"tanpi(x::acb)\n\nReturn the tangent of pi x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"cotpi(::acb)","category":"page"},{"location":"acb/#Nemo.cotpi-Tuple{acb}","page":"Complex balls","title":"Nemo.cotpi","text":"cotpi(x::acb)\n\nReturn the cotangent of pi x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sinh(::acb)","category":"page"},{"location":"acb/#Base.sinh-Tuple{acb}","page":"Complex balls","title":"Base.sinh","text":"sinh(x::acb)\n\nReturn the hyperbolic sine of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"cosh(::acb)","category":"page"},{"location":"acb/#Base.cosh-Tuple{acb}","page":"Complex balls","title":"Base.cosh","text":"cosh(x::acb)\n\nReturn the hyperbolic cosine of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"tanh(::acb)","category":"page"},{"location":"acb/#Base.tanh-Tuple{acb}","page":"Complex balls","title":"Base.tanh","text":"tanh(x::acb)\n\nReturn the hyperbolic tangent of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"coth(::acb)","category":"page"},{"location":"acb/#Base.Math.coth-Tuple{acb}","page":"Complex balls","title":"Base.Math.coth","text":"coth(x::acb)\n\nReturn the hyperbolic cotangent of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"atan(::acb)","category":"page"},{"location":"acb/#Base.atan-Tuple{acb}","page":"Complex balls","title":"Base.atan","text":"atan(x::acb)\n\nReturn the arctangent of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"log_sinpi(::acb)","category":"page"},{"location":"acb/#Nemo.log_sinpi-Tuple{acb}","page":"Complex balls","title":"Nemo.log_sinpi","text":"log_sinpi(x::acb)\n\nReturn logsin(pi x), constructed without branch cuts off the real line.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"gamma(::acb)","category":"page"},{"location":"acb/#Nemo.gamma-Tuple{acb}","page":"Complex balls","title":"Nemo.gamma","text":"gamma(x::acb)\n\nReturn the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"lgamma(::acb)","category":"page"},{"location":"acb/#Nemo.lgamma-Tuple{acb}","page":"Complex balls","title":"Nemo.lgamma","text":"lgamma(x::acb)\n\nReturn the logarithm of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"rgamma(::acb)","category":"page"},{"location":"acb/#Nemo.rgamma-Tuple{acb}","page":"Complex balls","title":"Nemo.rgamma","text":"rgamma(x::acb)\n\nReturn the reciprocal of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"digamma(::acb)","category":"page"},{"location":"acb/#Nemo.digamma-Tuple{acb}","page":"Complex balls","title":"Nemo.digamma","text":"digamma(x::acb)\n\nReturn the  logarithmic derivative of the gamma function evaluated at x, i.e. psi(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"zeta(::acb)","category":"page"},{"location":"acb/#Nemo.zeta-Tuple{acb}","page":"Complex balls","title":"Nemo.zeta","text":"zeta(x::acb)\n\nReturn the Riemann zeta function evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"barnes_g(::acb)","category":"page"},{"location":"acb/#Nemo.barnes_g-Tuple{acb}","page":"Complex balls","title":"Nemo.barnes_g","text":"barnes_g(x::acb)\n\nReturn the Barnes G-function, evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"log_barnes_g(::acb)","category":"page"},{"location":"acb/#Nemo.log_barnes_g-Tuple{acb}","page":"Complex balls","title":"Nemo.log_barnes_g","text":"log_barnes_g(x::acb)\n\nReturn the logarithm of the Barnes G-function, evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"erf(::acb)","category":"page"},{"location":"acb/#Nemo.erf-Tuple{acb}","page":"Complex balls","title":"Nemo.erf","text":"erf(x::acb)\n\nReturn the error function evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"erfi(::acb)","category":"page"},{"location":"acb/#Nemo.erfi-Tuple{acb}","page":"Complex balls","title":"Nemo.erfi","text":"erfi(x::acb)\n\nReturn the imaginary error function evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"exp_integral_ei(::acb)","category":"page"},{"location":"acb/#Nemo.exp_integral_ei-Tuple{acb}","page":"Complex balls","title":"Nemo.exp_integral_ei","text":"exp_integral_ei(x::acb)\n\nReturn the exponential integral evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sin_integral(::acb)","category":"page"},{"location":"acb/#Nemo.sin_integral-Tuple{acb}","page":"Complex balls","title":"Nemo.sin_integral","text":"sin_integral(x::acb)\n\nReturn the sine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"cos_integral(::acb)","category":"page"},{"location":"acb/#Nemo.cos_integral-Tuple{acb}","page":"Complex balls","title":"Nemo.cos_integral","text":"cos_integral(x::acb)\n\nReturn the exponential cosine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sinh_integral(::acb)","category":"page"},{"location":"acb/#Nemo.sinh_integral-Tuple{acb}","page":"Complex balls","title":"Nemo.sinh_integral","text":"sinh_integral(x::acb)\n\nReturn the hyperbolic sine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"cosh_integral(::acb)","category":"page"},{"location":"acb/#Nemo.cosh_integral-Tuple{acb}","page":"Complex balls","title":"Nemo.cosh_integral","text":"cosh_integral(x::acb)\n\nReturn the hyperbolic cosine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"dedekind_eta(::acb)","category":"page"},{"location":"acb/#Nemo.dedekind_eta-Tuple{acb}","page":"Complex balls","title":"Nemo.dedekind_eta","text":"dedekind_eta(x::acb)\n\nReturn the Dedekind eta function eta(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"modular_weber_f(::acb)","category":"page"},{"location":"acb/#Nemo.modular_weber_f-Tuple{acb}","page":"Complex balls","title":"Nemo.modular_weber_f","text":"modular_weber_f(x::acb)\n\nReturn the modular Weber function mathfrakf(tau) = fraceta^2(tau)eta(tau2)eta(2tau) at x in the complex upper half plane.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"modular_weber_f1(::acb)","category":"page"},{"location":"acb/#Nemo.modular_weber_f1-Tuple{acb}","page":"Complex balls","title":"Nemo.modular_weber_f1","text":"modular_weber_f1(x::acb)\n\nReturn the modular Weber function mathfrakf_1(tau) = fraceta(tau2)eta(tau) at x in the complex upper half plane.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"modular_weber_f2(::acb)","category":"page"},{"location":"acb/#Nemo.modular_weber_f2-Tuple{acb}","page":"Complex balls","title":"Nemo.modular_weber_f2","text":"modular_weber_f2(x::acb)\n\nReturn the modular Weber function mathfrakf_2(tau) = fracsqrt2eta(2tau)eta(tau) at x in the complex upper half plane.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"j_invariant(::acb)","category":"page"},{"location":"acb/#Nemo.j_invariant-Tuple{acb}","page":"Complex balls","title":"Nemo.j_invariant","text":"j_invariant(x::acb)\n\nReturn the j-invariant j(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"modular_lambda(::acb)","category":"page"},{"location":"acb/#Nemo.modular_lambda-Tuple{acb}","page":"Complex balls","title":"Nemo.modular_lambda","text":"modular_lambda(x::acb)\n\nReturn the modular lambda function lambda(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"modular_delta(::acb)","category":"page"},{"location":"acb/#Nemo.modular_delta-Tuple{acb}","page":"Complex balls","title":"Nemo.modular_delta","text":"modular_delta(x::acb)\n\nReturn the modular delta function Delta(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"eisenstein_g(::Int, ::acb)","category":"page"},{"location":"acb/#Nemo.eisenstein_g-Tuple{Int64, acb}","page":"Complex balls","title":"Nemo.eisenstein_g","text":"eisenstein_g(k::Int, x::acb)\n\nReturn the non-normalized Eisenstein series G_k(tau) of mathrmSL_2(mathbbZ). Also defined for tau = i infty.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"hilbert_class_polynomial(::Int, ::FmpzPolyRing)","category":"page"},{"location":"acb/#Nemo.hilbert_class_polynomial-Tuple{Int64, FmpzPolyRing}","page":"Complex balls","title":"Nemo.hilbert_class_polynomial","text":"hilbert_class_polynomial(D::Int, R::FmpzPolyRing)\n\nReturn in the ring R the Hilbert class polynomial of discriminant D, which is only defined for D  0 and D equiv 0 1 pmod 4.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"elliptic_k(::acb)","category":"page"},{"location":"acb/#Nemo.elliptic_k-Tuple{acb}","page":"Complex balls","title":"Nemo.elliptic_k","text":"elliptic_k(x::acb)\n\nReturn the complete elliptic integral K(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"elliptic_e(::acb)","category":"page"},{"location":"acb/#Nemo.elliptic_e-Tuple{acb}","page":"Complex balls","title":"Nemo.elliptic_e","text":"elliptic_e(x::acb)\n\nReturn the complete elliptic integral E(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sincos(::acb)","category":"page"},{"location":"acb/#Base.Math.sincos-Tuple{acb}","page":"Complex balls","title":"Base.Math.sincos","text":"sincos(x::acb)\n\nReturn a tuple s c consisting of the sine s and cosine c of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sincospi(::acb)","category":"page"},{"location":"acb/#Base.Math.sincospi-Tuple{acb}","page":"Complex balls","title":"Base.Math.sincospi","text":"sincospi(x::acb)\n\nReturn a tuple s c consisting of the sine s and cosine c of pi x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"sinhcosh(::acb)","category":"page"},{"location":"acb/#Nemo.sinhcosh-Tuple{acb}","page":"Complex balls","title":"Nemo.sinhcosh","text":"sinhcosh(x::acb)\n\nReturn a tuple s c consisting of the hyperbolic sine and cosine of x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"agm(::acb)\nagm(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.agm-Tuple{acb}","page":"Complex balls","title":"Nemo.agm","text":"agm(x::acb)\n\nReturn the arithmetic-geometric mean of 1 and x.\n\n\n\n","category":"method"},{"location":"acb/#Nemo.agm-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.agm","text":"agm(x::acb, y::acb)\n\nReturn the arithmetic-geometric mean of x and y.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"polygamma(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.polygamma-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.polygamma","text":"polygamma(s::acb, a::acb)\n\nReturn the generalised polygamma function psi(sz).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"zeta(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.zeta-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.zeta","text":"zeta(s::acb, a::acb)\n\nReturn the Hurwitz zeta function zeta(sa).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"rising_factorial(::acb, ::Int)","category":"page"},{"location":"acb/#Nemo.rising_factorial-Tuple{acb, Int64}","page":"Complex balls","title":"Nemo.rising_factorial","text":"rising_factorial(x::acb, n::Int)\n\nReturn the rising factorial x(x + 1)ldots (x + n - 1) as an Acb.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"rising_factorial2(::acb, ::Int)","category":"page"},{"location":"acb/#Nemo.rising_factorial2-Tuple{acb, Int64}","page":"Complex balls","title":"Nemo.rising_factorial2","text":"rising_factorial2(x::acb, n::Int)\n\nReturn a tuple containing the rising factorial x(x + 1)ldots (x + n - 1) and its derivative.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"polylog(::Union{acb,Int}, ::acb)","category":"page"},{"location":"acb/#Nemo.polylog-Tuple{Union{Int64, acb}, acb}","page":"Complex balls","title":"Nemo.polylog","text":"polylog(s::Union{acb,Int}, a::acb)\n\nReturn the polylogarithm Li_s(a).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"log_integral(::acb)","category":"page"},{"location":"acb/#Nemo.log_integral-Tuple{acb}","page":"Complex balls","title":"Nemo.log_integral","text":"log_integral(x::acb)\n\nReturn the logarithmic integral, evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"log_integral_offset(::acb)","category":"page"},{"location":"acb/#Nemo.log_integral_offset-Tuple{acb}","page":"Complex balls","title":"Nemo.log_integral_offset","text":"log_integral_offset(x::acb)\n\nReturn the offset logarithmic integral, evaluated at x.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"exp_integral_e(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.exp_integral_e-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.exp_integral_e","text":"exp_integral_e(s::acb, x::acb)\n\nReturn the generalised exponential integral E_s(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"gamma(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.gamma-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.gamma","text":"gamma(s::acb, x::acb)\n\nReturn the upper incomplete gamma function Gamma(sx).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"gamma_regularized(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.gamma_regularized-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.gamma_regularized","text":"gamma_regularized(s::acb, x::acb)\n\nReturn the regularized upper incomplete gamma function Gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"gamma_lower(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.gamma_lower-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.gamma_lower","text":"gamma_lower(s::acb, x::acb)\n\nReturn the lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"gamma_lower_regularized(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.gamma_lower_regularized-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.gamma_lower_regularized","text":"gamma_lower_regularized(s::acb, x::acb)\n\nReturn the regularized lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"airy_ai(::acb)","category":"page"},{"location":"acb/#Nemo.airy_ai-Tuple{acb}","page":"Complex balls","title":"Nemo.airy_ai","text":"airy_ai(x::acb)\n\nReturn the Airy function operatornameAi(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"airy_ai_prime(::acb)","category":"page"},{"location":"acb/#Nemo.airy_ai_prime-Tuple{acb}","page":"Complex balls","title":"Nemo.airy_ai_prime","text":"airy_ai_prime(x::acb)\n\nReturn the derivative of the Airy function operatornameAi^prime(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"airy_bi(::acb)","category":"page"},{"location":"acb/#Nemo.airy_bi-Tuple{acb}","page":"Complex balls","title":"Nemo.airy_bi","text":"airy_bi(x::acb)\n\nReturn the Airy function operatornameBi(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"airy_bi_prime(::acb)","category":"page"},{"location":"acb/#Nemo.airy_bi_prime-Tuple{acb}","page":"Complex balls","title":"Nemo.airy_bi_prime","text":"airy_bi_prime(x::acb)\n\nReturn the derivative of the Airy function operatornameBi^prime(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"bessel_j(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.bessel_j-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.bessel_j","text":"bessel_j(nu::acb, x::acb)\n\nReturn the Bessel function J_nu(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"bessel_y(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.bessel_y-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.bessel_y","text":"bessel_y(nu::acb, x::acb)\n\nReturn the Bessel function Y_nu(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"bessel_i(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.bessel_i-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.bessel_i","text":"bessel_i(nu::acb, x::acb)\n\nReturn the Bessel function I_nu(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"bessel_k(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.bessel_k-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.bessel_k","text":"bessel_k(nu::acb, x::acb)\n\nReturn the Bessel function K_nu(x).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_1f1(::acb, ::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.hypergeometric_1f1-Tuple{acb, acb, acb}","page":"Complex balls","title":"Nemo.hypergeometric_1f1","text":"hypergeometric_1f1(a::acb, b::acb, x::acb)\n\nReturn the confluent hypergeometric function _1F_1(abx).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_1f1_regularized(::acb, ::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.hypergeometric_1f1_regularized-Tuple{acb, acb, acb}","page":"Complex balls","title":"Nemo.hypergeometric_1f1_regularized","text":"hypergeometric_1f1_regularized(a::acb, b::acb, x::acb)\n\nReturn the regularized confluent hypergeometric function _1F_1(abx)  Gamma(b).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_u(::acb, ::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.hypergeometric_u-Tuple{acb, acb, acb}","page":"Complex balls","title":"Nemo.hypergeometric_u","text":"hypergeometric_u(a::acb, b::acb, x::acb)\n\nReturn the confluent hypergeometric function U(abx).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_2f1(::acb, ::acb, ::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.hypergeometric_2f1-NTuple{4, acb}","page":"Complex balls","title":"Nemo.hypergeometric_2f1","text":"hypergeometric_2f1(a::acb, b::acb, c::acb, x::acb; flags=0)\n\nReturn the Gauss hypergeometric function _2F_1(abcx).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"jacobi_theta(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.jacobi_theta-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.jacobi_theta","text":"jacobi_theta(z::acb, tau::acb)\n\nReturn a tuple of four elements containing the Jacobi theta function values theta_1 theta_2 theta_3 theta_4 evaluated at z tau.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"weierstrass_p(::acb, ::acb)","category":"page"},{"location":"acb/#Nemo.weierstrass_p-Tuple{acb, acb}","page":"Complex balls","title":"Nemo.weierstrass_p","text":"weierstrass_p(z::acb, tau::acb)\n\nReturn the Weierstrass elliptic function wp(ztau).\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\ns = CC(1, 2)\nz = CC(\"1.23\", \"3.45\")\n\na = sin(z)^2 + cos(z)^2\nb = zeta(z)\nc = bessel_j(s, z)\nd = hypergeometric_1f1(s, s+1, z)","category":"page"},{"location":"acb/#Linear-dependence","page":"Complex balls","title":"Linear dependence","text":"","category":"section"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"lindep(::Vector{acb}, n::Int)","category":"page"},{"location":"acb/#Nemo.lindep-Tuple{Vector{acb}, Int64}","page":"Complex balls","title":"Nemo.lindep","text":"lindep(A::Vector{acb}, bits::Int)\n\nFind a small linear combination of the entries of the array A that is small (using LLL). The entries are first scaled by the given number of bits before truncating the real and imaginary parts to integers for use in LLL. This function can be used to find linear dependence between a list of complex numbers. The algorithm is heuristic only and returns an array of Nemo integers representing the linear combination.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"lindep(A::Matrix{acb}, bits::Int)","category":"page"},{"location":"acb/#Nemo.lindep-Tuple{Matrix{acb}, Int64}","page":"Complex balls","title":"Nemo.lindep","text":"lindep(A::Matrix{acb}, bits::Int)\n\nFind a (common) small linear combination of the entries in each row of the array A, that is small (using LLL). It is assumed that the complex numbers in each row of the array share the same linear combination. The entries are first scaled by the given number of bits before truncating the real and imaginary parts to integers for use in LLL. This function can be used to find a common linear dependence shared across a number of lists of complex numbers. The algorithm is heuristic only and returns an array of Nemo integers representing the common linear combination.\n\n\n\n","category":"method"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(128)\n\n# These are two of the roots of x^5 + 3x + 1\na = CC(1.0050669478588622428791051888364775253, - 0.93725915669289182697903585868761513585)\nb = CC(-0.33198902958450931620250069492231652319)\n\n# We recover the polynomial from one root....\nV1 = [CC(1), a, a^2, a^3, a^4, a^5];\nW = lindep(V1, 20)\n\n# ...or from two\nV2 = [CC(1), b, b^2, b^3, b^4, b^5];\nVs = [V1 V2]\nX = lindep(Vs, 20)","category":"page"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Global-variables-and-precompilation","page":"Miscellaneous","title":"Global variables and precompilation","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Due to limitations of the precompilation of modules in julia, global variables referring to certain Nemo types require special attention when used inside modules. As a simple example, the following code for a module called A will not work as expected:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"module A\n\nusing Nemo\nQx, x = QQ[\"x\"]\nf(n) = x^n\nend","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"When running julia and loading the module via using/import A, calling f will lead to segmentation faults. The preferred workaround is to put the definitions of the global variables into the __init__() function of the module as follows:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"module A\n\nusing Nemo\n\nfunction __init__()\n  global (Qx, x) = QQ[\"x\"]\nend\n\nf(n) = x^n\nend","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Alternatively, one can disable precompilation by adding __precompile__(false) inside A. Note that this might have other unwanted side effects.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"CurrentModule = Nemo","category":"page"},{"location":"qadic/#Qadics","page":"Qadics","title":"Qadics","text":"","category":"section"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields, that is, unramified extensions of p-adic fields, are provided in Nemo by Flint. This allows construction of q-adic fields for any prime power q.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields are constructed using the FlintQadicField function. However, for convenience we define","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"QadicField = FlintQadicField","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"so that q-adic fields can be constructed using QadicField rather than FlintQadicField. Note that this is the name of the constructor, but not of qadic field type.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"The types of q-adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Library Field Element type Parent type\nFlint mathbbQ_q qadic QadicField","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"All the q-adic field types belong to the Field abstract type and the q-adic field element types belong to the FieldElem abstract type.","category":"page"},{"location":"qadic/#P-adic-functionality","page":"Qadics","title":"P-adic functionality","text":"","category":"section"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields in Nemo provide all the functionality described in AbstractAlgebra for fields:.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Below, we document all the additional function that is provide by Nemo for q-adic fields.","category":"page"},{"location":"qadic/#Constructors","page":"Qadics","title":"Constructors","text":"","category":"section"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"In order to construct q-adic field elements in Nemo, one must first construct the q-adic field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"FlintQadicField(::Integer, ::Int, ::Int)","category":"page"},{"location":"qadic/#Nemo.FlintQadicField-Tuple{Integer, Int64, Int64}","page":"Qadics","title":"Nemo.FlintQadicField","text":"FlintQadicField(p::Integer, d::Int, prec::Int, var::String = \"a\")\n\nReturns the parent object for the q-adic field for given prime p and degree d, where the default absolute precision of elements of the field is given by prec and the generator is printed as var.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"It is also possible to call the inner constructor directly. It has the following form.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"FlintQadicField(p::fmpz, d::Int, prec::Int)","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Returns the parent object for the q-adic field for given prime p and degree d, where the default absolute precision of elements of the field is given by prec. It also return the uniformizer p with the default precision.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Here are some examples of creating q-adic fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"R, p = QadicField(7, 1, 30)\nS, _ = QadicField(ZZ(65537), 1, 30)\n\na = R()\nb = S(1)\nc = S(ZZ(123))\nd = R(ZZ(1)//7^2)","category":"page"},{"location":"qadic/#Big-oh-notation","page":"Qadics","title":"Big-oh notation","text":"","category":"section"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Elements of p-adic fields can  be constructed using the big-oh notation. For this purpose we define the following functions.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"O(::FlintQadicField, ::Integer)\nO(::FlintQadicField, ::fmpz)\nO(::FlintQadicField, ::fmpq)","category":"page"},{"location":"qadic/#AbstractAlgebra.O-Tuple{FlintQadicField, Integer}","page":"Qadics","title":"AbstractAlgebra.O","text":"O(R::FlintQadicField, m::Integer)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"qadic/#AbstractAlgebra.O-Tuple{FlintQadicField, fmpz}","page":"Qadics","title":"AbstractAlgebra.O","text":"O(R::FlintQadicField, m::fmpz)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"qadic/#AbstractAlgebra.O-Tuple{FlintQadicField, fmpq}","page":"Qadics","title":"AbstractAlgebra.O","text":"O(R::FlintQadicField, m::fmpq)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"The O(p^n) construction can be used to construct q-adic values of precision n by adding it to integer values representing the q-adic value modulo p^n as in the examples.","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 30)\nS, _ = QadicField(ZZ(65537), 30)\n\nc = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nd = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\nf = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Beware that the expression 1 + 2*p + 3*p^2 + O(R, p^n) is actually computed as a normal Julia expression. Therefore if {Int} values are used instead of Flint integers or Julia bignums, overflow may result in evaluating the value.","category":"page"},{"location":"qadic/#Basic-manipulation","page":"Qadics","title":"Basic manipulation","text":"","category":"section"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"prime(::FlintQadicField)","category":"page"},{"location":"qadic/#AbstractAlgebra.Generic.prime-Tuple{FlintQadicField}","page":"Qadics","title":"AbstractAlgebra.Generic.prime","text":"prime(R::FlintQadicField)\n\nReturn the prime p for the given q-adic field.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"precision(::qadic)","category":"page"},{"location":"qadic/#Base.precision-Tuple{qadic}","page":"Qadics","title":"Base.precision","text":"precision(a::qadic)\n\nReturn the precision of the given q-adic field element, i.e. if the element is known to O(p^n) this function will return n.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"valuation(::qadic)","category":"page"},{"location":"qadic/#AbstractAlgebra.valuation-Tuple{qadic}","page":"Qadics","title":"AbstractAlgebra.valuation","text":"valuation(a::qadic)\n\nReturn the valuation of the given q-adic field element, i.e. if the given element is divisible by p^n but not a higher power of q then the function will return n.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"lift(::FmpqPolyRing, ::qadic)\nlift(::FmpzPolyRing, ::qadic)","category":"page"},{"location":"qadic/#AbstractAlgebra.lift-Tuple{FmpqPolyRing, qadic}","page":"Qadics","title":"AbstractAlgebra.lift","text":"lift(R::FmpqPolyRing, a::qadic)\n\nReturn a lift of the given q-adic field element to mathbbQx.\n\n\n\n","category":"method"},{"location":"qadic/#AbstractAlgebra.lift-Tuple{FmpzPolyRing, qadic}","page":"Qadics","title":"AbstractAlgebra.lift","text":"lift(R::FmpzPolyRing, a::qadic)\n\nReturn a lift of the given q-adic field element to mathbbZx if possible.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 1, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = R(2)\n\nk = precision(a)\nm = prime(R)\nn = valuation(b)\nQx, x = FlintQQ[\"x\"]\np = lift(Qx, a)\nZy, y = FlintZZ[\"y\"]\nq = lift(Zy, divexact(a, b))","category":"page"},{"location":"qadic/#Square-root","page":"Qadics","title":"Square root","text":"","category":"section"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Base.sqrt(::qadic)","category":"page"},{"location":"qadic/#Base.sqrt-Tuple{qadic}","page":"Qadics","title":"Base.sqrt","text":"sqrt(a::qadic; check::Bool=true)\n\nReturn the q-adic square root of a. We define this only when the valuation of a is even. The precision of the output will be precision(a) - valuation(a)2. If the square root does not exist, an exception is thrown.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 1, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\n\nd = sqrt(a)\nf = sqrt(b)\nf = sqrt(c)\ng = sqrt(R(121))","category":"page"},{"location":"qadic/#Special-functions","page":"Qadics","title":"Special functions","text":"","category":"section"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Base.exp(::qadic)","category":"page"},{"location":"qadic/#Base.exp-Tuple{qadic}","page":"Qadics","title":"Base.exp","text":"exp(a::qadic)\n\nReturn the q-adic exponential of a. We define this only when the valuation of a is positive (unless a = 0). The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"log(::qadic)","category":"page"},{"location":"qadic/#Base.log-Tuple{qadic}","page":"Qadics","title":"Base.log","text":"log(a::qadic)\n\nReturn the q-adic logarithm of a. We define this only when the valuation of a is zero (but not for a = 0). The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"teichmuller(::qadic)","category":"page"},{"location":"qadic/#Nemo.teichmuller-Tuple{qadic}","page":"Qadics","title":"Nemo.teichmuller","text":"teichmuller(a::qadic)\n\nReturn the Teichmuller lift of the q-adic value a. We require the valuation of a to be nonnegative. The precision of the output will be the same as the precision of the input. For convenience, if a is congruent to zero modulo q we return zero. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"frobenius(::qadic, ::Int)","category":"page"},{"location":"qadic/#Nemo.frobenius-Tuple{qadic, Int64}","page":"Qadics","title":"Nemo.frobenius","text":"frobenius(a::qadic, e::Int = 1)\n\nReturn the image of the e-th power of Frobenius on the q-adic value a. The precision of the output will be the same as the precision of the input.\n\n\n\n","category":"method"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 5*7 + 3*7^2 + O(R, 7^3)\nc = 3*7 + 2*7^2 + O(R, 7^5)\n\nc = exp(c)\nd = log(a)\nc = exp(R(0))\nd = log(R(1))\nf = teichmuller(b)\ng = frobenius(a, 2)","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"CurrentModule = Nemo","category":"page"},{"location":"developer/parents/#Parent-objects","page":"Parent objects","title":"Parent objects","text":"","category":"section"},{"location":"developer/parents/#The-use-of-parent-objects-in-Nemo","page":"Parent objects","title":"The use of parent objects in Nemo","text":"","category":"section"},{"location":"developer/parents/#The-parent/element-model","page":"Parent objects","title":"The parent/element model","text":"","category":"section"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"As for other major computer algebra projects such as Sage and Magma, Nemo uses the parent/element model to manage its mathematical objects.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"As explained in the appendix to the AbstractAlgebra documentation, the standard type/object model used in most programming languages is insufficient for much of mathematics which often requires mathematical structures parameterised by other objects.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example a quotient ring by an ideal would be parameterised by the ideal. The ideal is an object in the system and not a type and so parameterised types are not sufficient to represent such quotient rings.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"This means that each mathematical \"domain\" in the system (set, group, ring, field, module, etc.) must be represented by an object in the system, rather than a type. Such objects are called parent objects.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Just as one would write typeof(a) to get the type of an object a in an object/type system of a standard programming language, we write parent(a) to return the parent of the object a.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"When talked about with reference to a parent in this way, the object a is referred to as an element of the parent. Thus the system is divided into elements and parents. For example a polynomial would be an element of a polynomial ring, the latter being the parent of the former.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Naturally the parent/element system leads to some issues in a programming language not built around this model. We discuss some of these issues below.","category":"page"},{"location":"developer/parents/#Types-in-the-parent/element-model","page":"Parent objects","title":"Types in the parent/element model","text":"","category":"section"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"As all elements and parents in Nemo are objects, those objects have types which we refer to as the element type and parent type respectively.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example, Flint integers have type fmpz and the parent object they all belong to, FlintZZ has type FlintIntegerRing.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"More complex parents and elements are parameterised. For example, generic univariate polynomials over a base ring R are parameterised by R. The base ring of a ring S can be obtained by the call base_ring(S).","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"We have found it extremely useful to parameterise the type of both the parent and element objects of such a ring by the type of the elements of the base ring. Thus for example, a generic polynomial with Flint integer coefficients would have type Poly{fmpz}.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"In practice Flint already implements univariate polynomials over Flint integers, and these have type fmpz_poly. But both fmpz_poly and the generic polynomials Poly{fmpz} belong to the abstract type PolyElem{fmpz} making it possible to write functions for all univariate polynomials over Flint integers.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Given a specific element type or parent type it is possible to compute one from the other with the functions elem_type and parent_type. For example parent_type(fmpz_poly) returns FmpzPolyRing and elem_type(FmpzPolyRing) returns fmpz_poly. Similarly parent_type(Generic.Poly{fmpz}) returns Generic.PolyRing{fmpz} and so on.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"These functions are especially useful when writing type assertions or constructing arrays of elements insides function where only the parent object was passed.","category":"page"},{"location":"developer/parents/#Other-functions-for-computing-types","page":"Parent objects","title":"Other functions for computing types","text":"","category":"section"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Sometimes one needs to know the type of a polynomial or matrix one would obtain if it were constructed over a given ring or with coefficients/entries of a given element type.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"This is especially important in generic code where it may not even be known which Julia package is being used. The user may be expecting an AbstractAlgebra object, a Nemo object or even some other kind of object to be constructed, depending on which package they are using.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"The function for returning the correct type for a dense matrix is dense_matrix_type to which one can pass either a base ring or an element type. For example, if AbstractAlgebra is being used, dense_matrix_type(ZZ) will return Mat{BigInt} whereas if Nemo is being used it will return fmpz_mat.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"We also have dense_poly_type for univariate polynomials, abs_series_type for absolute series and rel_series_type for relative series.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"In theory such functions should exist for all major object types, however they have in most cases not been implemented yet.","category":"page"},{"location":"developer/parents/#Functions-for-creating-objects-of-a-similar-type","page":"Parent objects","title":"Functions for creating objects of a similar type","text":"","category":"section"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"A slightly more consistent interface for creating objects of a type that is suitable for the package currently in use is the similar interface.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example, given a matrix M one can create one with the same dimensions but over a different ring R by calling similar(M, R). Likewise one can create one over the same ring with different dimensions r x c by calling similar(M, r, c).","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"The similar system is sophisticated enough to know that there is no native type provided by Flint/Antic for matrices and polynomials over a number field. The system knows that in such cases it must create a generic matrix or polynomial over the given number field.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"A great deal of thought went into the design of the similar system so that developers would not be required to implement similar for every pair of types in the package.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Again this interface should exist for all major Nemo domains, but the functionality is still being implemented in some cases.","category":"page"},{"location":"developer/parents/#Changing-base-rings-and-map","page":"Parent objects","title":"Changing base rings and map","text":"","category":"section"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Given a polynomial, matrix or other composite object over a base ring, it is often convenient to create a similar object but with all the entries or coefficients coerced into a different ring.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"For this purpose the function change_base_ring is provided.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Similarly it may be useful to create the matrix or polynomial that results by applying a given map/function/lambda to each of the entries or coefficients.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"For this purpose Julia's map function is overloaded. There are also functions specific to polynomials and matrices called map_coefficients and map_entries respectively, which essentially do the same thing.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Note that the implementation of such functions must make use of the functions discussed above to ensure that a matrix/polynomial of the right type is output.","category":"page"},{"location":"developer/parents/#Parent-checking","page":"Parent objects","title":"Parent checking","text":"","category":"section"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"When applying binary operations to a pair of elements of a given ring, it is useful to check that they are in fact elements of the same ring. This is not possible by checking the types alone. For example elements of Z7Z and Z3Z would have the same type but different parents (one parameterised by the integer 7, the other by the integer 3).","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"In order to perform such a check in a function one uses check_parent(a, b) where a and b are the objects one wishes to assert must have the same parent. If not, an exception is raised by parent_check.","category":"page"},{"location":"developer/parents/#Parent-object-constructors","page":"Parent objects","title":"Parent object constructors","text":"","category":"section"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Various functions are provided for constructing parent objects. For example a polynomial ring is constructed by calling a PolynomialRing function. Such functions are called parent object constructors.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"In general parent object constructors are intended for the user and should not be used in library code. There are a number of reasons for this.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Firstly, inside the Generic submodule of AbstractAlgebra the only parent object constructors that are directly accessible are the ones inside Generic. Thus if a Nemo function calls a function inside Generic and it creates a parent object using one of the parent object constructors, it will create a parent object for a generic ring rather than a Nemo one.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"One can work around this by calling AbstractAlgebra.PolynomialRing instead of simply PolynomialRing inside Generic, but even safer would be to find another way to construct the polynomials required.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"A second issue is that parent objects are allowed to be as large as one likes and they are cached by the system. They can also perform arbitrary precomputations for the ring/field/module etc. that is being constructed. Over time they tend to accumulate such precomputations, slowing down all generic code which made use of them. Both memory usage and performance may blow out in previously working code.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Thirdly, parent objects must be unique across the system for a given set of parameters. This means they must be cached globally. This is problematic for any future attempts to parallelise library code and in the worst case memory usage can balloon due to swelling caches.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Most parent object constructors take a cached keyword which specifies whether the parent object should be cached or not, but again it is better overall to simply eschew the use of parent object constructors in library code.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Instead, it is recommended to use functions such as similar, zero, zero_matrix, identity_matrix, change_base_ring, map, etc. for constructing polynomials and matrices directly.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"There are also functions that provide alternative ways of constructing objects, e.g. matrix provides a means of creating a matrix over a given ring with given dimensions. The constructor polynomial allows creation of a polynomial over a given base ring with given coefficients and abs_series and rel_series do similar things for absolute and relative series. These should be used in preference to parent object constructors where possible. Additional functions of this type should be added in future.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"However even when using these functions in library code, it is important to remember to pass cached=false so that the cache is not filled up by calls to the library code. But this creates an additional problem, namely that if one uses polynomial say, to construct two polynomials over the same base ring, they will not be compatible in the sense that they will have different parents.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"When one wishes to construct multiple elements in the same group/ring/field, it is convenient to be able to construct a parent just as a user would. For this purpose various light-weight and very safe parent constructors are provided for use in library code.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example there are the constructors PolyRing, AbsSeriesRing and RelSeriesRing. These functions return the parent ring R only and no generator (it can be obtained by calling gen(R)). They also set the variable for printing to a default (usually x). Moreover, these parents are not cached, so they are completely safe to use in library code. They can be thousands of times faster than the full parent constructors intended for users.","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Here is an example of their use:","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"R = PolyRing(ZZ)\np = R([1, 2, 3])\nq = R([2, 3, 4])\ns = p + q","category":"page"},{"location":"developer/parents/","page":"Parent objects","title":"Parent objects","text":"Naturally functions like polynomial and matrix and the light-weight parent constructors are missing for other modules in Nemo at present and it is hoped that developers will fill in such infrastructure rather than simply push the can down the road for someone else to fix. Forcing the creating of full parent objects into as few bottlenecks as possible will make it much easier for developers to remove problems associated with such calls when they arise in future.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"CurrentModule = Nemo","category":"page"},{"location":"developer/topics/#Specific-topics","page":"Specific topics","title":"Specific topics","text":"","category":"section"},{"location":"developer/topics/#Julia-arithmetic","page":"Specific topics","title":"Julia arithmetic","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"At the console, Julia arithmetic is often defined in a way that a numerical person would expect. For example, 3/1 returns a floating point number 3.0, sqrt(4) returns the floating point number 2.0 and exp(0) returns the floating point number 1.0.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In each case the ring is changed from the input to the output of the function. Whilst this is often what one expects to happen in a computer algebra system, these are not the definitions one would want for algebraic operations.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In this section we describe the alternatives we have implemented to allow algebraic computations, particularly for rings and fields.","category":"page"},{"location":"developer/topics/#divexact-and-divides","page":"Specific topics","title":"divexact and divides","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Nemo implements numerous kinds of division:","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"floating point division using the / operator as per Julia\nexact division in a ring using divexact and divides\nquotient field element construction using // as per Julia\nEuclidean division using div, rem, divrem, mod and %","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The expression divexact(a, b) for a and b in a ring R returns a value c in R such that a = bc. If such an element of R does not exist, an exception is raised.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"To instead test whether such an element exists, divides(a, b) returns a tuple (flag, q) where flag is a boolean saying whether such an exact quotient exists in the ring and if so q is such a quotient.","category":"page"},{"location":"developer/topics/#Euclidean-division","page":"Specific topics","title":"Euclidean division","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Nemo must provide Euclidean division, i.e. given a and b in a Euclidean ring R it must be able to find q and r such that a = bq + r with r smaller than a with respect to some fixed Euclidean function on R. There are some restrictions imposed by Julia however.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Firstly, % is a constant alias of rem in Julia, so these are not actually two independent functions but the same function.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Julia defines div, rem and divrem for integers as a triple of functions that return Euclidean quotient and remainder, where the remainder has the same sign as the dividend, e.g. rem(1, 3) == 1 but rem(-2, 3) == -2. In other words, this triple of functions gives Euclidean division, but without a consistent set of representatives.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"When using Nemo at the console (or indeed inside any other package without importing the internal Nemo definitions) div, rem and divrem return the same values as Julia and these functions follows the Julia convention of making the sign of the remainder the same as the dividend over ZZ, e.g. rem(ZZ(1), ZZ(3)) == 1 but rem(ZZ(-2), ZZ(3)) == -2.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Internally to Nemo however, this is not convenient. For example, Hermite normal form over ZZ will only return a unique result if there is a consistent choice of representatives for the Euclidean division. This applies to the generic HNF code in AbstractAlgebra, but similar problems exist for the generic finitely presented module code in AbstractAlgebra, even when used over Nemo integers. Thus the Julia definition of rem will not suffice.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Furthermore, as Nemo wraps Flint, it is convenient that Euclidean division inside Nemo should operate the way Flint operates. This is critical if for example one wants the result of a Hermite normal form coming from Flint to be reduced using the same definition of Euclidean remainder as used elsewhere throughout the Nemo module and to return the same answers as the generic HNF code in AbstractAlgebra for example.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In particular, Flint defines Euclidean remainder over the integers in line with the Julia function mod, namely by returning the smallest remainder with the same sign as the divisor, i.e. mod(1, 3) == 1 but mod(1, -3) == -2.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Therefore internally, Nemo chooses div, mod and divrem to be a consistent triple of functions for Euclidean division, with mod defined as per Julia. Thus in particular, div and divrem behave differently to Julia inside of Nemo itself, viz. Nemo.divrem(-1, 3) == (-1, 2).","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The same definitions for div, mod and divrem are used internally to AbstractAlgebra as well, even for Julia integers, so that AbstractAlgebra and Nemo are both consistent internally. However, both AbstractAlgebra and Nemo export definitions in line with Julia so that behaviour at the console is consistent.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The Nemo developers have given considerable thought to this compromise and the current situation has evolved over many iterations to the current state. We do not consider this to be a situation that needs 'fixing', though we are acutely aware that many tickets will be opened complaining about some inconsistency.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"When reflecting on the choice we have made, one must consider the following:","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Nemo must internally behave as Flint does for consistency\nThere are also functions such as powmod, invmod that reduce as per mod\nHNF requires a consistent set of representatives for uniqueness over ZZ","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Also note that Julia's rem does not provide symmetric mod, a misconception that often arises. The issues here are independent of the decision to use positive remainder (for positive modulus) in Flint, rather than symmetric mod.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"We are aware that the conventions we have chosen have inconsistencies with Julia and do not have the nice property that div, rem and divrem are a triple of Euclidean functions inside Nemo. However, we are sure that the convention we have chosen is one of only two sensible possibilities, and switching to the other convention (apart from being a huge amount of effort) would only succeed in replacing one kind of inconsistency with another.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"As a consequence of these choices, div, mod and divrem are a triple of functions for all Euclidean division across Nemo, not just for the integers. As generic code must use a consistent set of functions, we ask that developers respect this choice by using these three functions in all generic code. The functions rem and % should only be used for Julia integers, and only when one specifically wants the Julia definition.","category":"page"},{"location":"developer/topics/#sqrt,-inv-and-exp","page":"Specific topics","title":"sqrt, inv and exp","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"As mentioned above, Julia does not perform computations within a given ring, but often returns a numerical result when given an exact input.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Whilst this is often what a user expects, it makes operations such as power series square root, inversion or exponentiation more tricky over an exact ring.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Therefore, AbstractAlgebra defines sqrt, inv and exp internally in a strictly algebraic way, returning a result only if it exists in the ring of the input and otherwise raising an exception.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"For example, AbstractAlgebra.sqrt(4) == 2, AbstractAlgebra.inv(-1) == -1 and AbstractAlgebra.exp(0) == 1.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Naturally these definitions are not so terribly useful to a user and are only needed for internal consistency. Therefore, of course these definitions are not exported by AbstractAlgebra so that the behaviour at the console is not affected by these definitions.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"There is currently some inconsistency in that Nemo follows the Julia numerical definitions internally rather than following the algebraic definitions provided internally in AbstractAlgebra. This may or may not change in future.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"It is worth recalling that Julia provides isqrt for integer square root. This is not sufficient to solve our problem as we require square root for all rings, not just integers. We don't feel that developers will want to type isqrt rather than sqrt internally for all rings.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"A number of changes are expected to be made with regard to the behaviour of root taking and division functions, including the ability to specify high performance alternatives that do not check the exactness of the computation. These changes are being discussed on the Nemo ticket https://github.com/Nemocas/Nemo.jl/issues/862 In particular, the table given there by thofma represents the current consensus on the changes that will be made in the future.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that many of the above issues with exact computations in rings exist for all the Julia transcendental functions, sin, cos, log, etc., of which there are many. If we ever add some kind of generic power series functions for these, we may extend the internal definitions to include exact algebraic versions of all these functions. At least for now this is not a pressing issue.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The way that AbstractAlgebra deals with functions which must have a different definition inside the module than what it exports is as follows. Firstly, we do not import the functions from Base or export the functions at all. Internally we make our definitions as we want them, but then we overload the Base version explicitly to do what the console version of the function should do. This is done by explicitly defining Base.sqrt(::fmpz) for example without explicitly importing sqrt from Base, etc.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the Generic module discussed below, we import the definitions from AbstractAlgebra rather than Base.","category":"page"},{"location":"developer/topics/#Determinant","page":"Specific topics","title":"Determinant","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Another function which Nemo handles differently to Julia is det for determinant of matrices. If the input is an integer matrix, Nemo outputs an integer rather than a floating point number for the determinant.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"However, this is not such an acute problem as Julia's det has now been placed in LinearAlgebra rather than Base. Moreover, Nemo has its own matrices and so does not conflict with the definition of det for Julia matrices.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"It is important for developers to understand this difference however. It is not generally wise to use the Julia linear algebra functionality on the Julia matrices underlying generic Nemo matrices for this reason.","category":"page"},{"location":"developer/topics/#The-Generic-submodule","page":"Specific topics","title":"The Generic submodule","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In AbstractAlgebra we define a submodule called Generic. The purpose of this module is to allow generic constructions over a given base ring. For example in Nemo, R, x = Generic.PolynomialRing(ZZ, \"x\") will construct a generic polynomial ring over Nemo integers instead of constructing a Flint polynomial ring.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In other words x will have the type Generic.Poly{fmpz} instead of the usual fmpz_poly.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The ability to construct generic polynomials and matrices and the like is useful for test code and for tracking down bugs in basic arithmetic. It is also useful for performance comparison of arithmetic defined for generic ring constructions vs the specialised implementations provided by C libraries like Flint.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Whilst most developers will not need to use the Generic module specifically, unless they have such needs, all Nemo developers need to understand how to define new generic ring constructions and functions for them. They also need to understand some subtleties that arise because of this mechanism.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Firstly, a generic construction like PolynomialRing must be defined inside the Generic submodule of AbstractAlgebra. All files inside the src/generic directory of AbstractAlgebra exist for this purpose. However, exporting from that submodule will not export the functionality to the Nemo user.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"To do this, one must add a function PolynomialRing for example, in src/Poly.jl, say, which calls Generic.PolynomialRing. Then one needs to export PolynomialRing from AbstractAlgebra (also in that file).","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Similarly, all functions provided for generic polynomial rings are not automatically available, even when exported from the Generic submodule. Two additional things are required, namely an import from Generic into AbstractAlgebra and then an export from AbstractAlgebra to the user.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"An exception to this is if there is a function with the same name in AbstractAlgebra (i.e. in the top level src directory). In this case it is sufficient to simply import that function into Generic in the file src/Generic.jl.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the former case, two large lists exist in src/AbstractAlgebra.jl with these imports and exports. These are kept in alphabetical order to prevent duplicate imports/exports being added over time.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"If one wishes to extend a definition provided by Base, one can simply overload Base.blah inside the Generic submodule directly. Exceptions to this include the div, mod, divrem, sqrt, inv and exp functions mentioned above.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"For AbstractAlgebra types, one still defines these exceptions blah by overloading Base.blah directly inside Generic. However, for the versions that would conflict with the Julia definition (e.g. the definition for Int), we instead define AbstractAlgebra.blah for that specific type and a fallback AbstractAlgebra.blah(a) = Base.blah(a) which calls the Base version of the function for all other types. Of course we do not export blah from AbstractAlgebra.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In order to make the AbstractAlgebra version available in Generic (rather than the Base version), we do not import blah from Base inside Generic, but instead import it from AbstractAlgebra. One can see these imports for the exceptional functions blah in the file src/Generic.jl.","category":"page"},{"location":"developer/topics/#Unsafe-operations-and-aliasing","page":"Specific topics","title":"Unsafe operations and aliasing","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"As with most object oriented languages that overload arithmetic operators, Julia creates new objects when doing an arithmetic operation. For example, BigInt(3) + BigInt(5) creates a new BigInt object to return the value BigInt(8). This can be problematic when accumulating many such operations in a single coefficient of a polynomial or entry of a matrix due to the large number of temporary objects the garbage collector must allocate and clean up.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"To speed up such accumulations, Nemo provides numerous unsafe operators, which mutate the existing elements of the polynomial, matrix, etc. These include functions such as add!, addeq!, mul!, zero! and addmul!.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"These functions take as their first argument the object that should be modified with the return value.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that functions such as sub!, submul! and subeq! are not in the official interface and not provided consistently, thus generic code cannot rely on them existing. So far it has always been the case that when doing accumulation where subtraction is needed rather than addition, that a single negation can be performed outside the accumulation loop and then the additive versions of the functions can be called inside the loop where the performance matters.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"If we encounter cases in future where this is not the case, it may be necessary to add the versions that do subtraction to the interface. However, this can only be done if all rings in Nemo support it. One cannot define a fallback which turns a subtraction into a negation and an addition, as then the old performance characteristics of a new object being created per operation will result, meaning that the developer will not be able to reason about the likely performance of unsafe operators.","category":"page"},{"location":"developer/topics/#Interaction-of-unsafe-operators-and-immutable-types","page":"Specific topics","title":"Interaction of unsafe operators and immutable types","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Because not all objects in Nemo are mutable, the unsafe operators somehow have to support immutable objects. This is done by also returning the \"modified\" return value from the unsafe operators. Naturally, this return value is not a mutated version of the original value, as that is not possible. However, it does allow the unsafe operators to accept immutable values in their first argument. Instead of modifying this value, the old value is replaced with the return value of the unsafe operator.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In order to make this work correctly, every single call to an unsafe operator must assign the return value to the original location. This requires discipline on the part of the developer using unsafe operators.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"For example, to set the existing value a to a + b one must write","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"a = addeq!(a, b)","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"i.e. one must have an explicit assignment to the left of the addeq! call and indeed all the unsafe operator calls.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the case of a mutable type, addeq! will simply modify the original a. The modified object will be returned and assigned to the exact same variable, which has no effect.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the case of an immutable type, addeq! does not modify the original object a as this is impossible, but it still returns the new value and assigns it to a which is what one wants.","category":"page"},{"location":"developer/topics/#Aliasing-rules-and-mutation","page":"Specific topics","title":"Aliasing rules and mutation","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"One must be incredibly careful when mutating an existing value that one owns the value. If the user passes an object to a generic function for example and it changes the object without the user knowing, this can result in incorrect results in user code due to the value of their objects changing from under them.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the first instance, functions should never modify their inputs. But further problems can also occur if the output of an unsafe operator happens to alias one of the other inputs. Such cases need to be handled exceptionally carefully.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"A second issue arises as Nemo is based on Flint, which has its own aliasing rules which are distinct from the default expectation in Julia. This leads to some interesting corner cases.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In particularly, Flint always allows aliasing of inputs and outputs in its polynomial functions but expects matrix functions to have output matrices that are distinct from their inputs, except in a handful of functions that are specially documented to be inplace operations.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Moreover, when assigning an element to a coefficient of a polynomial or entry of a matrix Flint always makes a copy of the element being assigned to that location. In Julia however, if one assigns an element to some index of an array, the existing object at that location is replaced with the new object. This means that inplace modification of Julia array elements is not safe as it would modify the original object that was assigned to that location, whereas in Flint inplace modification is highly desirable for performance reasons and is completely safe due to the fact that a copy was made when the value was assigned to that location.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"We have developed over a period of many years a set of rules that maximise the performance benefit we get from our unsafe operators, whilst keeping the burden imposed on the programmer to a minimum. It has been a very difficult task to arrive at the set of rules we have whilst respecting correctness of our code, and it would be extremely hard to change any of them.","category":"page"},{"location":"developer/topics/#Arithmetic-operations-return-a-new-object","page":"Specific topics","title":"Arithmetic operations return a new object","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In order to make it easy for the Nemo developer to create a completely new object when one is needed, e.g. for accumulating values using unsafe operators, we developed the following rules.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Whenever an arithmetic operation is used, i.e. +, -, *, unary minus and ^, Nemo always returns a new object, in line with Julia. Naturally, deepcopy also makes a copy of an object which can be used in unsafe functions.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that if R is a type and an element a of that type is passed to it, e.g. R(a) then, the Julia convention is that the original object a will be returned rather than a copy of a. This convention ensures there is not an additional cost when coercing values that are already of the right type, e.g in generic code where coercion may or may not be needed depending on the type.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"We extend this convention to parent objects R and elements a of that parent. In particular, R(a) cannot be used to make a copy of a for use in an unsafe function if R is the parent of a.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"All other functions may also return the input object if they wish. In other words, the return value of all other functions is not suitable for use in an unsafe function. Only return values of arithmetic operations and deepcopy or objects freshly created using inner constructors will be suitable for such use.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"This convention has been chosen to maximise performance of Nemo. Low level operations (where performance matters) make a new object, even if the result is the same arithmetically as one of the inputs. But higher level functions will not necessarily make a new object, meaning that they cannot be used with unsafe functions.","category":"page"},{"location":"developer/topics/#Aliasing-rules","page":"Specific topics","title":"Aliasing rules","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"We now summarise the aliasing rules used by Nemo and AbstractAlgebra. We are relatively confident by now that following these rules will result in correct code given the constraints mentioned above.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"matrices are viewed as containers which may contain elements that alias one another. Other objects, e.g. polynomials, series, etc., are constructed from objects that do not alias one another, even in part\nstandard unsafe operators, addeq!, mul!, addmul!, zero!, add! which mutate their outputs are allow to be used iff that output is entirely under the control of the caller, i.e. it was created for the purpose of accumulation, but otherwise must not be used\nall arithmetic functions i.e. unary minus, +, -, *, ^, and deepcopy must return new objects and cannot return one of their inputs\nall other functions are allowed to return their inputs as outputs\nmatrix functions with an exclamation mark should not mutate the objects that occur as entries of the output matrix, though should be allowed to arbitrarily replace/swap the entries that appear in the matrix. In other words, these functions should be interpreted as inplace operations, rather than operations that are allowed to mutate the actual entries themselves\nR(a) where R is the parent of a, always just returns a and not a copy\nsetcoeff! and setindex! and getcoeff and getindex should not make copies. Note that this implies that setcoeff! should not be passed an element that aliases another somewhere else, even in part\nConstructors for polynomials, series and similar ring element objects (that are not matrices) that take an array as input, must ensure that the coefficients being placed into the object do not alias, even in part","category":"page"},{"location":"developer/topics/#The-SparsePoly-module","page":"Specific topics","title":"The SparsePoly module","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The SparsePoly module in AbstractAlgebra is a generic module for sparse univariate polynomials over a given base ring.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"This module is used internally, e.g. in the generic multivariate gcd code, however it is not particularly suitable for general use.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Firstly, whilst the representation is sparse (recursive) the algorithms used generally are not. This is because the amount of time taken by the Jit in Julia is simply too large (upwards of 6s for the first multivariate gcd).","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Secondly, the order of terms in that representation is not the one which a developer would expect for a sparse univariate format.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"If the Julia Jit is ever made orders of magnitude faster, it may be worth cleaning up this module and making it generally available. But for now, it should be considered internal and heavily incomplete.","category":"page"},{"location":"developer/topics/#Parent-object-caching","page":"Specific topics","title":"Parent object caching","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Parent objects in Nemo must be unique given the data that is used to create them. For this purpose most parent objects are cached globally and looked up upon creation. If a parent object with that data already exists, it is returned from the cache instead of creating a new one.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"There are two situations where this can be problematic however.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The first situation is if one is doing some parallel programming. Here global objects are a blight and it may be necessary to turn off caching and simply ensure that that same data is only ever used once when creating parent objects.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"The second situation is when doing multimodular algorithms, where many similar parent objects with different moduli are created. The cache can become overwhelmed slowing the code down or even grinding to a halt.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"In both these situations one can pass false as an additional argument to a parent constructor to avoid caching the parent object it creates. This parameter normally has a default value of true and under normal circumstances doesn't need to be supplied.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that special light-weight parent constructors, PolyRing, AbsSeriesRing, RelSeriesRing, etc. are also provided which do not cache.","category":"page"},{"location":"developer/topics/#Throw/nothrow-for-check_parent","page":"Specific topics","title":"Throw/nothrow for check_parent","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"By default the check_parent functions throw an exception if parents do not match. However sometimes one would like to know if they match without throwing.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"For this purpose one can pass an additional false argument to check_parent. This supresses the exception that would be thrown if the parent objects didn't match. Instead the function simply returns true or false to indicate whether they matched or not.","category":"page"},{"location":"developer/topics/#Delayed-reduction","page":"Specific topics","title":"Delayed reduction","text":"","category":"section"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"When working in residue rings, various functions will perform an arithmetic operation followed by a reduction modulo the modulus of the residue ring.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Some accumulations, e.g. in linear algebra or polynomial arithmetic, can be dramatically sped up if one can delay the reductions that would happen after each operation in the accumulation.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Some of the Generic code in Nemo is designed to allow such delayed reduction if the ring supports it and to simply use fallbacks that do the reduction after every intermediate operation if they don't.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"To support delayed reduction, a ring must support the delayed reduction interface which we describe here.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Two additional functions must be supplied for the element type. We give examples for the Nemo nf_elem type:","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"mul_red!(z::nf_elem, x::nf_elem, y::nf_elem, red::Bool)","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"This function behaves as per mul! but only performs reduction if the additional boolean argument red is set to true. This function can assume that both the inputs are reduced.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"reduce!(x::nf_elem)","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"This function must perform reduction on an unreduced element (mutating it). Note that it must return the mutated value as per all unsafe operators.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Finally, the add! and addeq! operators must be able to add nonreduced values.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"If one wishes to speed up generic code for rings that provide delayed reduction, one makes use of the function addmul_delayed_reduction! in the accumulation loop. Here is an example for accumulation into a two dimensional matrix element in Generic in a matrix multiplication routine:","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"A[i, j] = base_ring(X)()\nfor k = 1:ncols(X)\n    A[i, j] = addmul_delayed_reduction!(A[i, j], x[i, k], y[k, j], C)\nend\nA[i, j] = reduce!(A[i, j])","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Here C is a temporary element of the same type as the other inputs which is used internally in addmul_delayed_reduction! if needed.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Notice the final call to reduce! to reduce the accumulated value after the accumulation loop has finished.","category":"page"},{"location":"developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that mul_red! is never called directly but is called inside the generic implementation of addmul_delayed_reduction! for rings that support delayed reduction. That generic code falls back to a call to addmul! which in turn falls back to mul! and addeq! where delayed reduction or addmul! are not available.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"CurrentModule = Nemo","category":"page"},{"location":"padic/#Padics","page":"Padics","title":"Padics","text":"","category":"section"},{"location":"padic/","page":"Padics","title":"Padics","text":"P-adic fields are provided in Nemo by Flint. This allows construction of p-adic fields for any prime p.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"P-adic fields are constructed using the FlintPadicField function. However, for convenience we define","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"PadicField = FlintPadicField","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"so that p-adic fields can be constructed using PadicField rather than FlintPadicField. Note that this is the name of the constructor, but not of padic field type.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"The types of p-adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"Library Field Element type Parent type\nFlint mathbbQ_p padic PadicField","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"All the p-adic field types belong to the Field abstract type and the p-adic field element types belong to the FieldElem abstract type.","category":"page"},{"location":"padic/#P-adic-functionality","page":"Padics","title":"P-adic functionality","text":"","category":"section"},{"location":"padic/","page":"Padics","title":"Padics","text":"P-adic fields in Nemo implement all the AbstractAlgebra field functionality:.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"Below, we document all the additional function that is provide by Nemo for p-adic fields.","category":"page"},{"location":"padic/#Constructors","page":"Padics","title":"Constructors","text":"","category":"section"},{"location":"padic/","page":"Padics","title":"Padics","text":"In order to construct p-adic field elements in Nemo, one must first construct the p-adic field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"FlintPadicField(::Integer, ::Int)","category":"page"},{"location":"padic/#Nemo.FlintPadicField-Tuple{Integer, Int64}","page":"Padics","title":"Nemo.FlintPadicField","text":"FlintPadicField(p::Integer, prec::Int; kw...)\n\nReturns the parent object for the p-adic field for given prime p, where the default absolute precision of elements of the field is given by prec.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"It is also possible to call the inner constructor directly. It has the following form.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"FlintPadicField(p::fmpz, prec::Int)","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"Returns the parent object for the p-adic field for given prime p, where the default absolute precision of elements of the field is given by prec.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"Here are some examples of creating p-adic fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\nS = PadicField(ZZ(65537), 30)\n\na = R()\nb = S(1)\nc = S(ZZ(123))\nd = R(ZZ(1)//7^2)","category":"page"},{"location":"padic/#Big-oh-notation","page":"Padics","title":"Big-oh notation","text":"","category":"section"},{"location":"padic/","page":"Padics","title":"Padics","text":"Elements of p-adic fields can  be constructed using the big-oh notation. For this purpose we define the following functions.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"O(::FlintPadicField, ::Integer)\nO(::FlintPadicField, ::fmpz)\nO(::FlintPadicField, ::fmpq)","category":"page"},{"location":"padic/#AbstractAlgebra.O-Tuple{FlintPadicField, Integer}","page":"Padics","title":"AbstractAlgebra.O","text":"O(R::FlintPadicField, m::Integer)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"padic/#AbstractAlgebra.O-Tuple{FlintPadicField, fmpz}","page":"Padics","title":"AbstractAlgebra.O","text":"O(R::FlintPadicField, m::fmpz)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"padic/#AbstractAlgebra.O-Tuple{FlintPadicField, fmpq}","page":"Padics","title":"AbstractAlgebra.O","text":"O(R::FlintPadicField, m::fmpq)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"The O(p^n) construction can be used to construct p-adic values of precision n by adding it to integer values representing the p-adic value modulo p^n as in the examples.","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\nS = PadicField(ZZ(65537), 30)\n\nc = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nd = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\nf = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"Beware that the expression 1 + 2*p + 3*p^2 + O(R, p^n) is actually computed as a normal Julia expression. Therefore if {Int} values are used instead of Flint integers or Julia bignums, overflow may result in evaluating the value.","category":"page"},{"location":"padic/#Basic-manipulation","page":"Padics","title":"Basic manipulation","text":"","category":"section"},{"location":"padic/","page":"Padics","title":"Padics","text":"prime(::FlintPadicField)","category":"page"},{"location":"padic/#AbstractAlgebra.Generic.prime-Tuple{FlintPadicField}","page":"Padics","title":"AbstractAlgebra.Generic.prime","text":"prime(R::FlintPadicField)\n\nReturn the prime p for the given p-adic field.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"precision(::padic)","category":"page"},{"location":"padic/#Base.precision-Tuple{padic}","page":"Padics","title":"Base.precision","text":"precision(a::padic)\n\nReturn the precision of the given p-adic field element, i.e. if the element is known to O(p^n) this function will return n.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"valuation(::padic)","category":"page"},{"location":"padic/#AbstractAlgebra.valuation-Tuple{padic}","page":"Padics","title":"AbstractAlgebra.valuation","text":"valuation(a::padic)\n\nReturn the valuation of the given p-adic field element, i.e. if the given element is divisible by p^n but not a higher power of p then the function will return n.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"lift(::FlintIntegerRing, ::padic)\nlift(::FlintRationalField, ::padic)","category":"page"},{"location":"padic/#AbstractAlgebra.lift-Tuple{FlintIntegerRing, padic}","page":"Padics","title":"AbstractAlgebra.lift","text":"lift(R::FlintIntegerRing, a::padic)\n\nReturn a lift of the given p-adic field element to mathbbZ.\n\n\n\n","category":"method"},{"location":"padic/#AbstractAlgebra.lift-Tuple{FlintRationalField, padic}","page":"Padics","title":"AbstractAlgebra.lift","text":"lift(R::FlintRationalField, a::padic)\n\nReturn a lift of the given p-adic field element to mathbbQ.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = R(2)\n\nk = precision(a)\nm = prime(R)\nn = valuation(b)\np = lift(FlintZZ, a)\nq = lift(FlintQQ, divexact(a, b))","category":"page"},{"location":"padic/#Square-root","page":"Padics","title":"Square root","text":"","category":"section"},{"location":"padic/","page":"Padics","title":"Padics","text":"Base.sqrt(::padic)","category":"page"},{"location":"padic/#Base.sqrt-Tuple{padic}","page":"Padics","title":"Base.sqrt","text":"sqrt(a::padic; check::Bool=true)\n\nReturn the p-adic square root of a. We define this only when the valuation of a is even. The precision of the output will be precision(a) - valuation(a)2. By default if the square root does not exist, an exception is thrown. If check=false this test is not performed.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\n\nd = sqrt(a)\nf = sqrt(b)\nf = sqrt(c)\ng = sqrt(R(121))","category":"page"},{"location":"padic/#Special-functions","page":"Padics","title":"Special functions","text":"","category":"section"},{"location":"padic/","page":"Padics","title":"Padics","text":"Base.exp(::padic)","category":"page"},{"location":"padic/#Base.exp-Tuple{padic}","page":"Padics","title":"Base.exp","text":"exp(a::padic)\n\nReturn the p-adic exponential of a. We define this only when the valuation of a is positive (unless a = 0). The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"log(::padic)","category":"page"},{"location":"padic/#Base.log-Tuple{padic}","page":"Padics","title":"Base.log","text":"log(a::padic)\n\nReturn the p-adic logarithm of a. We define this only when ord_p(a) is at least 2 when p = 2 or art least 1 otherwise. The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"teichmuller(::padic)","category":"page"},{"location":"padic/#Nemo.teichmuller-Tuple{padic}","page":"Padics","title":"Nemo.teichmuller","text":"teichmuller(a::padic)\n\nReturn the Teichmuller lift of the p-adic value a. We require the valuation of a to be nonnegative. The precision of the output will be the same as the precision of the input. For convenience, if a is congruent to zero modulo p we return zero. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 5*7 + 3*7^2 + O(R, 7^3)\nc = 3*7 + 2*7^2 + O(R, 7^5)\n\nc = exp(c)\nd = log(a)\nc = exp(R(0))\nd = log(R(1))\nf = teichmuller(b)","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"CurrentModule = Nemo","category":"page"},{"location":"complex/#Exact-real-and-complex-numbers","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Exact real and complex numbers are provided by Calcium. Internally, a number z is represented as an element of an extension field of the rational numbers. That is,","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"z in mathbbQ(a_1ldotsa_n)","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"where a_1 ldots a_n are symbolically defined algebraic or transcendental real or complex numbers such as pi, sqrt2 or e^sqrt2 pi i. The user does not normally need to worry about the details of the internal representation; Calcium constructs extension numbers and fields automatically as needed to perform operations.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The user must create a CalciumField instance which represents the mathematical domain mathbbC. This parent object holds a cache of extension numbers and fields used to represent individual elements. It also stores various options for evaluation (documented further below).","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Library Element type Parent type\nCalcium ca CalciumField","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Please note the following:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"It is in the nature of exact complex arithmetic that some operations must be implemented using incomplete heuristics. For example, testing whether an element is zero will not always succeed. When Calcium is unable to perform a task, Nemo will throw an exception. This ensures that Calcium fields behave exactly and never silently return wrong results.\nCalcium elements can optionally hold special non-numerical values:\nUnsigned infinity hat infty\nSigned infinities (pm infty, pm i infty, and more generally e^i theta cdot infty)\nUndefined\nUnknown\nBy default, such special values are disallowed so that a CalciumField represents the mathematical field mathbbC, and any operation that would result in a special value (for example, 1  0 = hat infty) will throw an exception. To allow special values, pass extended=true to the CalciumField constructor.\nCalciumField instances only support single-threaded use. You must create a separate parent object for each thread to do parallel computation.\nWhen performing an operation involving two ca operands with different parent objects, Nemo will arbitrarily coerce the operands (and hence the result) to one of the parents.","category":"page"},{"location":"complex/#Calcium-field-options","page":"Exact real and complex numbers","title":"Calcium field options","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The CalciumField parent stores various options that affect simplification power, performance, or appearance. The user can override any of the default values using C = CalciumField(options=dict) where dict is a dictionary with Symbol => Int pairs. To retrieve the option values as a dictionary (including any default values not set by the user), call options(C).","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The following options are supported:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Option Explanation\n:verbose Enable debug output\n:print_flags Flags controlling print style\n:mpoly_ord Monomial order for polynomials\n:prec_limit Precision limit for numerical evaluation\n:qqbar_deg_limit Degree limit for algebraic numbers\n:low_prec Initial precision for numerical evaluation\n:smooth_limit Factor size limit for smooth integer factorization\n:lll_prec Precision for integer relation detection\n:pow_limit Maximum exponent for in-field powering\n:use_gb Enable Gröbner basis computation\n:gb_length_limit Maximum ideal basis length during Gröbner basis computation\n:gb_poly_length_limit Maximum polynomial length during Gröbner basis computation\n:gb_poly_bits_limit Maximum bit size during Gröbner basis computation\n:gb_vieta_limit Maximum degree to use Vieta's formulas\n:trig_form Default form of trigonometric functions","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"An important function of these options is to control how hard Calcium will try to find an answer before it gives up. For example:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Setting :prec_limit => 65536 will allow Calcium to use up to 65536 bits of precision (instead of the default 4096) to prove inequalities.\nSetting :qqbar_deg_limit => typemax(Int) (instead of the default 120) will force most calculations involving algebraic numbers to run to completion, no matter how long this will take.\nSetting :use_gb => 0 (instead of the default 1) disables use of Gröbner bases. In general, this will negatively impact Calcium's ability to simplify field elements and prove equalities, but it can speed up calculations where Gröbner bases are unnecessary.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"For a detailed explanation, refer to the following section in the Calcium documentation: https://fredrikj.net/calcium/ca.html#context-options","category":"page"},{"location":"complex/#Basic-examples","page":"Exact real and complex numbers","title":"Basic examples","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C = CalciumField()\nExact Complex Field\n\njulia> exp(C(pi) * C(1im)) + 1\n0\n\njulia> log(C(-1))\n3.14159*I {a*b where a = 3.14159 [Pi], b = I [b^2+1=0]}\n\njulia> log(C(-1)) ^ 2\n-9.86960 {-a^2 where a = 3.14159 [Pi], b = I [b^2+1=0]}\n\njulia> log(C(10)^23) // log(C(100))\n11.5000 {23/2}\n\njulia> 4*atan(C(1)//5) - atan(C(1)//239) == C(pi)//4\ntrue\n\njulia> Cx, x = PolynomialRing(C, \"x\")\n(Univariate Polynomial Ring in x over Exact Complex Field, x)\n\njulia> (a, b) = (sqrt(C(2)), sqrt(C(3)))\n(1.41421 {a where a = 1.41421 [a^2-2=0]}, 1.73205 {a where a = 1.73205 [a^2-3=0]})\n\njulia> (x-a-b)*(x-a+b)*(x+a-b)*(x+a+b)\nx^4 + (-10)*x^2 + 1","category":"page"},{"location":"complex/#Conversions-and-numerical-evaluation","page":"Exact real and complex numbers","title":"Conversions and numerical evaluation","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Calcium numbers can created from integers (ZZ), rationals (QQ) and algebraic numbers (QQbar), and through the application of arithmetic operations and transcendental functions.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Calcium numbers can be converted to integers, rational and algebraic fields provided that the values are integer, rational or algebraic. An exception is thrown if the value does not belong to the target domain, if Calcium is unable to prove that the value belongs to the target domain, or if Calcium is unable to compute the explicit value because of evaluation limits.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> QQ(C(1))\n1\n\njulia> QQBar(sqrt(C(2)) // 2)\nRoot 0.707107 of 2x^2 - 1\n\njulia> QQ(C(pi))\nERROR: unable to convert to a rational number\n\njulia> QQ(C(10) ^ C(10^9))\nERROR: unable to convert to a rational number","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"To compute arbitrary-precision numerical enclosures, convert to ArbField or AcbField:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> CC = AcbField(64);\n\njulia> CC(exp(C(1im)))\n[0.54030230586813971740 +/- 9.37e-22] + [0.84147098480789650665 +/- 2.51e-21]*im","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The constructor","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"(R::AcbField)(a::ca; parts::Bool=false)","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"returns an enclosure of the complex number a. It attempts to obtain a relative accuracy of prec bits where prec is the precision of the target field, but it is not guaranteed that this goal is achieved.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"If parts is set to true, it attempts to achieve the target accuracy for both real and imaginary parts. This can be significantly more expensive if one part is smaller than the other, or if the number is nontrivially purely real or purely imaginary (in which case an exact proof attempt is made).","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> x = sin(C(1), form=:exponential)\n0.841471 + 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}\n\njulia> AcbField(64)(x)\n[0.84147098480789650665 +/- 2.51e-21] + [+/- 4.77e-29]*im\n\njulia> AcbField(64)(x, parts=true)\n[0.84147098480789650665 +/- 2.51e-21]","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The constructor","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"(R::ArbField)(a::ca; check::Bool=true)","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"returns a real enclosure. If check is set to true (default), the number a is verified to be real, and an exception is thrown if this cannot be determined. With check set to false, this function returns an enclosure of the real part of a without checking that the imaginary part is zero. This can be significantly faster.","category":"page"},{"location":"complex/#Comparisons-and-properties","page":"Exact real and complex numbers","title":"Comparisons and properties","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Except where otherwise noted, predicate functions such as iszero, ==, < and isreal act on the mathematical values of Calcium field elements. For example, although evaluating x = sqrt2 sqrt3 and y = sqrt6 results in different internal representations (x in mathbbQ(sqrt3 sqrt2) and y in mathbbQ(sqrt6)), the numbers compare as equal:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> x = sqrt(C(2)) * sqrt(C(3))\n2.44949 {a*b where a = 1.73205 [a^2-3=0], b = 1.41421 [b^2-2=0]}\n\njulia> y = sqrt(C(6))\n2.44949 {a where a = 2.44949 [a^2-6=0]}\n\njulia> x == y\ntrue\n\njulia> iszero(x - y)\ntrue\n\njulia> isinteger(x - y)\ntrue","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Predicate functions return true if the property is provably true and false if the property if provably false. If Calcium is unable to prove the truth value, an exception is thrown. For example, with default settings, Calcium is currently able to prove that e^e^-1000 ne 1, but it fails to prove e^e^-3000 ne 1:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> x = exp(exp(C(-1000)))\n1.00000 {a where a = 1.00000 [Exp(5.07596e-435 {b})], b = 5.07596e-435 [Exp(-1000)]}\n\njulia> x == 1\nfalse\n\njulia> x = exp(exp(C(-3000)))\n1.00000 {a where a = 1.00000 [Exp(1.30784e-1303 {b})], b = 1.30784e-1303 [Exp(-3000)]}\n\njulia> x == 1\nERROR: Unable to perform operation (failed deciding truth of a predicate): isequal\n...","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"In this case, we can get an answer by allowing a higher working precision:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C2 = CalciumField(options=Dict(:prec_limit => 10^5));\n\njulia> exp(exp(C2(-3000))) == 1\nfalse","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Real numbers can be ordered and sorted the usual way. We illustrate finding square roots that are well-approximated by integers:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> sort([sqrt(C(n)) for n=0:10], by=x -> abs(x - floor(x + C(1)//2)))\n11-element Vector{ca}:\n 0\n 1\n 2\n 3\n 3.16228 {a where a = 3.16228 [a^2-10=0]}\n 2.82843 {2*a where a = 1.41421 [a^2-2=0]}\n 2.23607 {a where a = 2.23607 [a^2-5=0]}\n 1.73205 {a where a = 1.73205 [a^2-3=0]}\n 2.64575 {a where a = 2.64575 [a^2-7=0]}\n 1.41421 {a where a = 1.41421 [a^2-2=0]}\n 2.44949 {a where a = 2.44949 [a^2-6=0]}","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"As currently implemented, order comparisons involving nonreal numbers yield false (in both directions) rather than throwing an exception:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C(1im) < C(1im)\nfalse\n\njulia> C(1im) > C(1im)\nfalse","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"This behavior may be changed or may become configurable in the future.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Interface","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"iszero(a::ca)\nisone(a::ca)\nisalgebraic(a::ca)\nisrational(a::ca)\nisinteger(a::ca)\nisreal(a::ca)\nisimaginary(a::ca)","category":"page"},{"location":"complex/#Base.iszero-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.iszero","text":"iszero(a::ca)\n\nReturn whether a is the number 0.\n\n\n\n","category":"method"},{"location":"complex/#Base.isone-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.isone","text":"isone(a::ca)\n\nReturn whether a is the number 1.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.isalgebraic-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.isalgebraic","text":"isalgebraic(a::ca)\n\nReturn whether a is an algebraic number.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.isrational-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.isrational","text":"isrational(a::ca)\n\nReturn whether a is a rational number.\n\n\n\n","category":"method"},{"location":"complex/#Base.isinteger-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.isinteger","text":"isinteger(a::ca)\n\nReturn whether a is an integer.\n\n\n\n","category":"method"},{"location":"complex/#Base.isreal-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.isreal","text":"isreal(a::ca)\n\nReturn whether a is a real number. This returns false if a is a pure real infinity.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.isimaginary-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.isimaginary","text":"isimaginary(a::ca)\n\nReturn whether a is an imaginary number. This returns false if a is a pure imaginary infinity.\n\n\n\n","category":"method"},{"location":"complex/#Infinities-and-special-values","page":"Exact real and complex numbers","title":"Infinities and special values","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"By default, CalciumField does not permit creating values that are not numbers, and any non-number value (unsigned infinity, signed infinity, Undefined) will result in an exception. This also applies to the special value Unknown, used in situations where Calcium is unable to prove that a value is a number. To enable special values, use extended=true.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C = CalciumField()\nExact Complex Field\n\njulia> 1 // C(0)\nERROR: DomainError with UnsignedInfinity:\nNon-number result\n...\n\njulia> Cext = CalciumField(extended=true)\nExact Complex Field (Extended)\n\njulia> 1 // Cext(0)\nUnsignedInfinity","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Note that special values do not satisfy the properties of a mathematical ring or field. You will likely get meaningless results if you put infinities in matrices or polynomials.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"unsigned_infinity(C::CalciumField)\ninfinity(C::CalciumField)\ninfinity(a::ca)\nundefined(C::CalciumField)\nunknown(C::CalciumField)\nisnumber(a::ca)\nisundefined(a::ca)\nisinf(a::ca)\nisuinf(a::ca)\nissigned_inf(a::ca)\nisunknown(a::ca)","category":"page"},{"location":"complex/#Nemo.unsigned_infinity-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"Nemo.unsigned_infinity","text":"unsigned_infinity(C::CalciumField)\n\nReturn unsigned infinity (hat infty) as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.infinity-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"Nemo.infinity","text":"infinity(C::CalciumField)\n\nReturn positive infinity (+infty) as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.infinity-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.infinity","text":"infinity(a::ca)\n\nReturn the signed infinity (a cdot infty). This throws an exception if the parent of a does not allow special values.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.undefined-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"Nemo.undefined","text":"undefined(C::CalciumField)\n\nReturn the special value Undefined as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.unknown-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"Nemo.unknown","text":"unknown(C::CalciumField)\n\nReturn the special meta-value Unknown as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.isnumber-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.isnumber","text":"isnumber(a::ca)\n\nReturn whether a is a number, i.e. not an infinity or undefined.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.isundefined-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.isundefined","text":"isundefined(a::ca)\n\nReturn whether a is the special value Undefined.\n\n\n\n","category":"method"},{"location":"complex/#Base.isinf-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.isinf","text":"isinf(a::ca)\n\nReturn whether a is any infinity (signed or unsigned).\n\n\n\n","category":"method"},{"location":"complex/#Nemo.isuinf-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.isuinf","text":"isuinf(a::ca)\n\nReturn whether a is unsigned infinity.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.issigned_inf-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.issigned_inf","text":"issigned_inf(a::ca)\n\nReturn whether a is any signed infinity.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.isunknown-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.isunknown","text":"isunknown(a::ca)\n\nReturn whether a is the special value Unknown. This is a representation property and not a mathematical predicate.\n\n\n\n","category":"method"},{"location":"complex/#Complex-parts","page":"Exact real and complex numbers","title":"Complex parts","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Functions for computing components of real and complex numbers will perform automatic symbolic simplifications in special cases. In general, such operations will introduce new extension numbers.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> real(C(2+3im))\n2\n\njulia> sign(C(2im))\n1.00000*I {a where a = I [a^2+1=0]}\n\njulia> sign(C(2+3im))\n0.554700 + 0.832050*I {a where a = 0.554700 + 0.832050*I [13*a^4+10*a^2+13=0]}\n\njulia> angle(C(2+2im))\n0.785398 {(a)/4 where a = 3.14159 [Pi]}\n\njulia> angle(C(2+3im))\n0.982794 {a where a = 0.982794 [Arg(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}\n\njulia> angle(C(2+3im)) == atan(C(3)//2)\ntrue\n\njulia> floor(C(pi) ^ 100)\n5.18785e+49 {51878483143196131920862615246303013562686760680405}\n\njulia> ZZ(floor(C(pi) ^ 100))\n51878483143196131920862615246303013562686760680405","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Interface","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"real(a::ca)\nimag(a::ca)\nangle(a::ca)\ncsgn(a::ca)\nsign(a::ca)\nabs(a::ca)\nconj(a::ca; form::Symbol=:default)\nfloor(a::ca)\nceil(a::ca)","category":"page"},{"location":"complex/#Base.real-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.real","text":"real(a::ca)\n\nReturn the real part of a.\n\n\n\n","category":"method"},{"location":"complex/#Base.imag-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.imag","text":"imag(a::ca)\n\nReturn the imaginary part of a.\n\n\n\n","category":"method"},{"location":"complex/#Base.angle-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.angle","text":"angle(a::ca)\n\nReturn the complex argument of a.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.csgn-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.csgn","text":"csgn(a::ca)\n\nReturn the extension of the real sign function taking the value 1 strictly in the right half plane, -1 strictly in the left half plane, and the sign of the imaginary part when on the imaginary axis. Equivalently, operatornamecsgn(x) = x  sqrtx^2 except that the value is 0 at zero.\n\n\n\n","category":"method"},{"location":"complex/#Base.sign-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.sign","text":"sign(a::ca)\n\nReturn the complex sign of a, defined as zero if a is zero and as a  a for any other complex number. This function also extracts the sign when a is a signed infinity.\n\n\n\n","category":"method"},{"location":"complex/#Base.abs-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.abs","text":"abs(a::ca)\n\nReturn the absolute value of a.\n\n\n\n","category":"method"},{"location":"complex/#Base.conj-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.conj","text":"conj(a::ca; form::Symbol=:default)\n\nReturn the complex conjugate of a. The optional form argument allows specifying the representation. In :shallow form, overlinea is introduced as a new extension number if it no straightforward simplifications are possible. In :deep form, complex conjugation is performed recursively.\n\n\n\n","category":"method"},{"location":"complex/#Base.floor-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.floor","text":"floor(a::ca)\n\nReturn the floor function of a.\n\n\n\n","category":"method"},{"location":"complex/#Base.ceil-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.ceil","text":"ceil(a::ca)\n\nReturn the ceiling function of a.\n\n\n\n","category":"method"},{"location":"complex/#Elementary-and-special-functions","page":"Exact real and complex numbers","title":"Elementary and special functions","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Elementary and special functions generally create new extension numbers. In special cases, simplifications occur automatically.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> exp(C(1))\n2.71828 {a where a = 2.71828 [Exp(1)]}\n\njulia> exp(C(0))\n1\n\njulia> atan(C(1))\n0.785398 {(a)/4 where a = 3.14159 [Pi]}\n\njulia> cos(C(1))^2 + sin(C(1))^2\n1\n\njulia> log(1 // exp(sqrt(C(2))+1)) == -sqrt(C(2)) - 1\ntrue\n\njulia> gamma(C(2+3im))\n-0.0823953 + 0.0917743*I {a where a = -0.0823953 + 0.0917743*I [Gamma(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}\n\njulia> gamma(C(5) // 2)\n1.32934 {(3*a)/4 where a = 1.77245 [Sqrt(3.14159 {b})], b = 3.14159 [Pi]}\n\njulia> erf(C(1))\n0.842701 {a where a = 0.842701 [Erf(1)]}\n\njulia> erf(C(1)) + erfc(C(1))\n1","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Some functions allow representing the result in different forms:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> s1 = sin(C(1))\n0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}\n\njulia> s2 = sin(C(1), form=:direct)\n0.841471 {a where a = 0.841471 [Sin(1)]}\n\njulia> s3 = sin(C(1), form=:exponential)\n0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}\n\njulia> s4 = sin(C(1), form=:tangent)\n0.841471 {(2*a)/(a^2+1) where a = 0.546302 [Tan(0.500000 {1/2})]}\n\njulia> s1 == s2 == s3 == s4\ntrue\n\njulia> isreal(s1) && isreal(s2) && isreal(s3) && isreal(s4)\ntrue","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The exponential form is currently used by default since it tends to be the most useful for symbolic simplification. The :direct and :tangent forms are likely to be better for numerical evaluation. The default behavior of trigonometric functions can be changed using the :trig_form option of CalciumField.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Proving equalities involving transcendental function values is a difficult problem in general. Calcium will sometimes fail even in elementary cases. Here is an example of two constant trigonometric identities where the first succeeds and the second fails:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> a = sqrt(C(2)) + 1;\n\njulia> cos(a) + cos(2*a) + cos(3*a) == sin(7*a//2)//(2*sin(a//2)) - C(1)//2\ntrue\n\njulia> sin(3*a) == 4 * sin(a) * sin(C(pi)//3 - a) * sin(C(pi)//3 + a)\nERROR: Unable to perform operation (failed deciding truth of a predicate): isequal","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"A possible workaround is to fall back on a numerical comparison:","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> abs(cos(a) + cos(2*a) + cos(3*a) - (sin(7*a//2)//(2*sin(a//2)) - C(1)//2)) <= C(10)^-100\ntrue","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Of course, this is not a rigorous proof that the numbers are equal, and CalciumField is overkill here; it would be far more efficient to use ArbField directly to check that the numbers are approximately equal.","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Interface","category":"page"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"const_pi(C::CalciumField)\nconst_euler(C::CalciumField)\nonei(C::CalciumField)\nsqrt(a::ca)\nexp(a::ca)\nlog(a::ca)\npow(a::ca, b::Int; form::Symbol=:default)\nsin(a::ca; form::Symbol=:default)\ncos(a::ca; form::Symbol=:default)\ntan(a::ca; form::Symbol=:default)\natan(a::ca; form::Symbol=:default)\nasin(a::ca; form::Symbol=:default)\nacos(a::ca; form::Symbol=:default)\ngamma(a::ca)\nerf(a::ca)\nerfi(a::ca)\nerfc(a::ca)","category":"page"},{"location":"complex/#Nemo.const_pi-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"Nemo.const_pi","text":"const_pi(C::CalciumField)\n\nReturn the constant pi as an element of C.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.const_euler-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"Nemo.const_euler","text":"const_euler(C::CalciumField)\n\nReturn Euler's constant gamma as an element of C.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.onei-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"Nemo.onei","text":"onei(C::CalciumField)\n\nReturn the imaginary unit i as an element of C.\n\n\n\n","category":"method"},{"location":"complex/#Base.sqrt-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.sqrt","text":"Base.sqrt(a::ca; check::Bool=true)\n\nReturn the principal square root of a.\n\n\n\n","category":"method"},{"location":"complex/#Base.exp-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.exp","text":"exp(a::ca)\n\nReturn the exponential function of a.\n\n\n\n","category":"method"},{"location":"complex/#Base.log-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.log","text":"log(a::ca)\n\nReturn the natural logarithm of a.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.pow-Tuple{ca, Int64}","page":"Exact real and complex numbers","title":"Nemo.pow","text":"pow(a::ca, b::Int; form::Symbol=:default)\n\nReturn a raised to the integer power b. The optional form argument allows specifying the representation. In :default form, this is equivalent to a ^ b, which may create a new extension number a^b if the exponent b is too large (as determined by the parent option :pow_limit or :prec_limit depending on the case). In :arithmetic form, the exponentiation is performed arithmetically in the field of a, regardless of the size of the exponent b.\n\n\n\n","category":"method"},{"location":"complex/#Base.sin-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.sin","text":"sin(a::ca; form::Symbol=:default)\n\nReturn the sine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :exponential form, the value is represented using complex exponentials. In :tangent form, the value is represented using tangents. In :direct form, the value is represented directly using a sine or cosine.\n\n\n\n","category":"method"},{"location":"complex/#Base.cos-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.cos","text":"cos(a::ca; form::Symbol=:default)\n\nReturn the cosine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :exponential form, the value is represented using complex exponentials. In :tangent form, the value is represented using tangents. In :direct form, the value is represented directly using a sine or cosine.\n\n\n\n","category":"method"},{"location":"complex/#Base.tan-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.tan","text":"tan(a::ca; form::Symbol=:default)\n\nReturn the tangent of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :exponential form, the value is represented using complex exponentials. In :direct or :tangent form, the value is represented directly using tangents. In :sine_cosine form, the value is represented using sines or cosines.\n\n\n\n","category":"method"},{"location":"complex/#Base.atan-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.atan","text":"atan(a::ca; form::Symbol=:default)\n\nReturn the inverse tangent of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :logarithm form, the value is represented using complex logarithms. In :direct or :arctangent form, the value is represented directly using arctangents.\n\n\n\n","category":"method"},{"location":"complex/#Base.asin-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.asin","text":"asin(a::ca; form::Symbol=:default)\n\nReturn the inverse sine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :logarithm form, the value is represented using complex logarithms. In :direct form, the value is represented directly using an inverse sine or cosine.\n\n\n\n","category":"method"},{"location":"complex/#Base.acos-Tuple{ca}","page":"Exact real and complex numbers","title":"Base.acos","text":"acos(a::ca; form::Symbol=:default)\n\nReturn the inverse cosine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :logarithm form, the value is represented using complex logarithms. In :direct form, the value is represented directly using an inverse sine or cosine.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.gamma-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.gamma","text":"gamma(a::ca)\n\nReturn the gamma function of a.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.erf-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.erf","text":"erf(a::ca)\n\nReturn the error function of a.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.erfi-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.erfi","text":"erfi(a::ca)\n\nReturn the imaginary error function of a.\n\n\n\n","category":"method"},{"location":"complex/#Nemo.erfc-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.erfc","text":"erfc(a::ca)\n\nReturn the complementary error function of a.\n\n\n\n","category":"method"},{"location":"complex/#Rewriting-and-simplification","page":"Exact real and complex numbers","title":"Rewriting and simplification","text":"","category":"section"},{"location":"complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"complex_normal_form(a::ca; deep::Bool=true)","category":"page"},{"location":"complex/#Nemo.complex_normal_form-Tuple{ca}","page":"Exact real and complex numbers","title":"Nemo.complex_normal_form","text":"complex_normal_form(a::ca, deep::Bool=true)\n\nReturns the input rewritten using standardizing transformations over the complex numbers:\n\nElementary functions are rewritten in terms of exponentials, roots and logarithms.\nComplex parts are rewritten using logarithms, square roots, and (deep) complex conjugates.\nAlgebraic numbers are rewritten in terms of cyclotomic fields where applicable.\n\nIf deep is set, the rewriting is applied recursively to the tower of extension numbers; otherwise, the rewriting is only applied to the top-level extension numbers.\n\nThe result is not a normal form in the strong sense (the same number can have many possible representations even after applying this transformation), but this transformation can nevertheless be a useful heuristic for simplification.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"CurrentModule = Nemo","category":"page"},{"location":"finitefield/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Finite fields are provided in Nemo by Flint. This allows construction of finite fields of any characteristic and degree for which there are Conway polynomials. It is also possible for the user to specify their own irreducible polynomial generating a finite field.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Finite fields are constructed using the FlintFiniteField function. However, for convenience we define","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"FiniteField = FlintFiniteField","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"so that finite fields can be constructed using FiniteField rather than FlintFiniteField. Note that this is the name of the constructor, but not of finite field type.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"The types of finite field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Library Field Element type Parent type\nFlint mathbbF_p^n (small p) fq_nmod FqNmodFiniteField\nFlint mathbbF_p^n (large p) fq FqFiniteField","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"The only difference between the fq and fq_nmod types is the representation. The former is for finite fields with multiprecision characteristic and the latter is for characteristics that fit into a single unsigned machine word. The FlintFiniteField constructor automatically picks the correct representation for the user, and so the average user doesn't need to know about the actual types.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"All the finite field types belong to the FinField abstract type and the finite field element types belong to the FinFieldElem abstract type.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Since all the functionality for the fq finite field type is identical to that provided for the fq_nmod finite field type, we simply document the former.","category":"page"},{"location":"finitefield/#Finite-field-functionality","page":"Finite fields","title":"Finite field functionality","text":"","category":"section"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Finite fields in Nemo provide all the field functionality described in AbstractAlgebra:","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Below we describe the functionality that is provided in addition to this.","category":"page"},{"location":"finitefield/#Constructors","page":"Finite fields","title":"Constructors","text":"","category":"section"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"In order to construct finite field elements in Nemo, one must first construct the finite field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"FlintFiniteField","category":"page"},{"location":"finitefield/#Nemo.FlintFiniteField","page":"Finite fields","title":"Nemo.FlintFiniteField","text":"FlintFiniteField(char::Union{fmpz, Integer}, deg::Int, s::AbstractString; cached = true)\n\nReturns a tuple S x consisting of a finite field parent object S and generator x for the finite field of the given characteristic and degree. The string s is used to designate how the finite field generator will be printed. The characteristic must be prime. When a Conway polynomial is known, the field is generated using the Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. The generator of the field is guaranteed to be a multiplicative generator only if the field is generated by a Conway polynomial. We require the degree to be positive.\n\n\n\nFlintFiniteField(pol::Union{fmpz_mod_poly, gfp_fmpz_poly}, s::AbstractString; cached = true, check = true)\n\nReturns a tuple S x consisting of a finite field parent object S and generator x for the finite field over F_p defined by the given polynomial, i.e. mathbbF_pt(pol). The characteristic is specified by the modulus of pol. The polynomial is required to be irreducible, but this is not checked. The base ring of the polynomial is required to be a field, which is checked by default. Use check = false to disable the check. The string s is used to designate how the finite field generator will be printed. The generator will not be multiplicative in general.\n\n\n\n","category":"function"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Here are some examples of creating finite fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(7, 3, \"x\")\nS, y = FiniteField(ZZ(12431351431561), 2, \"y\")\nT, t = PolynomialRing(ResidueRing(ZZ, 12431351431561), \"t\")\nU, z = FiniteField(t^2 + 7, \"z\")\n\na = R(5)\nb = R(x)\nc = S(ZZ(11))\nd = U(7)","category":"page"},{"location":"finitefield/#Basic-manipulation","page":"Finite fields","title":"Basic manipulation","text":"","category":"section"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"gen(::FqFiniteField)","category":"page"},{"location":"finitefield/#AbstractAlgebra.gen-Tuple{FqFiniteField}","page":"Finite fields","title":"AbstractAlgebra.gen","text":"gen(a::FqFiniteField)\n\nReturn the generator of the finite field. Note that this is only guaranteed to be a multiplicative generator if the finite field is generated by a Conway polynomial automatically.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"isgen(::fq)","category":"page"},{"location":"finitefield/#AbstractAlgebra.isgen-Tuple{fq}","page":"Finite fields","title":"AbstractAlgebra.isgen","text":"isgen(a::fq)\n\nReturn true if the given finite field element is the generator of the finite field, otherwise return false.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"coeff(::fq, ::Int)","category":"page"},{"location":"finitefield/#AbstractAlgebra.coeff-Tuple{fq, Int64}","page":"Finite fields","title":"AbstractAlgebra.coeff","text":"coeff(x::fq, n::Int)\n\nReturn the degree n coefficient of the polynomial representing the given finite field element.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"degree(::FqFiniteField)","category":"page"},{"location":"finitefield/#AbstractAlgebra.degree-Tuple{FqFiniteField}","page":"Finite fields","title":"AbstractAlgebra.degree","text":"degree(a::FqFiniteField)\n\nReturn the degree of the given finite field.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"modulus(::FqFiniteField)","category":"page"},{"location":"finitefield/#AbstractAlgebra.modulus-Tuple{FqFiniteField}","page":"Finite fields","title":"AbstractAlgebra.modulus","text":"modulus(k::FqFiniteField, var::String=\"T\")\n\nReturn the modulus defining the finite field k.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(ZZ(7), 5, \"x\")\n\nc = gen(R)\nd = characteristic(R)\nf = order(R)\ng = degree(R)\nn = isgen(x)","category":"page"},{"location":"finitefield/#Special-functions","page":"Finite fields","title":"Special functions","text":"","category":"section"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Various special functions with finite field specific behaviour are defined.","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"tr(::fq)","category":"page"},{"location":"finitefield/#LinearAlgebra.tr-Tuple{fq}","page":"Finite fields","title":"LinearAlgebra.tr","text":"tr(x::fq)\n\nReturn the trace of x. This is an element of mathbbF_p, but the value returned is this value embedded in the original finite field.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"norm(::fq)","category":"page"},{"location":"finitefield/#LinearAlgebra.norm-Tuple{fq}","page":"Finite fields","title":"LinearAlgebra.norm","text":"norm(x::fq)\n\nReturn the norm of x. This is an element of mathbbF_p, but the value returned is this value embedded in the original finite field.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"frobenius(::fq, ::Int)","category":"page"},{"location":"finitefield/#Nemo.frobenius-Tuple{fq, Int64}","page":"Finite fields","title":"Nemo.frobenius","text":"frobenius(x::fq, n = 1)\n\nReturn the iterated Frobenius sigma_p^n(x) where sigma_p is the Frobenius map sending the element a to a^p in the finite field of characteristic p. By default the Frobenius map is applied n = 1 times if n is not specified.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"pth_root(::fq)","category":"page"},{"location":"finitefield/#Nemo.pth_root-Tuple{fq}","page":"Finite fields","title":"Nemo.pth_root","text":"pth_root(x::fq)\n\nReturn the p-th root of x in the finite field of characteristic p. This is the inverse operation to the Frobenius map sigma_p.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(ZZ(7), 5, \"x\")\n\na = x^4 + 3x^2 + 6x + 1\n\nb = tr(a)\nc = norm(a)\nd = frobenius(a)\nf = frobenius(a, 3)\ng = pth_root(a)","category":"page"},{"location":"finitefield/#Lift","page":"Finite fields","title":"Lift","text":"","category":"section"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"lift(::GFPFmpzPolyRing, ::fq)","category":"page"},{"location":"finitefield/#AbstractAlgebra.lift-Tuple{GFPFmpzPolyRing, fq}","page":"Finite fields","title":"AbstractAlgebra.lift","text":"lift(R::GFPFmpzPolyRing, x::fq)\n\nLift the finite field element x to a polynomial over the prime field.\n\n\n\n","category":"method"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(23, 2, \"x\")\nS, y = PolynomialRing(GF(23), \"y\")\n\nf = 8x + 9\n\nlift(S, f)","category":"page"},{"location":"finitefield/","page":"Finite fields","title":"Finite fields","text":"```","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"CurrentModule = Nemo","category":"page"},{"location":"fraction/#Fraction-fields","page":"Fraction fields","title":"Fraction fields","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Nemo allows the creation of fraction fields over any ring R. We don't require R to be an integral domain, however no attempt is made to deal with the general case. Two fractions ab and cd are equal in Nemo iff ad = bc. Thus, in practice, a greatest common divisor function is currently required for the ring R.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"In order to make the representation ab unique for printing, we have a notion of canonical unit for elements of a ring R. When canonicalising ab, each of the elements a and b is first divided by the canonical unit of b.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"The canonical_unit function is defined for elements of every Nemo ring. It must have the properties","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"canonical_unit(u) == u\ncanonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"for any unit u of the ring in question, and a and b arbitrary elements of the ring.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"For example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"The canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"There are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"The following table shows each of the fraction types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Frac{T} Generic.FracField{T}\nmathbbZ Flint fmpq FlintRationalField","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"All fraction element types belong to the abstract type FracElem and all of the fraction field types belong to the abstract type FracField. This enables one to write generic functions that can accept any Nemo fraction type.","category":"page"},{"location":"fraction/#Fraction-functionality","page":"Fraction fields","title":"Fraction functionality","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"All fraction types in Nemo provide funtionality for fields described in AbstractAlgebra.jl:","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"In addition all the fraction field functionality of AbstractAlgebra.jl is provided, along with generic fractions fields as described here:","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/fraction","category":"page"},{"location":"fraction/#Basic-manipulation","page":"Fraction fields","title":"Basic manipulation","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"sign(::fmpq)","category":"page"},{"location":"fraction/#Base.sign-Tuple{fmpq}","page":"Fraction fields","title":"Base.sign","text":"sign(a::fmpq)\n\nReturn the sign of a (-1, 0 or 1) as a fraction.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"height(::fmpq)","category":"page"},{"location":"fraction/#Nemo.height-Tuple{fmpq}","page":"Fraction fields","title":"Nemo.height","text":"height(a::fmpq)\n\nReturn the height of the fraction a, namely the largest of the absolute values of the numerator and denominator.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"height_bits(::fmpq)","category":"page"},{"location":"fraction/#Nemo.height_bits-Tuple{fmpq}","page":"Fraction fields","title":"Nemo.height_bits","text":"height_bits(a::fmpq)\n\nReturn the number of bits of the height of the fraction a.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"<<(::fmpq, ::Int)","category":"page"},{"location":"fraction/#Base.:<<-Tuple{fmpq, Int64}","page":"Fraction fields","title":"Base.:<<","text":"<<(a::fmpq, b::Int)\n\nReturn a times 2^b.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":">>(::fmpq, ::Int)","category":"page"},{"location":"fraction/#Base.:>>-Tuple{fmpq, Int64}","page":"Fraction fields","title":"Base.:>>","text":">>(a::fmpq, b::Int)\n\nReturn a2^b.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"floor(::fmpq)\nceil(::fmpq)","category":"page"},{"location":"fraction/#Base.floor-Tuple{fmpq}","page":"Fraction fields","title":"Base.floor","text":"floor(a::fmpq)\n\nReturn the greatest integer that is less than or equal to a. The result is returned as a rational with denominator 1.\n\n\n\n","category":"method"},{"location":"fraction/#Base.ceil-Tuple{fmpq}","page":"Fraction fields","title":"Base.ceil","text":"ceil(a::fmpq)\n\nReturn the least integer that is greater than or equal to a. The result is returned as a rational with denominator 1.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"d = abs(ZZ(11)//3)\n4 <= ZZ(7)//ZZ(3)","category":"page"},{"location":"fraction/#Modular-arithmetic","page":"Fraction fields","title":"Modular arithmetic","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"The following functions are available for rationals.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"mod(a::fmpq, b::fmpz)","category":"page"},{"location":"fraction/#Base.mod-Tuple{fmpq, fmpz}","page":"Fraction fields","title":"Base.mod","text":"mod(a::fmpq, b::fmpz)\n\nReturn a pmodb where b is an integer coprime to the denominator of a.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"mod(a::fmpq, b::Integer)","category":"page"},{"location":"fraction/#Base.mod-Tuple{fmpq, Integer}","page":"Fraction fields","title":"Base.mod","text":"mod(a::fmpq, b::Integer)\n\nReturn a pmodb where b is an integer coprime to the denominator of a.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"a = -fmpz(2)//3\nb = fmpz(1)//2\n\nc = mod(a, 7)\nd = mod(b, fmpz(5))","category":"page"},{"location":"fraction/#Rational-Reconstruction","page":"Fraction fields","title":"Rational Reconstruction","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Rational reconstruction is available for rational numbers.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"reconstruct(::fmpz, ::fmpz)\nreconstruct(::fmpz, ::Integer)\nreconstruct(::Integer, ::fmpz)\nreconstruct(::Integer, ::Integer)","category":"page"},{"location":"fraction/#Nemo.reconstruct-Tuple{fmpz, fmpz}","page":"Fraction fields","title":"Nemo.reconstruct","text":"reconstruct(a::fmpz, b::fmpz)\n\nAttempt to return a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"fraction/#Nemo.reconstruct-Tuple{fmpz, Integer}","page":"Fraction fields","title":"Nemo.reconstruct","text":"reconstruct(a::fmpz, b::Integer)\n\nAttempt to return a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"fraction/#Nemo.reconstruct-Tuple{Integer, fmpz}","page":"Fraction fields","title":"Nemo.reconstruct","text":"reconstruct(a::Integer, b::fmpz)\n\nAttempt to find a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"fraction/#Nemo.reconstruct-Tuple{Integer, Integer}","page":"Fraction fields","title":"Nemo.reconstruct","text":"reconstruct(a::Integer, b::Integer)\n\nAttempt to return a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"a = reconstruct(7, 13)\nb = reconstruct(fmpz(15), 31)\nc = reconstruct(fmpz(123), fmpz(237))","category":"page"},{"location":"fraction/#Rational-enumeration","page":"Fraction fields","title":"Rational enumeration","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Various methods exist to enumerate rationals.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_minimal(::fmpq)","category":"page"},{"location":"fraction/#Nemo.next_minimal-Tuple{fmpq}","page":"Fraction fields","title":"Nemo.next_minimal","text":"next_minimal(a::fmpq)\n\nGiven a, return the next rational number in the sequence obtained by enumerating all positive denominators q, and for each q enumerating the numerators 1 le p  q in order and generating both pq and qp, but skipping all gcd(pq) neq 1. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being 0 1 12 2 13 3 23 32 14 4 34 43 ldots. This enumeration produces the rational numbers in order of minimal height. It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If a  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_signed_minimal(::fmpq)","category":"page"},{"location":"fraction/#Nemo.next_signed_minimal-Tuple{fmpq}","page":"Fraction fields","title":"Nemo.next_signed_minimal","text":"next_signed_minimal(a::fmpq)\n\nGiven a signed rational number a assumed to be in canonical form, return the next element in the minimal-height sequence generated by next_minimal but with negative numbers interleaved. The sequence begins 0 1 -1 12 -12 2 -2 13 -13 ldots. Starting with zero, this generates every rational number once and only once, in order of minimal height.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_calkin_wilf(::fmpq)","category":"page"},{"location":"fraction/#Nemo.next_calkin_wilf-Tuple{fmpq}","page":"Fraction fields","title":"Nemo.next_calkin_wilf","text":"next_calkin_wilf(a::fmpq)\n\nReturn the next number after a in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being 0 1 12 2 13 32 23 3 14 43 35 52 25 ldots. Despite the appearance of the initial entries, the Calkin-Wilf enumeration does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_signed_calkin_wilf(::fmpq)","category":"page"},{"location":"fraction/#Nemo.next_signed_calkin_wilf-Tuple{fmpq}","page":"Fraction fields","title":"Nemo.next_signed_calkin_wilf","text":"next_signed_calkin_wilf(a::fmpq)\n\nGiven a signed rational number a returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins 0 1 -1 12 -12 2 -2 13 -13 ldots. Starting with zero, this generates every rational number once and only once, but not in order of minimal height.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_minimal(fmpz(2)//3)\nnext_signed_minimal(-fmpz(21)//31)\nnext_calkin_wilf(fmpz(321)//113)\nnext_signed_calkin_wilf(-fmpz(51)//(17))","category":"page"},{"location":"fraction/#Random-generation","page":"Fraction fields","title":"Random generation","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"rand_bits(::FlintRationalField, b::Int)","category":"page"},{"location":"fraction/#Nemo.rand_bits-Tuple{FlintRationalField, Int64}","page":"Fraction fields","title":"Nemo.rand_bits","text":"rand_bits(::FlintRationalField, b::Int)\n\nReturn a random signed rational whose numerator and denominator both have b bits before canonicalisation. Note that the resulting numerator and denominator can be smaller than b bits.\n\n\n\n","category":"method"},{"location":"fraction/#Special-functions","page":"Fraction fields","title":"Special functions","text":"","category":"section"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"The following special functions are available for specific rings in Nemo.","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"harmonic(::Int)","category":"page"},{"location":"fraction/#Nemo.harmonic-Tuple{Int64}","page":"Fraction fields","title":"Nemo.harmonic","text":"harmonic(n::Int)\n\nReturn the harmonic number H_n = 1 + 12 + 13 + cdots + 1n. Table lookup is used for H_n whose numerator and denominator fit in a single limb. For larger n, a divide and conquer strategy is used.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"bernoulli(::Int)","category":"page"},{"location":"fraction/#Nemo.bernoulli-Tuple{Int64}","page":"Fraction fields","title":"Nemo.bernoulli","text":"bernoulli(n::Int)\n\nReturn the Bernoulli number B_n for nonnegative n.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"bernoulli_cache(::Int)","category":"page"},{"location":"fraction/#Nemo.bernoulli_cache-Tuple{Int64}","page":"Fraction fields","title":"Nemo.bernoulli_cache","text":"bernoulli_cache(n::Int)\n\nPrecomputes and caches all the Bernoulli numbers up to B_n. This is much faster than repeatedly calling bernoulli(k). Once cached, subsequent calls to bernoulli(k) for any k le n will read from the cache, making them virtually free.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"dedekind_sum(::fmpz, ::fmpz)","category":"page"},{"location":"fraction/#Nemo.dedekind_sum-Tuple{fmpz, fmpz}","page":"Fraction fields","title":"Nemo.dedekind_sum","text":"dedekind_sum(h::fmpz, k::fmpz)\n\nReturn the Dedekind sum s(hk) for arbitrary h and k.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"a = harmonic(12)\n\nb = dedekind_sum(12, 13)\nc = dedekind_sum(-120, fmpz(1305))\n\nd = bernoulli(12)\n\nbernoulli_cache(100)\ne = bernoulli(100)","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"simplest_between(::fmpq, ::fmpq)","category":"page"},{"location":"fraction/#Nemo.simplest_between-Tuple{fmpq, fmpq}","page":"Fraction fields","title":"Nemo.simplest_between","text":"  simplest_between(l::fmpq, r::fmpq)\n\nReturn the simplest fraction in the closed interval l r. A canonical fraction a_1  b_1 is defined to be simpler than a_2  b_2 if and only if b_1  b_2 or b_1 = b_2 and a_1  a_2.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Fraction fields","title":"Fraction fields","text":"simplest_between(fmpq(1//10), fmpq(3//10))","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"CurrentModule = Nemo","category":"page"},{"location":"developer/introduction/#Introduction-to-Nemo-development","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"","category":"section"},{"location":"developer/introduction/#Relationship-to-AbstractAlgebra.jl","page":"Introduction to Nemo development","title":"Relationship to AbstractAlgebra.jl","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Some time in the past, Nemo was split into two packages called Nemo.jl and AbstractAlgebra.jl. The purpose was to provide a Julia only package which did some subset of what Nemo could do, albeit slower. This was requested by people in the Julia community.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Unfortunately this hasn't been terribly successful. Most Julia developers expect that AbstractAlgebra and Nemo functionality will work for Julia matrices over AbstractAlgebra/Nemo rings. This would be possible for functions that do not conflict with Base or LinearAlgebra at least when working with non-empty matrices. However, for reasons that we explain in both the Appendix to the AbstractAlgebra package and in the parent object section of the developer documentation, this is not possible even in theory for functions that would conflict with Julia's standard library or for empty matrices (except in a limited number of special cases).","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Unfortunately the Julia standard library functions do not work with matrices of Nemo objects and there is little we can do about this. Moreover, some Julia functionality isn't supported by the underlying C libraries in Nemo and would be difficult or impossible to provide on the C side.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Nowadays we see AbstractAlgebra to provide three things to Nemo:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"An abstract type hierarchy\nGeneric ring constructions, e.g. generic polynomials and matrices\nGeneric implementations that should work for any ring implementing the required interfaces. These interfaces are documented in the AbstractAlgebra documentation.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Nemo itself is now more or less just a wrapper of four C libraries:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Flint : polynomials and matrices over Z, Q, Z/nZ, Qp, Fq\nArb : polynomials, matrices and special functions over balls over R and C\nAntic : algebraic number field element arithmetic\nCalcium : exact real and complex numbers, including algebraic numbers","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Each ring implemented in those C libraries is wrapped in such a way as to implement the interfaces described by AbstractAlgebra.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Most of the time an AbstractAlgebra implementation will work just as well using Nemo, but the latter will usually be faster, due to the extremely performant C code (around half a million lines of it).","category":"page"},{"location":"developer/introduction/#Layout-of-files","page":"Introduction to Nemo development","title":"Layout of files","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the src directory of Nemo are four directories flint, arb, antic and calcium, each containing the wrappers for the relevant C libraries. The test directory is similarly organised.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Within each of these directories is a set of files, one per module within the C libraries, e.g. the fmpz.jl file wraps the Flint fmpz module for multiple precision integers. The fmpz_poly.jl file wraps the Flint univariate polynomials over fmpz integers, and so on.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The fmpq prefix is for Flint rationals, fq for Flint finite fields with multiprecision characteristic, fq_nmod is the same but for single word characteristic. The padic prefix is for the field of p-adic numbers for a given p. The nmod prefix is for Z/nZ for a given n. The gfp prefix is the same as Z/nZ but where n is prime, so that we are dealing with a field.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The FlintTypes.jl file contains the implementation of all the Flint types.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the antic directory, nf_elem is for elements of a number field.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The AnticTypes.jl file contains the Antic types.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the arb directory the arb prefix is for arbitrary precision ball arithmetic over the reals. The acb prefix is similar but for complex numbers.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The ArbTypes.jl file contains the Arb types.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the calcium directory the ca prefix is for Calcium's type. There is also a qqbar file for the field of algebraic numbers.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the AbstractAlgebra.jl package the src directory contains a directory called generic. This is where the implementations of generic types, such as matrices, polynomials, series, etc. reside. Each file such as Matrix.jl corresponds to a generic group/ring/field or other algebraic construction (typically over a base ring). The files in this directory exist inside a submodule of AbstractAlgebra called Generic.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The file GenericTypes.jl is where all the generic types are implemented.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"At the top level of the src directory is a file Generic.jl which is where the Generic submodule of AbstractAlgebra begins and where imports are made from AbstractAlgebra into Generic.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the src directory we have implementations that work for every type belonging to a given abstract type, e.g. Matrix.jl has implementations that will work for any matrix type, whether from AbstractAlgebra's Generic module or even matrix types from Nemo, and so on. So long as they are implemented to provide the Matrix interface all the functions there will work for them. The same applies for Poly.jl for polynomial types, AbsSeries.jl for absolute series types, RelSeries.jl for relative series types, etc.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the src directory is AbstractTypes.jl where all the AbstractAlgebra abstract types are defined.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Also in the src directory is a subdirectory called Julia. This is where we give our own implementations of functionality for Julia Integers and Rationals and various other basic rings implemented in terms of Julia types. These are provided so that the package will work as a pure Julia package, replacing many of the rings and fields that would be available in Flint and the other C libraries with Julia equivalents.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Note that some of the implementations we give there would conflict with Base and so are only available inside AbstractAlgebra and are not exported!","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"We try to keep the test directory at the top level of the source tree organised in the same manner as the other directories just discussed, though there is currently no split between tests for Generic and for the implementations in src. All tests are currently combined in test/generic..","category":"page"},{"location":"developer/introduction/#Git,-GitHub-and-project-workflows","page":"Introduction to Nemo development","title":"Git, GitHub and project workflows","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The official repositories for AbstractAlgebra and Nemo are:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/Nemocas/AbstractAlgebra.jl","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/Nemocas/Nemo.jl","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"If you wish to contribute to these projects, the first step is to fork them on GitHub. The button for this is in the upper right of the main project page. You will need to sign up for a free GitHub account to do this.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Once you have your own GitHub copy of our repository you can push changes to it from your local machine and this will make them visible to the world.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Before sinking a huge amount of time into a contribution, please open a ticket on the official project page on GitHub explaining what you intend to do and discussing it with the other developers.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The easiest way to get going with development on your local machine is to dev AbstractAlgebra and/or Nemo. To do this, press the ] key in Julia to enter the special package mode and type:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"dev Nemo","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Now you will find a local copy on your machine of the Nemo repository in","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":".julia/dev/Nemo","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"However, this will be set up to push to the official repository instead of your own, so you will need to change this. For example, if your GitHub account name is myname, edit the .git/config file in your local Nemo directory to say:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"        url = https://github.com/Nemocas/Nemo.jl.git\n        pushurl = https://github.com/myname/Nemo.jl","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"instead of just the first line which will already be there.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"It is highly recommended that you do not work in the master branch, but create a new branch for each thing you want to contribute to Nemo.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"git checkout -b mynewbranch","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"If your contribution is small and does not take a long time to implement, everything will likely be fine if you simply commit the changes locally, then push them to your GitHub account online:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"git commit -a\ngit push --all","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"However, if you are working on a much larger project it is highly recommended that you frequently pull from the official master branch and rebase your new branch on top of any changes that have been made there:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"git checkout master\ngit pull\ngit checkout mynewbranch\ngit rebase master","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Note that rebasing will try to rewrite each of your commits over the top of the branch you are rebasing on (master in this case). This process will have many steps if there are many commits and lots of conflicts. Simply follow the instructions until the process is finished.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The longer you leave it before rebasing on master the longer the rebase process will take. It can eventually become overwhelming as it is not replaying the latest state of your repository over master, but each commit that you made in order. You may have completely forgotten what those older commits were about, so this can become very difficult if not done regularly.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Once you have pushed your changes to your GitHub account, go to the official project GitHub page and you should see your branch mentioned near the top of the page. Open a pull request.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Someone will review your code and suggest changes they'd like made. Simply add more commits to your branch and push again. They will automatically get added to your pull request.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Note that we don't accept code without tests and documentation. We use Documenter.jl for our documentation, in Markdown format. See our existing code for examples of docstrings above functions in the source code and look in the docs/src directory to see how these docstrings are merged into our online documentation.","category":"page"},{"location":"developer/introduction/#Development-list","page":"Introduction to Nemo development","title":"Development list","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"All developers of AbstractAlgebra and Nemo are welcome to write to our development list to ask questions and discuss development:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://groups.google.com/g/nemo-devel","category":"page"},{"location":"developer/introduction/#Reporting-bugs","page":"Introduction to Nemo development","title":"Reporting bugs","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Bugs should be reported by opening an issue (ticket) on the official GitHub page for the relevant project. Please state the Julia version being used, the machine you are using and the version of AbstractAlgebra/Nemo you are using. The version can be found in the Project.toml file at the top level of the source tree.","category":"page"},{"location":"developer/introduction/#Development-roadmap","page":"Introduction to Nemo development","title":"Development roadmap","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"AbstractAlgebra has a special roadmap ticket which lists the most important tickets that have been opened. If you want to contribute something high value this is the place to start:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/Nemocas/AbstractAlgebra.jl/issues/492","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"This ticket is updated every so often.","category":"page"},{"location":"developer/introduction/#Binaries","page":"Introduction to Nemo development","title":"Binaries","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Binaries of C libraries for Nemo are currently made in a separate repository:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/JuliaPackaging/Yggdrasil","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"If code is added to any of the C libraries used by Nemo, this jll package must be updated first and the version updated in Nemo.jl before the new functionality can be used. Ask the core developers for help with this as various other tasks must be completed at the same time.","category":"page"},{"location":"developer/introduction/#Relationship-to-Oscar","page":"Introduction to Nemo development","title":"Relationship to Oscar","text":"","category":"section"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Nemo and AbstractAlgebra are heavily used by the Oscar computer algebra system being developed in Germany by a number of universities involved in a large project known as TRR 195, funded by the DFG.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Oscar is the number one customer for Nemo. Many bugs in Nemo are found and fixed by Oscar developers and most of the key Nemo developers are part of the Oscar project.","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"See the Oscar website for further details:","category":"page"},{"location":"developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://oscar.computeralgebra.de/","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"CurrentModule = Nemo","category":"page"},{"location":"developer/typesystem/#The-type-system","page":"The type system","title":"The type system","text":"","category":"section"},{"location":"developer/typesystem/#Use-of-Julia-types-in-Nemo","page":"The type system","title":"Use of Julia types in Nemo","text":"","category":"section"},{"location":"developer/typesystem/#Concrete-and-abstract-types","page":"The type system","title":"Concrete and abstract types","text":"","category":"section"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Julia does not provide a traditional class/inheritance approach to programming. Instead, the basic unit of its object oriented approach is the type definition (struct and mutable struct) and inheritance exists only on the function side of the language rather than data side. Julia provides a rich system of abstract types and unions on the data side and multimethods on the function side to effect this.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"For example Julia's Number type is an abstract type containing all concrete types that behave like numbers, e.g. Int64, Float64, and so on.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Abstract types can also belong to other abstract types, forming a tree of abstract types.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"In Nemo the most important abstract types are Ring and Field, with the latter belonging to the former so that all fields are rings, and the abstract types RingElem and FieldElem for the objects that represent elements of rings and fields, again with the latter abstract type belonging to the former.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Because this hierarchy of abstract types must form a tree, Julia is strictly speaking single inheritance, as each concrete and abstract type can belong to at most one other abstract type. For example, one could not have a diamond of abstract types with ExactField belonging to both Field and ExactRing.","category":"page"},{"location":"developer/typesystem/#Recovering-aspects-of-multiple-inheritance-in-Nemo","page":"The type system","title":"Recovering aspects of multiple inheritance in Nemo","text":"","category":"section"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Various possibilities exist to get around the limitation that abstract types must form a 'tree' in Nemo and AbstractAlgebra.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"One such possibility is union types. If a function should accept one of a number of concrete or abstract types that can't all be made to belong to a single abstract type due to this limitation then one can use a union type.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"For example, Nemo defines RingElement to be a union of RingElem and all the Julia standard types which behave like ring elements, e.g. all Integer types and types of rationals with Integer components.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Other union types are defined in src/AbstractAlgebra.jl in AbstractAlgebra.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"A second feature we make use of in Nemo is parameterised types. Each concrete and abstract type can take one or more parameters. These parameter can be any other type, either concrete or abstract. For example, in Julia Rational{T} is for rationals with numerator and denominator of type T.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"A great deal of control over parameterised types is possible, e.g. one can restrict the type parameter T using a where clause, e.g. to write a function that accepts all rational types with integer components of the same type one can use the type Rational{T} where T <: Integer.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Nemo makes use of such parameterised types for generic ring constructions such as generic polynomial rings and matrices over a given base ring. The type of the elements of the base ring is substituted for the parameter T in any concrete instantiation of the types Poly{T} and Mat{T}, which are defined in AbstractAlgebra in src/generic/GenericTypes.jl.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The totality of all univariate polynomial types, including those of generic Poly{T} types and those coming from C libraries (such as fmpz_poly), is represented by the abstract type PolyElem{T} which in turn belongs to RingElem, both defined in AbstractAlgebra in src/AbstractTypes.jl.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Similarly, the totality of all matrix types, including explicit C types like fmpz_mat and the generic Mat{T} types is given by the abstract type MatElem{T}, again defined in AbstractAlgebra in src/AbstractTypes.jl.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"This hierarchy of types allows one to write functions at any level, e.g. for all univariate polynomial types, just those with a given base type T, or for a specific concrete type corresponding to just one kind of univariate polynomial.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"A third possibility to get around the single inheritance limitation of Julia is type traits. There is currently no explicit compiler/language support for traits, however various implementations exist that make use of type parameters in tricky ways. This allows one to add 'traits' to types, so long as those traits can be expressed as types. In this way, types can have multiple 'properties' at the same time, instead of belonging to just a single abstract type.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Nemo does not currently use type traits, though the map types in Nemo do make use of a custom analogue of this.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Note that unlike class based systems that dispatch on the type of a (sometimes implicit) this or self parameter, Julia methods dispatch on the type of all arguments. This is a natural fit for mathematics where all sorts of ad hoc left and right operations may be required.","category":"page"},{"location":"developer/typesystem/#Encapsulation,-maps-and-runtime-flags","page":"The type system","title":"Encapsulation, maps and runtime flags","text":"","category":"section"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"One limitation of the Julia approach is that the type of an object cannot be changed at runtime. For example one might like to insist that a given ring is in fact a field. There are three standard ways to handle this in Julia.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The first approach is to encapsulate the object in another object which does have the desired type. The second approach is to map the object to a different one of the required type (e.g. by applying a morphism). The third approach is to introduce data fields in the original type which can be changed at runtime, unlike its type. All three approaches come with downsides. ","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Encapsulation can be time consuming for the developer as methods which applied to the original object do not automatically apply to the encapsulated object. One can write methods which do, but this is not automatic.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Application of a map may come with a performance penalty and may be difficult for the user to navigate. Moreover, mutation of the resulting object does not result in mutation of the original object.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The third option of adding runtime data fields essentially takes one back to writing a (possibly bug ridden) interpreter. It relies on the developer  implementing outer methods that make use of hand written control statements to determine which of a range of inner methods should be applied to the object. This misses the benefits of one of the main defining features of Julia, namely its multimethod system and can also make introspection more difficult.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Nemo does not apply any of these three approaches widely at present, though information which can only be known at runtime such as whether a ring is Euclidean will eventually have to be encoded using one of these three methods.","category":"page"},{"location":"developer/typesystem/#Nemo's-custom-map-types","page":"The type system","title":"Nemo's custom map types","text":"","category":"section"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"It makes sense that map types in Nemo should be parameterised by the element types of both the domain and codomain of the map, and of course all maps in the system should somehow belong to an abstract type Map.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"This leads one to consider a two parameter system of types Map{D, C} where D and C are the domain and codomain types respectively.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"One may also wish to implement various types of map, e.g. linear maps (where the map contains a matrix representing the map) or functional maps (where the map is implemented by a Julia function) and so on. Notionally one imagines doing this with a hierarchy of two parameter abstract types all ultimately belonging to Map{D, C} as the root of the tree.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"This approach begins to break down when constructions from homological algebra begin to be applied to maps. In such cases, the maps themselves are the object of study and functions may be applied to maps to produce other maps.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The simplest such function is composition. In a system where composition of maps always results in a map of the same type, no problem arises with the straightforward approach outlined above.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"However, for various reasons (including performance) it may not be desirable or even possible to construct a composition of two given maps using the same representation as the original maps. This means that the result of composing two maps of the same type may be a map of a different type, e.g. in the worst case a general composition type.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"This problem makes many homological and category theoretic operations on maps difficult or impossible to implement.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Other operations which may be desirable to implement are caching of maps (e.g. where the map is extremely time consuming to compute, such as discrete logarithms) and attaching category theoretic information to maps. Such operations can be effected by encapsulating existing maps in objects containing the extra information, e.g. a cache or a category. However all the methods that applied to the original map objects now no longer apply to the encapsulated objects.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"To work around these limitations Nemo implements a four parameter Map type, Map{D, C, T, U}.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The first two parameters are the domain and codomain types as discussed above.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The parameter T is a \"map class\" which is itself an abstract type existing in a hierarchy of abstract types. This parameter is best thought of as a trait, independent of the hierarchy of abstract types belonging to Map, giving additional flexibility to the map types in the system.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"For example, T may be set to LinearMap or FunctionalMap. This may be useful if one wishes to distinguish maps in other ways, e.g. whether they are homomorphisms, isomorphisms, maps with section or retraction etc. As usual, offering traits partially gets around the single inheritance problem.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The final parameter U is used to allow maps of a given type U to be composed and still result in a map of type U, even though the concrete type of the composition is different to that of the original maps. Methods can be written for all maps of type U by matching this parameter, rather than matching on the concrete type U of the original maps.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"For example, two maps with concrete type MyRingHomomorphism would belong to Map{D, C, T, MyRingHomomorphism} as would any composition of such maps, even if the concrete type of the composition was not a MyRingHomomorphism.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Naturally four parameter types are rather unwieldy and so various helper functions are provided to compute four parameter map types. In the first instance one still has the type Map{D, C} which will give the union of all map types whose first two parameters are D and C, and where the remaining two parameters are arbitrary.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"However one can also pass a map class or a concrete type U to a Map function to compute the class of all maps of the given map class or type.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"For example, to write a function which accepts all maps of \"type\" MyRingHomomorphism, including all compositions of such maps, one inserts Map(MyRingHomomorphism) in place of the type, e.g.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"function myfun(f::Map(MyRingHomomorphism))","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Note the parentheses here, rather than curly braces; it's a function to compute a type! Now the function myfun will accept any map type whose fourth parameter U is set to MyRingHomomorphism.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"This four parameter system is flexible, but may need to be expanded in the future. For example it may be useful to have more than one trait T. This could be achieved either by making T a tuple of traits or by introducing a parameterised MapTrait type which can be placed at that location. Naturally the Map functions for computing the four parameter types will have to be similarly expanded to make it easier for the user.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The map type system is currently considered experimental and our observation so far is that it is not intuitive for developers.","category":"page"},{"location":"developer/typesystem/#Type-hierarchy-diagram","page":"The type system","title":"Type hierarchy diagram","text":"","category":"section"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"The most important abstract types in the system are the element types. Their hierarchy is shown in the following diagram.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"(Image: alt text)","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"Most of the element types have a corresponding parent abstract type. These are shown in the following diagram.","category":"page"},{"location":"developer/typesystem/","page":"The type system","title":"The type system","text":"(Image: alt text)","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"CurrentModule = Nemo","category":"page"},{"location":"series/#Power-series-and-Laurent-series","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"","category":"section"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Nemo allows the creation of capped relative and absolute power series over any computable ring R. Capped relative power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_k-1x^k-1 + O(x^k) where j geq 0, a_j in R and the relative precision k - j is at most equal to some specified precision n. On the other hand capped absolute power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_n-1x^n-1 + O(x^n) where j geq 0, a_j in R and the precision n is fixed.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The following table shows each of the relative power series types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl `Generic.RelSeries{T} Generic.RelSeriesRing{T}\nmathbbZ Flint fmpz_rel_series FmpzRelSeriesRing\nmathbbZnmathbbZ (small n) Flint nmod_rel_series NmodRelSeriesRing\nmathbbZnmathbbZ (large n) Flint fmpz_mod_rel_series FmpzModRelSeriesRing\nmathbbQ Flint fmpq_rel_series FmpqRelSeriesRing\nmathbbF_p (small n) Flint gfp_rel_series GFPRelSeriesRing\nmathbbF_p (large n) Flint gfp_fmpz_rel_series GFPFmpzRelSeriesRing\nmathbbF_p^n (small p) Flint fq_nmod_rel_series FqNmodRelSeriesRing\nmathbbF_p^n (large p) Flint fq_rel_series FqRelSeriesRing","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All relative power series elements belong to the abstract type RelSeriesElem and all of the relative power series ring types belong to the abstract type RelSeriesRing.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The maximum relative precision, the string representation of the variable and the base ring R of a generic power series are stored in its parent object. ","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Here is the corresponding table for the absolute power series types.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.AbsSeries{T} Generic.AbsSeriesRing{T}\nmathbbZ Flint fmpz_abs_series FmpzAbsSeriesRing\nmathbbZnmathbbZ (small n) Flint nmod_abs_series NmodAbsSeriesRing\nmathbbZnmathbbZ (large n) Flint fmpz_mod_abs_series FmpzModAbsSeriesRing\nmathbbQ Flint fmpq_abs_series FmpqAbsSeriesRing\nmathbbF_p (small n) Flint gfp_abs_series GFPAbsSeriesRing\nmathbbF_p (large n) Flint gfp_fmpz_abs_series GFPFmpzAbsSeriesRing\nmathbbF_p^n (small n) Flint fq_nmod_abs_series FqNmodAbsSeriesRing\nmathbbF_p^n (large n) Flint fq_abs_series FqAbsSeriesRing","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All absolute power series elements belong to the abstract type AbsSeriesElem and all of the absolute power series ring types belong to the abstract type AbsSeriesRing.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The absolute precision, the string representation of the variable and the base ring R of a generic power series are stored in its parent object. ","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All power series element types belong to the abstract type SeriesElem and all of the power series ring types belong to the abstract type SeriesRing. This enables one to write generic functions that can accept any Nemo power series type.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"AbstractAlgebra.jl also provides Nemo with a generic implementation of Laurent series over a given ring R. For completeness, we list it here.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.LaurentSeriesRingElem{T} Generic.LaurentSeriesRing{T}\nGeneric field K AbstractAlgebra.jl Generic.LaurentSeriesFieldElem{T} ","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Generic.LaurentSeriesField{T}","category":"page"},{"location":"series/#Capped-relative-power-series","page":"Power series and Laurent series","title":"Capped relative power series","text":"","category":"section"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Capped relative power series have their maximum relative precision capped at some value prec_max. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form  c_ax^a + c_a+1x^a+1 + ldots + O(x^a + b).","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The zero power series is simply taken to be 0 + O(x^b).","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series f and g we have that divexact(f*g), g) == f.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"However, capped relative power series are not additively stable, i.e. we do not always have (f + g) - g = f.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"In the capped relative model we say that two power series are equal if they agree up to the minimum absolute precision of the two power series. Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"During computations, it is possible for power series to lose relative precision due to cancellation. For example if f = x^3 + x^5 + O(x^8) and g = x^3 + x^6 + O(x^8) then f - g = x^5 - x^6 + O(x^8) which now has relative precision 3 instead of relative precision 5.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Amongst other things, this means that equality is not transitive. For example x^6 + O(x^11) == 0 + O(x^5) and x^7 + O(x^12) == 0 + O(x^5) but x^6 + O(x^11) neq x^7 + O(x^12).","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in y over the power series ring in x over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of (0 + O(x^10))y + (1 + O(x^10))?","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"If one takes it to be (0 + O(x^10)) then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!","category":"page"},{"location":"series/#Capped-absolute-power-series","page":"Power series and Laurent series","title":"Capped absolute power series","text":"","category":"section"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"An absolute power series ring over a ring R with precision p behaves  very much like the quotient Rx(x^p) of the polynomial ring over R.","category":"page"},{"location":"series/#Power-series-functionality","page":"Power series and Laurent series","title":"Power series functionality","text":"","category":"section"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Power series rings in Nemo provide all the functionality described for power series in AbstractAlgebra:","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/series","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"In addition, generic power series and Laurent series are provided by AbstractAlgebra.","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"We list below only the functionality that is Nemo specific for power series rings.","category":"page"},{"location":"series/#Special-functions","page":"Power series and Laurent series","title":"Special functions","text":"","category":"section"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"log(a::fmpq_rel_series)","category":"page"},{"location":"series/#Base.log-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.log","text":"log(a::fmpq_rel_series)\n\nReturn log(a). Requires the constant term to be one.\n\n\n\n","category":"method"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base.sqrt(a::fmpq_rel_series)","category":"page"},{"location":"series/#Base.sqrt-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.sqrt","text":"sqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nBase.sqrt(f::PolyElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\nsqrt(a::RelSeriesElem)\n\nReturn the square root of the power series a. By default the function raises an exception if the input is not a square. If check=false this check is omitted.\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"tan(a::fmpq_rel_series)\ntanh(a::fmpq_rel_series)\nsin(a::fmpq_rel_series)\nsinh(a::fmpq_rel_series)\ncos(a::fmpq_rel_series)\ncosh(a::fmpq_rel_series)","category":"page"},{"location":"series/#Base.tan-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.tan","text":"tan(a::fmpq_rel_series)\n\nReturn tan(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.tanh-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.tanh","text":"tanh(a::fmpq_rel_series)\n\nReturn tanh(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.sin-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.sin","text":"sin(a::fmpq_rel_series)\n\nReturn sin(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.sinh-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.sinh","text":"sinh(a::fmpq_rel_series)\n\nReturn sinh(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.cos-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.cos","text":"cos(a::fmpq_rel_series)\n\nReturn cos(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.cosh-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.cosh","text":"cosh(a::fmpq_rel_series)\n\nReturn cosh(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"asin(a::fmpq_rel_series)\nasinh(a::fmpq_rel_series)\natan(a::fmpq_rel_series)\natanh(a::fmpq_rel_series)","category":"page"},{"location":"series/#Base.asin-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.asin","text":"asin(a::fmpq_rel_series)\n\nReturn asin(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.asinh-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.asinh","text":"asinh(a::fmpq_rel_series)\n\nReturn asinh(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.atan-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.atan","text":"atan(a::fmpq_rel_series)\n\nReturn atan(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/#Base.atanh-Tuple{fmpq_rel_series}","page":"Power series and Laurent series","title":"Base.atanh","text":"atanh(a::fmpq_rel_series)\n\nReturn atanh(a). Requires a zero constant term.\n\n\n\n","category":"method"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Examples","category":"page"},{"location":"series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"S, x = PowerSeriesRing(R, 30, \"x\")\nT, z = PowerSeriesRing(QQ, 30, \"z\")\n\na = 1 + z + 3z^2 + O(z^5)\nb = z + 2z^2 + 5z^3 + O(z^5)\n\nd = divexact(x, exp(x + O(x^40)) - 1)\nf = exp(b)\ng = log(a)\nh = sqrt(a)\nk = sin(b)\nm = atanh(b)","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"CurrentModule = Nemo","category":"page"},{"location":"algebraic/#Algebraic-numbers","page":"Algebraic numbers","title":"Algebraic numbers","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Nemo allows working with exact real and complex algebraic numbers.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The default algebraic number type in Nemo is provided by Calcium. The associated field of algebraic numbers is represented by the constant parent object called CalciumQQBar.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"For convenience we define","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"QQBar = CalciumQQBar","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"so that algebraic numbers can be constructed using QQBar instead of CalciumQQBar. Note that this is the name of a specific parent object, not the name of its type.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Library Element type Parent type\nCalcium qqbar CalciumQQBarField","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Important note on performance","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The default algebraic number type represents algebraic numbers in canonical form using minimal polynomials. This works well for representing individual algebraic numbers, but it does not provide the best performance for field arithmetic. For fast calculation in overlinemathbbQ, CalciumField should typically be used instead (see the section on Exact real and complex numbers). Alternatively, to compute in a fixed subfield of overlinemathbbQ, you may fix a generator a and construct an Antic number field to represent mathbbQ(a).","category":"page"},{"location":"algebraic/#Algebraic-number-functionality","page":"Algebraic numbers","title":"Algebraic number functionality","text":"","category":"section"},{"location":"algebraic/#Constructing-algebraic-numbers","page":"Algebraic numbers","title":"Constructing algebraic numbers","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Methods to construct algebraic numbers include:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Conversion from other numbers and through arithmetic operations\nComputing the roots of a given polynomial\nComputing the eigenvalues of a given matrix\nRandom generation\nExact trigonometric functions (see later section)\nGuessing (see later section)","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Arithmetic:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> fmpz(QQBar(3))\n3\n\njulia> fmpq(QQBar(3) // 2)\n3//2\n\njulia> QQBar(-1) ^ (QQBar(1) // 3)\nRoot 0.500000 + 0.866025*im of x^2 - x + 1","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Solving the quintic equation:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rational Field, x)\n\njulia> v = roots(x^5-x-1, QQBar)\n5-element Vector{qqbar}:\n Root 1.16730 of x^5 - x - 1\n Root 0.181232 + 1.08395*im of x^5 - x - 1\n Root 0.181232 - 1.08395*im of x^5 - x - 1\n Root -0.764884 + 0.352472*im of x^5 - x - 1\n Root -0.764884 - 0.352472*im of x^5 - x - 1\n\njulia> v[1]^5 - v[1] - 1 == 0\ntrue","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Computing exact eigenvalues of a matrix:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> eigenvalues(ZZ[1 1 0; 0 1 1; 1 0 1], QQBar)\n3-element Vector{qqbar}:\n Root 2.00000 of x - 2\n Root 0.500000 + 0.866025*im of x^2 - x + 1\n Root 0.500000 - 0.866025*im of x^2 - x + 1","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"roots(f::fmpz_poly, R::CalciumQQBarField)\nroots(f::fmpq_poly, R::CalciumQQBarField)\neigenvalues(A::fmpz_mat, R::CalciumQQBarField)\neigenvalues(A::fmpq_mat, R::CalciumQQBarField)\nrand(R::CalciumQQBarField; degree::Int, bits::Int, randtype::Symbol=:null)","category":"page"},{"location":"algebraic/#AbstractAlgebra.Generic.roots-Tuple{fmpz_poly, CalciumQQBarField}","page":"Algebraic numbers","title":"AbstractAlgebra.Generic.roots","text":"roots(f::fmpz_poly, R::CalciumQQBarField)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Roots of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"algebraic/#AbstractAlgebra.Generic.roots-Tuple{fmpq_poly, CalciumQQBarField}","page":"Algebraic numbers","title":"AbstractAlgebra.Generic.roots","text":"roots(f::fmpq_poly, R::CalciumQQBarField)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Roots of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.eigenvalues-Tuple{fmpz_mat, CalciumQQBarField}","page":"Algebraic numbers","title":"Nemo.eigenvalues","text":"eigenvalues(A::fmpz_mat, R::CalciumQQBarField)\n\nReturn all the eigenvalues of the matrix A in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Eigenvalues of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.eigenvalues-Tuple{fmpq_mat, CalciumQQBarField}","page":"Algebraic numbers","title":"Nemo.eigenvalues","text":"eigenvalues(A::fmpq_mat, R::CalciumQQBarField)\n\nReturn all the eigenvalues of the matrix A in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Eigenvalues of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.rand-Tuple{CalciumQQBarField}","page":"Algebraic numbers","title":"Base.rand","text":"rand(R::CalciumQQBarField; degree::Int, bits::Int, randtype::Symbol=:null)\n\nReturn a random algebraic number with degree up to degree and coefficients up to bits in size. By default, both real and complex numbers are generated. Set the optional randtype to :real or :nonreal to generate a specific type of number. Note that nonreal numbers require degree at least 2.\n\n\n\n","category":"method"},{"location":"algebraic/#Numerical-evaluation","page":"Algebraic numbers","title":"Numerical evaluation","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Algebraic numbers can be evaluated numerically to arbitrary precision by converting to real or complex Arb fields:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = ArbField(64); RR(sqrt(QQBar(2)))\n[1.414213562373095049 +/- 3.45e-19]\n\njulia> CC = AcbField(32); CC(QQBar(-1) ^ (QQBar(1) // 4))\n[0.707106781 +/- 2.74e-10] + [0.707106781 +/- 2.74e-10]*im","category":"page"},{"location":"algebraic/#Minimal-polynomials,-conjugates,-and-properties","page":"Algebraic numbers","title":"Minimal polynomials, conjugates, and properties","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Retrieving the minimal polynomial and algebraic conjugates of a given algebraic number:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> minpoly(PolynomialRing(ZZ, \"x\")[1], QQBar(1+2im))\nx^2 - 2*x + 5\n\njulia> conjugates(QQBar(1+2im))\n2-element Vector{qqbar}:\n Root 1.00000 + 2.00000*im of x^2 - 2x + 5\n Root 1.00000 - 2.00000*im of x^2 - 2x + 5","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"iszero(x::qqbar)\nisone(x::qqbar)\nisinteger(x::qqbar)\nisrational(x::qqbar)\nisreal(x::qqbar)\ndegree(x::qqbar)\nisalgebraic_integer(x::qqbar)\nminpoly(R::FmpzPolyRing, x::qqbar)\nminpoly(R::FmpqPolyRing, x::qqbar)\nconjugates(a::qqbar)\ndenominator(x::qqbar)\nnumerator(x::qqbar)\nheight(x::qqbar)\nheight_bits(x::qqbar)","category":"page"},{"location":"algebraic/#Base.iszero-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.iszero","text":"iszero(x::qqbar)\n\nReturn whether x is the number 0.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.isone-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.isone","text":"isone(x::qqbar)\n\nReturn whether x is the number 1.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.isinteger-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.isinteger","text":"isinteger(x::qqbar)\n\nReturn whether x is an integer.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isrational-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.isrational","text":"isrational(x::qqbar)\n\nReturn whether x is a rational number.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.isreal-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.isreal","text":"isreal(x::qqbar)\n\nReturn whether x is a real number.\n\n\n\n","category":"method"},{"location":"algebraic/#AbstractAlgebra.degree-Tuple{qqbar}","page":"Algebraic numbers","title":"AbstractAlgebra.degree","text":"degree(x::qqbar)\n\nReturn the degree of the minimal polynomial of x.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isalgebraic_integer-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.isalgebraic_integer","text":"isalgebraic_integer(x::qqbar)\n\nReturn whether x is an algebraic integer.\n\n\n\n","category":"method"},{"location":"algebraic/#AbstractAlgebra.minpoly-Tuple{FmpzPolyRing, qqbar}","page":"Algebraic numbers","title":"AbstractAlgebra.minpoly","text":"minpoly(R::FmpzPolyRing, x::qqbar)\n\nReturn the minimal polynomial of x as an element of the polynomial ring R.\n\n\n\n","category":"method"},{"location":"algebraic/#AbstractAlgebra.minpoly-Tuple{FmpqPolyRing, qqbar}","page":"Algebraic numbers","title":"AbstractAlgebra.minpoly","text":"minpoly(R::FmpzPolyRing, x::qqbar)\n\nReturn the minimal polynomial of x as an element of the polynomial ring R.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.conjugates-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.conjugates","text":"conjugates(a::qqbar)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.denominator-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.denominator","text":"denominator(x::qqbar)\n\nReturn the denominator of x, defined as the leading coefficient of the minimal polynomial of x. The result is returned as an fmpz.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.numerator-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.numerator","text":"numerator(x::qqbar)\n\nReturn the numerator of x, defined as x multiplied by its denominator. The result is an algebraic integer.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.height-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.height","text":"height(x::qqbar)\n\nReturn the height of the algebraic number x. The result is an fmpz integer.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.height_bits-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.height_bits","text":"height_bits(x::qqbar)\n\nReturn the height of the algebraic number x measured in bits. The result is a Julia integer.\n\n\n\n","category":"method"},{"location":"algebraic/#Complex-parts","page":"Algebraic numbers","title":"Complex parts","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> real(sqrt(QQBar(1im)))\nRoot 0.707107 of 2x^2 - 1\n\njulia> abs(sqrt(QQBar(1im)))\nRoot 1.00000 of x - 1\n\njulia> floor(sqrt(QQBar(1000)))\nRoot 31.0000 of x - 31\n\njulia> sign(QQBar(-10-20im))\nRoot -0.447214 - 0.894427*im of 5x^4 + 6x^2 + 5","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"real(a::qqbar)\nimag(a::qqbar)\nabs(a::qqbar)\nabs2(a::qqbar)\nconj(a::qqbar)\nsign(a::qqbar)\ncsgn(a::qqbar)\nsign_real(a::qqbar)\nsign_imag(a::qqbar)\nfloor(a::qqbar)\nceil(a::qqbar)","category":"page"},{"location":"algebraic/#Base.real-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.real","text":"real(a::qqbar)\n\nReturn the real part of a.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.imag-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.imag","text":"imag(a::qqbar)\n\nReturn the imaginary part of a.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.abs-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.abs","text":"abs(a::qqbar)\n\nReturn the absolute value of a.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.abs2-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.abs2","text":"abs2(a::qqbar)\n\nReturn the squared absolute value of a.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.conj-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.conj","text":"conj(a::qqbar)\n\nReturn the complex conjugate of a.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.sign-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.sign","text":"sign(a::qqbar)\n\nReturn the complex sign of a, defined as zero if a is zero and as a  a otherwise.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.csgn-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.csgn","text":"csgn(a::qqbar)\n\nReturn the extension of the real sign function taking the value 1 strictly in the right half plane, -1 strictly in the left half plane, and the sign of the imaginary part when on the imaginary axis. Equivalently, operatornamecsgn(x) = x  sqrtx^2 except that the value is 0 at zero. The value is returned as a Julia integer.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.sign_real-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.sign_real","text":"sign_real(a::qqbar)\n\nReturn the sign of the real part of a as a Julia integer.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.sign_imag-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.sign_imag","text":"sign_imag(a::qqbar)\n\nReturn the sign of the imaginary part of a as a Julia integer.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.floor-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.floor","text":"floor(a::qqbar)\n\nReturn the floor function of a as an algebraic number. Use fmpz(floor(a)) to construct a Nemo integer instead.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.ceil-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.ceil","text":"ceil(a::qqbar)\n\nReturn the ceiling function of b as an algebraic number. Use fmpz(ceil(a)) to construct a Nemo integer instead.\n\n\n\n","category":"method"},{"location":"algebraic/#Comparing-algebraic-numbers","page":"Algebraic numbers","title":"Comparing algebraic numbers","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The operators == and != check exactly for equality.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"We provide various comparison functions for ordering algebraic numbers:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Standard comparison for real numbers (<, isless)\nReal parts\nImaginary parts\nAbsolute values\nAbsolute values of real or imaginary parts\nRoot sort order ","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The standard comparison will throw if either argument is nonreal.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The various comparisons for complex parts are provided as separate operations since these functions are far more efficient than explicitly computing the complex parts and then doing real comparisons.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The root sort order is a total order for complex algebraic numbers used to order the output of roots and conjugates canonically. We define this order as follows: real roots come first, in descending order. Nonreal roots are subsequently ordered first by real part in descending order, then in ascending order by the absolute value of the imaginary part, and then in descending order of the sign of the imaginary part. This implies that complex conjugate roots are adjacent, with the root in the upper half plane first.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> 1 < sqrt(QQBar(2)) < QQBar(3)//2\ntrue\n\njulia> x = QQBar(3+4im)\nRoot 3.00000 + 4.00000*im of x^2 - 6x + 25\n\njulia> isequal_abs(x, -x)\ntrue\n\njulia> isequal_abs_imag(x, 2-x)\ntrue\n\njulia> isless_real(x, x // 2)\nfalse","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"isequal_real(a::qqbar, b::qqbar)\nisequal_imag(a::qqbar, b::qqbar)\nisequal_abs(a::qqbar, b::qqbar)\nisequal_abs_real(a::qqbar, b::qqbar)\nisequal_abs_imag(a::qqbar, b::qqbar)\nisless_real(a::qqbar, b::qqbar)\nisless_imag(a::qqbar, b::qqbar)\nisless_abs(a::qqbar, b::qqbar)\nisless_abs_real(a::qqbar, b::qqbar)\nisless_abs_imag(a::qqbar, b::qqbar)\nisless_root_order(a::qqbar, b::qqbar)","category":"page"},{"location":"algebraic/#Nemo.isequal_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isequal_real","text":"isequal_real(a::qqbar, b::qqbar)\n\nCompares the real parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isequal_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isequal_imag","text":"isequal_imag(a::qqbar, b::qqbar)\n\nCompares the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isequal_abs-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isequal_abs","text":"isequal_abs(a::qqbar, b::qqbar)\n\nCompares the absolute values of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isequal_abs_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isequal_abs_real","text":"isequal_abs_real(a::qqbar, b::qqbar)\n\nCompares the absolute values of the real parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isequal_abs_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isequal_abs_imag","text":"isequal_abs_imag(a::qqbar, b::qqbar)\n\nCompares the absolute values of the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isless_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isless_real","text":"isless_real(a::qqbar, b::qqbar)\n\nCompares the real parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isless_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isless_imag","text":"isless_imag(a::qqbar, b::qqbar)\n\nCompares the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isless_abs-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isless_abs","text":"isless_abs(a::qqbar, b::qqbar)\n\nCompares the absolute values of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isless_abs_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isless_abs_real","text":"isless_abs_real(a::qqbar, b::qqbar)\n\nCompares the absolute values of the real parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isless_abs_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isless_abs_imag","text":"isless_abs_imag(a::qqbar, b::qqbar)\n\nCompares the absolute values of the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isless_root_order-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"Nemo.isless_root_order","text":"isless_root_order(a::qqbar, b::qqbar)\n\nCompares the a and b in root sort order.\n\n\n\n","category":"method"},{"location":"algebraic/#Roots-and-trigonometric-functions","page":"Algebraic numbers","title":"Roots and trigonometric functions","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> root(QQBar(2), 5)\nRoot 1.14870 of x^5 - 2\n\njulia> sinpi(QQBar(7) // 13)\nRoot 0.992709 of 4096x^12 - 13312x^10 + 16640x^8 - 9984x^6 + 2912x^4 - 364x^2 + 13\n\njulia> tanpi(atanpi(sqrt(QQBar(2)) + 1))\nRoot 2.41421 of x^2 - 2x - 1\n\njulia> root_of_unity(QQBar, 5)\nRoot 0.309017 + 0.951057*im of x^4 + x^3 + x^2 + x + 1\n\njulia> root_of_unity(QQBar, 5, 4)\nRoot 0.309017 - 0.951057*im of x^4 + x^3 + x^2 + x + 1\n\njulia> w = (1 - sqrt(QQBar(-3)))//2\nRoot 0.500000 - 0.866025*im of x^2 - x + 1\n\njulia> isroot_of_unity(w)\ntrue\n\njulia> isroot_of_unity(w + 1)\nfalse\n\njulia> root_of_unity_as_args(w)\n(6, 5)","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"sqrt(a::qqbar)\nroot(a::qqbar, n::Int)\nroot_of_unity(C::CalciumQQBarField, n::Int)\nroot_of_unity(C::CalciumQQBarField, n::Int, k::Int)\nisroot_of_unity(a::qqbar)\nroot_of_unity_as_args(a::qqbar)\nexp_pi_i(a::qqbar)\nlog_pi_i(a::qqbar)\nsinpi(a::qqbar)\ncospi(a::qqbar)\ntanpi(a::qqbar)\nasinpi(a::qqbar)\nacospi(a::qqbar)\natanpi(a::qqbar)","category":"page"},{"location":"algebraic/#Base.sqrt-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.sqrt","text":"sqrt(a::qqbar; check::Bool=true)\n\nReturn the principal square root of a.\n\n\n\n","category":"method"},{"location":"algebraic/#AbstractAlgebra.root-Tuple{qqbar, Int64}","page":"Algebraic numbers","title":"AbstractAlgebra.root","text":"root(a::qqbar, n::Int)\n\nReturn the principal n-th root of a. Requires positive n.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.root_of_unity-Tuple{CalciumQQBarField, Int64}","page":"Algebraic numbers","title":"Nemo.root_of_unity","text":"root_of_unity(C::CalciumQQBarField, n::Int)\n\nReturn the root of unity e^2 pi i  n as an element of the field of algebraic numbers C.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.root_of_unity-Tuple{CalciumQQBarField, Int64, Int64}","page":"Algebraic numbers","title":"Nemo.root_of_unity","text":"root_of_unity(C::CalciumQQBarField, n::Int, k::Int)\n\nReturn the root of unity e^2 pi i k  n as an element of the field of algebraic numbers C.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.isroot_of_unity-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.isroot_of_unity","text":"isroot_of_unity(a::qqbar)\n\nReturn whether the given algebraic number is a root of unity.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.root_of_unity_as_args-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.root_of_unity_as_args","text":"root_of_unity_as_args(a::qqbar)\n\nReturn a pair of integers (q, p) such that the given a equals e^2 pi i p  q. The denominator q will be minimal, with 0 le p  q. Throws if a is not a root of unity.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.exp_pi_i-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.exp_pi_i","text":"exp_pi_i(a::qqbar)\n\nReturn e^pi i a as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.log_pi_i-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.log_pi_i","text":"log_pi_i(a::qqbar)\n\nReturn log(a)  (pi i) as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.Math.sinpi-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.Math.sinpi","text":"sinpi(a::qqbar)\n\nReturn sin(pi a) as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"algebraic/#Base.Math.cospi-Tuple{qqbar}","page":"Algebraic numbers","title":"Base.Math.cospi","text":"cospi(a::qqbar)\n\nReturn cos(pi a) as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.tanpi-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.tanpi","text":"tanpi(a::qqbar)\n\nReturn tan(pi a) as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.asinpi-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.asinpi","text":"asinpi(a::qqbar)\n\nReturn operatornameasin(a)  pi as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.acospi-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.acospi","text":"acospi(a::qqbar)\n\nReturn operatornameacos(a)  pi as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"algebraic/#Nemo.atanpi-Tuple{qqbar}","page":"Algebraic numbers","title":"Nemo.atanpi","text":"atanpi(a::qqbar)\n\nReturn operatornameatan(a)  pi as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n","category":"method"},{"location":"algebraic/#Guessing","page":"Algebraic numbers","title":"Guessing","text":"","category":"section"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"An algebraic number can be recovered from a numerical value:","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = ArbField(53); guess(QQBar, RR(\"1.41421356 +/- 1e-6\"), 2)\nRoot 1.41421 of x^2 - 2","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Warning: the input should be an enclosure. If you have a floating-point approximation, you should add an error estimate; otherwise, the only algebraic number that can be guessed is the binary floating-point number itself.","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = ArbField(128);\n\njulia> x = RR(0.1);       # note: 53-bit binary approximation of 1//10 without radius\n\njulia> guess(QQBar, x, 1)\nRoot 0.100000 of 36028797018963968x - 3602879701896397\n\njulia> guess(QQBar, x + RR(\"+/- 1e-10\"), 1)\nRoot 0.100000 of 10x - 1","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"guess(R::CalciumQQBarField, x::arb, maxdeg::Int, maxbits::Int=0)\nguess(R::CalciumQQBarField, x::acb, maxdeg::Int, maxbits::Int=0)","category":"page"},{"location":"algebraic/#Nemo.guess","page":"Algebraic numbers","title":"Nemo.guess","text":"guess(R::CalciumQQBarField, x::acb, maxdeg::Int, maxbits::Int=0)\n\nTry to reconstruct an algebraic number from a given numerical enclosure x. The algorithm looks for candidates up to degree maxdeg and with coefficients up to size maxbits (which defaults to the precision of x if not given). Throws if no suitable algebraic number can be found.\n\nGuessing typically requires high precision to succeed, and it does not make much sense to call this function with input precision smaller than O(maxdeg cdot maxbits). If this function succeeds, then the output is guaranteed to be contained in the enclosure x, but failure does not prove that such an algebric number with the specified parameters does not exist.\n\nThis function does a single iteration with the target parameters. For best performance, one should invoke this function repeatedly with successively larger parameters when the size of the intended solution is unknown or may be much smaller than a worst-case bound.\n\n\n\n","category":"function"},{"location":"algebraic/#Nemo.guess-2","page":"Algebraic numbers","title":"Nemo.guess","text":"guess(R::CalciumQQBarField, x::acb, maxdeg::Int, maxbits::Int=0)\n\nTry to reconstruct an algebraic number from a given numerical enclosure x. The algorithm looks for candidates up to degree maxdeg and with coefficients up to size maxbits (which defaults to the precision of x if not given). Throws if no suitable algebraic number can be found.\n\nGuessing typically requires high precision to succeed, and it does not make much sense to call this function with input precision smaller than O(maxdeg cdot maxbits). If this function succeeds, then the output is guaranteed to be contained in the enclosure x, but failure does not prove that such an algebric number with the specified parameters does not exist.\n\nThis function does a single iteration with the target parameters. For best performance, one should invoke this function repeatedly with successively larger parameters when the size of the intended solution is unknown or may be much smaller than a worst-case bound.\n\n\n\n","category":"function"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"CurrentModule = Nemo","category":"page"},{"location":"numberfield/#Number-field-arithmetic","page":"Number field arithmetic","title":"Number field arithmetic","text":"","category":"section"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Number fields are provided in Nemo by Antic. This allows construction of absolute number fields and basic arithmetic computations therein.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Number fields are constructed using the AnticNumberField function. However, for convenience we define","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"NumberField = AnticNumberField","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"so that number fields can be constructed using NumberField rather than AnticNumberField. ","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The types of number field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Library Field Element type Parent type\nAntic mathbbQx(f) nf_elem AnticNumberField","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"All the number field types belong to the Field abstract type and the number field element types belong to the FieldElem abstract type.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The Hecke.jl library radically expands on number field functionality, providing ideals, orders, class groups, relative extensions, class field theory, etc.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The basic number field element type used in Hecke is the Nemo/antic number field element type, making the two libraries tightly integrated.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"https://thofma.github.io/Hecke.jl/latest/","category":"page"},{"location":"numberfield/#Number-field-functionality","page":"Number field arithmetic","title":"Number field functionality","text":"","category":"section"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The number fields in Nemo provide all of the AbstractAlgebra field functionality:","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Below, we document the additional functionality provided for number field elements.","category":"page"},{"location":"numberfield/#Constructors","page":"Number field arithmetic","title":"Constructors","text":"","category":"section"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"In order to construct number field elements in Nemo, one must first construct the number field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"NumberField(::fmpq_poly, ::String)\nCyclotomicField(::Int, ::String)\nCyclotomicRealSubfield(::Int, ::String)","category":"page"},{"location":"numberfield/#Nemo.NumberField-Tuple{fmpq_poly, String}","page":"Number field arithmetic","title":"Nemo.NumberField","text":"NumberField(f::fmpq_poly, s::AbstractString; cached::Bool = true, check::Bool = true)\n\nReturn a tuple R x consisting of the parent object R and generator x of the number field mathbbQx(f) where f is the supplied polynomial. The supplied string s specifies how the generator of the number field should be printed.\n\n\n\n","category":"method"},{"location":"numberfield/#Nemo.CyclotomicField-Tuple{Int64, String}","page":"Number field arithmetic","title":"Nemo.CyclotomicField","text":"CyclotomicField(n::Int, s::AbstractString, t = \"\\$\"; cached = true)\n\nReturn a tuple R x consisting of the parent object R and generator x of the n-th cyclotomic field, mathbbQ(zeta_n). The supplied string s specifies how the generator of the number field should be printed. If provided, the string t specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.\n\n\n\n","category":"method"},{"location":"numberfield/#Nemo.CyclotomicRealSubfield-Tuple{Int64, String}","page":"Number field arithmetic","title":"Nemo.CyclotomicRealSubfield","text":"CyclotomicRealSubfield(n::Int, s::AbstractString, t = \"\\$\"; cached = true)\n\nReturn a tuple R x consisting of the parent object R and generator x of the totally real subfield of the n-th cyclotomic field, mathbbQ(zeta_n). The supplied string s specifies how the generator of the number field should be printed. If provided, the string t specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Here are some examples of creating number fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\nL, b = CyclotomicField(5, \"b\")\nM, c = CyclotomicRealField(5, \"c\")\n\nd = K(3)\nf = L(b)\ng = L(ZZ(11))\nh = L(ZZ(11)//3)\nk = M(x)","category":"page"},{"location":"numberfield/#Number-field-element-constructors","page":"Number field arithmetic","title":"Number field element constructors","text":"","category":"section"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"gen(::AnticNumberField)","category":"page"},{"location":"numberfield/#AbstractAlgebra.gen-Tuple{AnticNumberField}","page":"Number field arithmetic","title":"AbstractAlgebra.gen","text":"gen(a::AnticNumberField)\n\nReturn the generator of the given number field.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The easiest way of constructing number field elements is to use element arithmetic with the generator, to construct the desired element by its representation as a polynomial. See the following examples for how to do this.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nd = gen(K)\nf = a^2 + 2a - 7","category":"page"},{"location":"numberfield/#Basic-functionality","page":"Number field arithmetic","title":"Basic functionality","text":"","category":"section"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"mul_red!(::nf_elem, ::nf_elem, ::nf_elem, ::Bool)","category":"page"},{"location":"numberfield/#AbstractAlgebra.mul_red!-Tuple{nf_elem, nf_elem, nf_elem, Bool}","page":"Number field arithmetic","title":"AbstractAlgebra.mul_red!","text":"mul_red!(z::nf_elem, x::nf_elem, y::nf_elem, red::Bool)\n\nMultiply x by y and set the existing number field element z to the result. Reduction modulo the defining polynomial is only performed if red is set to true. Note that x and y must be reduced. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"reduce!(::nf_elem)","category":"page"},{"location":"numberfield/#AbstractAlgebra.Generic.reduce!-Tuple{nf_elem}","page":"Number field arithmetic","title":"AbstractAlgebra.Generic.reduce!","text":"reduce!(x::nf_elem)\n\nReduce the given number field element by the defining polynomial, in-place. This only needs to be done after accumulating values computed by mul_red! where reduction has not been performed. All standard Nemo number field functions automatically reduce their outputs.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The following coercion function is provided for a number field R.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R(f::fmpq_poly)","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Coerce the given rational polynomial into the number field R, i.e. consider the polynomial to be the representation of a number field element and return it.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Conversely, if R is the polynomial ring to which the generating polynomial of a number field belongs, then we can coerce number field elements into the ring R using the following function.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R(b::nf_elem)","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Coerce the given number field element into the polynomial ring R of which the number field is a quotient.","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nf = R(a^2 + 2a + 3)\ng = K(x^2 + 2x + 1)","category":"page"},{"location":"numberfield/#Basic-manipulation","page":"Number field arithmetic","title":"Basic manipulation","text":"","category":"section"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"var(::AnticNumberField)","category":"page"},{"location":"numberfield/#AbstractAlgebra.var-Tuple{AnticNumberField}","page":"Number field arithmetic","title":"AbstractAlgebra.var","text":"var(a::AnticNumberField)\n\nReturns the identifier (as a symbol, not a string), that is used for printing the generator of the given number field.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"isgen(::nf_elem)","category":"page"},{"location":"numberfield/#AbstractAlgebra.isgen-Tuple{nf_elem}","page":"Number field arithmetic","title":"AbstractAlgebra.isgen","text":"isgen(a::nf_elem)\n\nReturn true if the given number field element is the generator of the number field, otherwise return false.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"coeff(::nf_elem, ::Int)","category":"page"},{"location":"numberfield/#AbstractAlgebra.coeff-Tuple{nf_elem, Int64}","page":"Number field arithmetic","title":"AbstractAlgebra.coeff","text":"coeff(x::nf_elem, n::Int)\n\nReturn the n-th coefficient of the polynomial representation of the given number field element. Coefficients are numbered from 0, starting with the constant coefficient.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"denominator(::nf_elem)","category":"page"},{"location":"numberfield/#Base.denominator-Tuple{nf_elem}","page":"Number field arithmetic","title":"Base.denominator","text":"denominator(a::nf_elem)\n\nReturn the denominator of the polynomial representation of the given number field element.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"degree(::AnticNumberField)","category":"page"},{"location":"numberfield/#AbstractAlgebra.degree-Tuple{AnticNumberField}","page":"Number field arithmetic","title":"AbstractAlgebra.degree","text":"degree(a::AnticNumberField)\n\nReturn the degree of the given number field, i.e. the degree of its defining polynomial.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nd = a^2 + 2a - 7\nm = gen(K)\n\nc = coeff(d, 1)\nisgen(m)\nq = degree(K)\nr, s = signature(K)\nv = var(R)","category":"page"},{"location":"numberfield/#Norm-and-trace","page":"Number field arithmetic","title":"Norm and trace","text":"","category":"section"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"norm(::nf_elem)","category":"page"},{"location":"numberfield/#LinearAlgebra.norm-Tuple{nf_elem}","page":"Number field arithmetic","title":"LinearAlgebra.norm","text":"norm(a::nf_elem)\n\nReturn the absolute norm of a. The result will be a rational number.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"tr(::nf_elem)","category":"page"},{"location":"numberfield/#LinearAlgebra.tr-Tuple{nf_elem}","page":"Number field arithmetic","title":"LinearAlgebra.tr","text":"tr(a::nf_elem)\n\nReturn the absolute trace of a. The result will be a rational number.\n\n\n\n","category":"method"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nc = 3a^2 - a + 1\n\nd = norm(c)\nf = tr(c)","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"CurrentModule = Nemo","category":"page"},{"location":"puiseux/#Puiseux-series","page":"Puiseux series","title":"Puiseux series","text":"","category":"section"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Nemo allows the creation of Puiseux series over any computable ring R. Puiseux series are series of the form a_jx^jm + a_j+1x^(j+1)m + cdots + a_k-1x^(k-1)m + O(x^km) where m is a positive integer, a_i in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of Puiseux series over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"The following table shows each of the Puiseux series types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl `Generic.PuiseuxSeriesRingElem{T} Generic.PuiseuxSeriesRing{T}\nGeneric field K AbstractAlgebra.jl `Generic.PuiseuxSeriesFieldElem{T} Generic.PuiseuxSeriesField{T}\nmathbbZ Flint FlintPuiseuxSeriesRingElem{fmpz_laurent_series} FlintPuiseuxSeriesRing{fmpz_laurent_series}","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"For convenience, FlintPuiseuxSeriesRingElem and FlintPuiseuxSeriesFieldElem both belong to a union type called FlintPuiseuxSeriesElem.","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"The maximum relative precision, the string representation of the variable and the base ring R of a generic power series are stored in the parent object. ","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Note that unlike most other Nemo types, Puiseux series are parameterised by the type of the underlying Laurent series type (which must exist before Nemo can make use of it), instead of the type of the coefficients.","category":"page"},{"location":"puiseux/#Puiseux-power-series","page":"Puiseux series","title":"Puiseux power series","text":"","category":"section"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Puiseux series have their maximum relative precision capped at some value prec_max. This refers to the maximum precision of the underlying Laurent series. See the description of the generic Puiseux series in AbstractAlgebra.jl for details.","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"There are numerous important things to be aware of when working with Puiseux series, or series in general. Please refer to the documentation of generic Puiseux series and  series in general in AbstractAlgebra.jl for details.","category":"page"},{"location":"puiseux/#Puiseux-series-functionality","page":"Puiseux series","title":"Puiseux series functionality","text":"","category":"section"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Puiseux series rings in Nemo implement all the same functionality that is available for AbstractAlgebra series rings, with the exception of the pol_length and polcoeff functions:","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/series","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"In addition, generic Puiseux series are provided by AbstractAlgebra.jl","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"We list below only the functionality that differs from that described in AbstractAlgebra, for specific rings provided by Nemo.","category":"page"},{"location":"puiseux/#Special-functions","page":"Puiseux series","title":"Special functions","text":"","category":"section"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base.sqrt(a::FlintPuiseuxSeriesElem{fmpz_laurent_series})","category":"page"},{"location":"puiseux/#Base.sqrt-Tuple{FlintPuiseuxSeriesElem{fmpz_laurent_series}}","page":"Puiseux series","title":"Base.sqrt","text":"sqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nBase.sqrt(f::PolyElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base.exp(a::FlintPuiseuxSeriesElem{fmpz_laurent_series})","category":"page"},{"location":"puiseux/#Base.exp-Tuple{FlintPuiseuxSeriesElem{fmpz_laurent_series}}","page":"Puiseux series","title":"Base.exp","text":"exp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\nexp(a::AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"eta_qexp(x::FlintPuiseuxSeriesElem{fmpz_laurent_series})","category":"page"},{"location":"puiseux/#Nemo.eta_qexp-Tuple{FlintPuiseuxSeriesElem{fmpz_laurent_series}}","page":"Puiseux series","title":"Nemo.eta_qexp","text":"eta_qexp(x::FlintPuiseuxSeriesElem{fmpz_laurent_series})\n\nReturn the q-series for eta evaluated at x, which must currently be a rational power of the generator of the Puiseux series ring.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Examples","category":"page"},{"location":"puiseux/","page":"Puiseux series","title":"Puiseux series","text":"S, x = PuiseuxSeriesRing(ZZ, 30, \"x\")\n\na = 1 + z + 3z^2 + O(z^5)\n\nh = sqrt(a^2)\nk = eta_qexp(S)","category":"page"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"CurrentModule = Nemo","category":"page"},{"location":"ff_embedding/#Finite-field-embeddings","page":"Finite field embeddings","title":"Finite field embeddings","text":"","category":"section"},{"location":"ff_embedding/#Introduction","page":"Finite field embeddings","title":"Introduction","text":"","category":"section"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"Nemo allows the construction of finite field embeddings making use of the algorithm of Bosma, Cannon and Steel behind the scenes to ensure compatibility. Critical routines (e.g. polynomial factorization, matrix computations) are provided by the C library Flint, whereas high level tasks are written directly in Nemo.","category":"page"},{"location":"ff_embedding/#Embedding-functionality","page":"Finite field embeddings","title":"Embedding functionality","text":"","category":"section"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"It is possible to explicitly call the embedding embed function to create an embedding, but it is also possible to directly ask for the conversion of a finite field element x in some other finite field k via calling k(x). The resulting embedding is of type FinFieldMorphism. It is also possible to compute the preimage map of an embedding via the preimage_map function, applied to an embedding or directly to the finite fields (this actually first computes the embedding), or via conversion. An error is thrown if the element you want to compute the preimage of is not in the image of the embedding.","category":"page"},{"location":"ff_embedding/#Computing-an-embedding","page":"Finite field embeddings","title":"Computing an embedding","text":"","category":"section"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"embed(::FqNmodFiniteField, ::FqNmodFiniteField)","category":"page"},{"location":"ff_embedding/#Nemo.embed-Tuple{FqNmodFiniteField, FqNmodFiniteField}","page":"Finite field embeddings","title":"Nemo.embed","text":"embed(k::T, K::T) where T <: FinField\n\nEmbed k in K, with some additional computations in order to satisfy compatibility conditions with previous and future embeddings.\n\n\n\n","category":"method"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"Examples","category":"page"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"julia> k2, x2 = FiniteField(19, 2, \"x2\")\n(Finite field of degree 2 over F_19, x2)\n\njulia> k4, x4 = FiniteField(19, 4, \"x4\")\n(Finite field of degree 4 over F_19, x4)\n\njulia> f = embed(k2, k4)\nMorphism from Finite field of degree 2 over F_19\nto Finite field of degree 4 over F_19\n\njulia> y = f(x2)\n6*x4^3+5*x4^2+9*x4+17\n\njulia> z = k4(x2)\n6*x4^3+5*x4^2+9*x4+17","category":"page"},{"location":"ff_embedding/#Computing-the-preimage-of-an-embedding","page":"Finite field embeddings","title":"Computing the preimage of an embedding","text":"","category":"section"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"preimage_map(::FqNmodFiniteField, ::FqNmodFiniteField)\npreimage_map(::FinFieldMorphism)","category":"page"},{"location":"ff_embedding/#AbstractAlgebra.Generic.preimage_map-Tuple{FqNmodFiniteField, FqNmodFiniteField}","page":"Finite field embeddings","title":"AbstractAlgebra.Generic.preimage_map","text":"preimage_map(k::T, k::T) where T <: FinField\n\nComputes the preimage map corresponding to the embedding of k into K.\n\n\n\n","category":"method"},{"location":"ff_embedding/#AbstractAlgebra.Generic.preimage_map-Tuple{Nemo.FinFieldMorphism}","page":"Finite field embeddings","title":"AbstractAlgebra.Generic.preimage_map","text":"preimage_map(f::FinFieldMorphism)\n\nCompute the preimage map corresponding to the embedding f.\n\n\n\n","category":"method"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"Examples","category":"page"},{"location":"ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"julia> k7, x7 = FiniteField(13, 7, \"x7\")\n(Finite field of degree 7 over F_13, x7)\n\njulia> k21, x21 = FiniteField(13, 21, \"x21\")\n(Finite field of degree 21 over F_13, x21)\n\njulia> s = preimage_map(k7, k21)\nPreimage of the morphism from Finite field of degree 7 over F_13\nto Finite field of degree 21 over F_13\n\njulia> y = k21(x7);\n\njulia> z = s(y)\nx7\n\njulia> t = k7(y)\nx7","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"CurrentModule = Nemo","category":"page"},{"location":"gfp/#Galois-fields","page":"Galois fields","title":"Galois fields","text":"","category":"section"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"Nemo allows the creation of Galois fields of the form mathbbZpmathbbZ for a prime p. Note that these are not the same as finite fields of degree 1, as Conway polynomials are not used and no generator is given.","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"For convenience, the following constructors are provided.","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"GF(n::UInt)\nGF(n::Int)\nGF(n::fmpz)","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"For example, one can create the Galois field of characteristic 7 as follows.","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"R = GF(7)","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"Elements of the field are then created in the usual way.","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"a = R(3)","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"Elements of Galois fields have type gfp_elem when p is given to the constructor as an Int or UInt, and of type gfp_fmpz_elem if p is given as an fmpz, and the type of the parent objects is GaloisField or GaloisFmpzField respectively.","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"The modulus p of an element of a Galois field is stored in its parent object.","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"The gfp_elem and gfp_fmpz_elem types belong to the abstract type FinFieldElem and the GaloisField and GaloisFmpzField parent object types belong to the abstract type FinField.","category":"page"},{"location":"gfp/#Galois-field-functionality","page":"Galois fields","title":"Galois field functionality","text":"","category":"section"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"Galois fields in Nemo provide all the residue ring functionality of AbstractAlgebra.jl:","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/residue","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"In addition, all the functionality for rings is available:","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/ring","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"Below we describe the functionality that is provided in addition to these.","category":"page"},{"location":"gfp/#Basic-manipulation","page":"Galois fields","title":"Basic manipulation","text":"","category":"section"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"Examples","category":"page"},{"location":"gfp/","page":"Galois fields","title":"Galois fields","text":"F = GF(3)\n\na = characteristic(F)\nb = order(F)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"CurrentModule = Nemo","category":"page"},{"location":"integer/#Integers","page":"Integers","title":"Integers","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"The default integer type in Nemo is provided by Flint. The associated ring of integers is represented by the constant parent object called FlintZZ.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"For convenience we define","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ = FlintZZ","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"so that integers can be constructed using ZZ instead of FlintZZ. Note that this is the name of a specific parent object, not the name of its type.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"The types of the integer ring parent objects and elements of the associated rings of integers are given in the following table according to the library provding them.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Library Element type Parent type\nFlint fmpz FlintIntegerRing","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"All integer element types belong directly to the abstract type RingElem and all the integer ring parent object types belong to the abstract type Ring.","category":"page"},{"location":"integer/#Integer-functionality","page":"Integers","title":"Integer functionality","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Nemo integers provide all of the ring and Euclidean ring functionality of AbstractAlgebra.jl.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/ring","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Below, we describe the functionality that is specific to the Nemo/Flint integer ring.","category":"page"},{"location":"integer/#Constructors","page":"Integers","title":"Constructors","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ(n::Integer)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Coerce a Julia integer value into the integer ring.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ(n::String)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Parse the given string as an integer.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ(n::Float64)\nZZ(n::Float32)\nZZ(n::Float16)\nZZ(n::BigFloat)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Coerce the given floating point number into the integer ring, assuming that it can be exactly represented as an integer.","category":"page"},{"location":"integer/#Basic-manipulation","page":"Integers","title":"Basic manipulation","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"sign(::fmpz)","category":"page"},{"location":"integer/#Base.sign-Tuple{fmpz}","page":"Integers","title":"Base.sign","text":"sign(a::fmpz)\n\nReturn the sign of a, i.e. +1, 0 or -1.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"size(::fmpz)","category":"page"},{"location":"integer/#Base.size-Tuple{fmpz}","page":"Integers","title":"Base.size","text":"size(a::fmpz)\n\nReturn the number of limbs required to store the absolute value of a.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"fits(::Type{UInt}, ::fmpz)\nfits(::Type{Int}, ::fmpz)","category":"page"},{"location":"integer/#Nemo.fits-Tuple{Type{UInt64}, fmpz}","page":"Integers","title":"Nemo.fits","text":"fits(::Type{UInt}, a::fmpz)\n\nReturn true if a fits into a UInt, otherwise return false.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.fits-Tuple{Type{Int64}, fmpz}","page":"Integers","title":"Nemo.fits","text":"fits(::Type{Int}, a::fmpz)\n\nReturn true if a fits into an Int, otherwise return false.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"denominator(::fmpz)","category":"page"},{"location":"integer/#Base.denominator-Tuple{fmpz}","page":"Integers","title":"Base.denominator","text":"denominator(a::fmpz)\n\nReturn the denominator of a thought of as a rational. Always returns 1.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"numerator(::fmpz)","category":"page"},{"location":"integer/#Base.numerator-Tuple{fmpz}","page":"Integers","title":"Base.numerator","text":"numerator(a::fmpz)\n\nReturn the numerator of a thought of as a rational. Always returns a.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = ZZ(12)\n\nisunit(a)\nsign(a)\ns = size(a)\nfits(Int, a)\nn = numerator(a)\nd = denominator(a)","category":"page"},{"location":"integer/#Euclidean-division","page":"Integers","title":"Euclidean division","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Nemo also provides a large number of Euclidean division operations. Recall that for a dividend a and divisor b, we can write a = bq + r with 0 leq r  b. We call q the quotient and r the remainder.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"We distinguish three cases. If q is rounded towards zero, r will have the same sign as a. If q is rounded towards plus infinity, r will have the opposite sign to b. Finally, if q is rounded towards minus infinity, r will have the same sign as b.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"In the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with q representing return of the quotient and r representing return of the remainder.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function Return Rounding\nmod r towards minus infinity\nrem r towards zero\ndiv q towards minus infinity\ndivrem(a::fmpz, b::fmpz) q, r towards minus infinity\ntdivrem(a::fmpz, b::fmpz) q, r towards zero\nfdivrem(a::fmpz, b::fmpz) q, r towards minus infinity\nndivrem(a::fmpz, b::fmpz) q, r nearest integer, ties rounds toward zero","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"N.B: the internal definition of Nemo.div and Nemo.divrem are the same as fdiv and fdivrem. The definitions in the table are of Base.div and Base.divrem which agree with Julia's definitions of div and divrem.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Nemo also offers the following ad hoc division operators. The notation and description is as for the other Euclidean division functions.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function Return Rounding\nmod(a::fmpz, b::Int) r towards minus infinity\nrem(a::fmpz, b::Int) r towards zero\ndiv(a::fmpz, b::Int) q towards zero\ntdiv(a::fmpz, b::Int) q towards zero\nfdiv(a::fmpz, b::Int) q towards minus infinity\ncdiv(a::fmpz, b::Int) q towards plus infinity","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"N.B: the internal definition of Nemo.div is the same as fdiv. The definition in the table is Base.div which agrees with Julia's definition of div.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"The following functions are also available, for the case where one is dividing by a power of 2. In other words, for Euclidean division of the form a = b2^d + r. These are useful for bit twiddling.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function Return Rounding\ntdivpow2(a::fmpz, d::Int) q towards zero\nfdivpow2(a::fmpz, d::Int) q towards minus infinity\nfmodpow2(a::fmpz, d::Int) r towards minus infinity\ncdivpow2(a::fmpz, d::Int) q towards plus infinity","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\nb = fmpz(5)\n\nq, r = divrem(a, b)\nc = cdiv(a, b)\nd = fdiv(a, b)\nf = tdivpow2(a, 2)\ng = fmodpow2(a, 3)","category":"page"},{"location":"integer/#Comparison","page":"Integers","title":"Comparison","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Instead of isless we implement a function cmp(a, b) which returns a positive value if a  b, zero if a == b and a negative value if a  b. We then implement all the other operators, including == in terms of cmp.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"For convenience we also implement a cmpabs(a, b) function which returns a positive value if a  b, zero if a == b and a negative value if a  b. This can be slightly faster than a call to cmp or one of the comparison operators when comparing nonnegative values for example.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Here is a list of the comparison functions implemented, with the understanding that cmp provides all of the comparison operators listed above.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function\ncmp(a::fmpz, b::fmpz)\ncmpabs(a::fmpz, b::fmpz)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function\ncmp(a::fmpz, b::Int)\ncmp(a::Int, b::fmpz)\ncmp(a::fmpz, b::UInt)\ncmp(a::UInt, b::fmpz)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = ZZ(12)\nb = ZZ(3)\n\na < b\na != b\na > 4\n5 <= b\ncmpabs(a, b)","category":"page"},{"location":"integer/#Shifting","page":"Integers","title":"Shifting","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"<<(::fmpz, ::Int)","category":"page"},{"location":"integer/#Base.:<<-Tuple{fmpz, Int64}","page":"Integers","title":"Base.:<<","text":"<<(x::fmpz, c::Int)\n\nReturn 2^cx where c geq 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":">>(::fmpz, ::Int)","category":"page"},{"location":"integer/#Base.:>>-Tuple{fmpz, Int64}","page":"Integers","title":"Base.:>>","text":">>(x::fmpz, c::Int)\n\nReturn x2^c, discarding any remainder, where c geq 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\n\na << 3\na >> 5","category":"page"},{"location":"integer/#Modular-arithmetic","page":"Integers","title":"Modular arithmetic","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"sqrtmod(::fmpz, ::fmpz)","category":"page"},{"location":"integer/#Nemo.sqrtmod-Tuple{fmpz, fmpz}","page":"Integers","title":"Nemo.sqrtmod","text":"sqrtmod(x::fmpz, m::fmpz)\n\nReturn a square root of x (mod m) if one exists. The remainder will be in the range 0 m). We require that m is prime, otherwise the algorithm may not terminate.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"crt(::fmpz, ::fmpz, ::fmpz, m::fmpz, ::Bool)\ncrt(::fmpz, ::fmpz, ::Int, ::Int, ::Bool)","category":"page"},{"location":"integer/#AbstractAlgebra.crt-Tuple{fmpz, fmpz, fmpz, fmpz, Bool}","page":"Integers","title":"AbstractAlgebra.crt","text":"crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, signed=false)\n\nReturn r such that r equiv r_1 (mod m_1) and r equiv r_2 (mod m_2). If signed = true, r will be in the range -m_1m_22  r leq m_1m_22. If signed = false the value will be in the range 0 leq r  m_1m_2.\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.crt-Tuple{fmpz, fmpz, Int64, Int64, Bool}","page":"Integers","title":"AbstractAlgebra.crt","text":"crt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, signed=false)\n\nReturn r such that r equiv r_1 (mod m_1) and r equiv r_2 (mod m_2). If signed = true, r will be in the range -m_1m_22  r leq m_1m_22. If signed = false the value will be in the range 0 leq r  m_1m_2.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"c = sqrtmod(ZZ(12), ZZ(13))\nd = crt(ZZ(5), ZZ(13), ZZ(7), ZZ(37), true)","category":"page"},{"location":"integer/#Integer-logarithm","page":"Integers","title":"Integer logarithm","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"flog(::fmpz, ::fmpz)\nflog(::fmpz, ::Int)","category":"page"},{"location":"integer/#Nemo.flog-Tuple{fmpz, fmpz}","page":"Integers","title":"Nemo.flog","text":"flog(x::fmpz, c::fmpz)\n\nReturn the floor of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.flog-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.flog","text":"flog(x::fmpz, c::Int)\n\nReturn the floor of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"clog(::fmpz, ::fmpz)\nclog(::fmpz, ::Int)","category":"page"},{"location":"integer/#Nemo.clog-Tuple{fmpz, fmpz}","page":"Integers","title":"Nemo.clog","text":"clog(x::fmpz, c::fmpz)\n\nReturn the ceiling of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.clog-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.clog","text":"clog(x::fmpz, c::Int)\n\nReturn the ceiling of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\nb = fmpz(2)\n\nc = flog(a, b)\nd = clog(a, 3)","category":"page"},{"location":"integer/#Integer-roots","page":"Integers","title":"Integer roots","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"isqrt(::fmpz)","category":"page"},{"location":"integer/#Base.isqrt-Tuple{fmpz}","page":"Integers","title":"Base.isqrt","text":"isqrt(x::fmpz)\n\nReturn the floor of the square root of x.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"isqrtrem(::fmpz)","category":"page"},{"location":"integer/#Nemo.isqrtrem-Tuple{fmpz}","page":"Integers","title":"Nemo.isqrtrem","text":"isqrtrem(x::fmpz)\n\nReturn a tuple s r consisting of the floor s of the square root of x and the remainder r, i.e. such that x = s^2 + r. We require x geq 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"root(::fmpz, ::Int)","category":"page"},{"location":"integer/#AbstractAlgebra.root-Tuple{fmpz, Int64}","page":"Integers","title":"AbstractAlgebra.root","text":"root(x::fmpz, n::Int; check::Bool=true)\n\nReturn the n-the root of x. We require n  0 and that x geq 0 if n is even. By default the function tests whether the input was a perfect n-th power and if not raises an exception. If check=false this check is omitted.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"iroot(::fmpz, ::Int)","category":"page"},{"location":"integer/#AbstractAlgebra.iroot-Tuple{fmpz, Int64}","page":"Integers","title":"AbstractAlgebra.iroot","text":"iroot(x::fmpz, n::Int)\n\nReturn the integer truncation of the n-the root of x (round towards zero). We require n  0 and that x geq 0 if n is even.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = ZZ(13)\nb = ZZ(27)\n\nc = isqrt(a)\ns, r = isqrtrem(a)\nd = iroot(a, 3)\nk = root(b, 3; check=true)","category":"page"},{"location":"integer/#Number-theoretic-functionality","page":"Integers","title":"Number theoretic functionality","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"divisible(::fmpz, ::Int)\ndivisible(::fmpz, ::fmpz)","category":"page"},{"location":"integer/#Nemo.divisible-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.divisible","text":"divisible(x::fmpz, y::Int)\n\nReturn true if x is divisible by y, otherwise return false. We require x neq 0.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.divisible-Tuple{fmpz, fmpz}","page":"Integers","title":"Nemo.divisible","text":"divisible(x::fmpz, y::fmpz)\n\nReturn true if x is divisible by y, otherwise return false. We require x neq 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"issquare(::fmpz)","category":"page"},{"location":"integer/#AbstractAlgebra.issquare-Tuple{fmpz}","page":"Integers","title":"AbstractAlgebra.issquare","text":"issquare(f::PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"isprime(::fmpz)","category":"page"},{"location":"integer/#Nemo.isprime-Tuple{fmpz}","page":"Integers","title":"Nemo.isprime","text":"isprime(x::fmpz)\n\nReturn true if x is a prime number, otherwise return false.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"isprobable_prime(::fmpz)","category":"page"},{"location":"integer/#Nemo.isprobable_prime-Tuple{fmpz}","page":"Integers","title":"Nemo.isprobable_prime","text":"isprobable_prime(x::fmpz)\n\nReturn true if x is very probably a prime number, otherwise return false. No counterexamples are known to this test, but it is conjectured that infinitely many exist.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"factor(::fmpz)","category":"page"},{"location":"integer/#AbstractAlgebra.factor-Tuple{fmpz}","page":"Integers","title":"AbstractAlgebra.factor","text":"factor(a::fmpz)\nfactor(a::UInt)\nfactor(a::Int)\n\nReturn a factorisation of a using a Fac struct (see the documentation on factorisation in Nemo).\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"divisor_lenstra(::fmpz, ::fmpz, ::fmpz)","category":"page"},{"location":"integer/#Nemo.divisor_lenstra-Tuple{fmpz, fmpz, fmpz}","page":"Integers","title":"Nemo.divisor_lenstra","text":"divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)\n\nIf n has a factor which lies in the residue class r (mod m) for 0  r  m  n, this function returns such a factor. Otherwise it returns 0. This is only efficient if m is at least the cube root of n. We require gcd(r m) = 1 and this condition is not checked.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"factorial(::fmpz)","category":"page"},{"location":"integer/#Base.factorial-Tuple{fmpz}","page":"Integers","title":"Base.factorial","text":"factorial(x::fmpz)\n\nReturn the factorial of x, i.e. x = 123ldots x. We require x geq 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"rising_factorial(::fmpz, ::fmpz)\nrising_factorial(::fmpz, ::Int)\nrising_factorial(::Int, ::Int)","category":"page"},{"location":"integer/#Nemo.rising_factorial-Tuple{fmpz, fmpz}","page":"Integers","title":"Nemo.rising_factorial","text":"rising_factorial(x::fmpz, n::fmpz)\n\nReturn the rising factorial of x, i.e. x(x + 1)(x + 2)cdots (x + n - 1). If n  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/#Nemo.rising_factorial-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.rising_factorial","text":"rising_factorial(x::fmpz, n::Int)\n\nReturn the rising factorial of x, i.e. x(x + 1)(x + 2)ldots (x + n - 1). If n  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/#Nemo.rising_factorial-Tuple{Int64, Int64}","page":"Integers","title":"Nemo.rising_factorial","text":"rising_factorial(x::Int, n::Int)\n\nReturn the rising factorial of x, i.e. x(x + 1)(x + 2)ldots (x + n - 1). If n  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"primorial(::fmpz)\nprimorial(::Int)","category":"page"},{"location":"integer/#Nemo.primorial-Tuple{fmpz}","page":"Integers","title":"Nemo.primorial","text":"primorial(x::fmpz)\n\nReturn the primorial of x, i.e. the product of all primes less than or equal to x. If x  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/#Nemo.primorial-Tuple{Int64}","page":"Integers","title":"Nemo.primorial","text":"primorial(x::Int)\n\nReturn the primorial of x, i.e. the product of all primes less than or equal to x. If x  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"fibonacci(::Int)\nfibonacci(::fmpz)","category":"page"},{"location":"integer/#Nemo.fibonacci-Tuple{Int64}","page":"Integers","title":"Nemo.fibonacci","text":"fibonacci(x::Int)\n\nReturn the x-th Fibonacci number F_x. We define F_1 = 1, F_2 = 1 and F_i + 1 = F_i + F_i - 1 for all integers i.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.fibonacci-Tuple{fmpz}","page":"Integers","title":"Nemo.fibonacci","text":"fibonacci(x::fmpz)\n\nReturn the x-th Fibonacci number F_x. We define F_1 = 1, F_2 = 1 and F_i + 1 = F_i + F_i - 1 for all integers i.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"bell(::fmpz)\nbell(::Int)","category":"page"},{"location":"integer/#Nemo.bell-Tuple{fmpz}","page":"Integers","title":"Nemo.bell","text":"bell(x::fmpz)\n\nReturn the Bell number B_x.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.bell-Tuple{Int64}","page":"Integers","title":"Nemo.bell","text":"bell(x::Int)\n\nReturn the Bell number B_x.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"binomial(::fmpz, ::fmpz)","category":"page"},{"location":"integer/#Base.binomial-Tuple{fmpz, fmpz}","page":"Integers","title":"Base.binomial","text":"binomial(n::fmpz, k::fmpz)\n\nReturn the binomial coefficient fracn(n - k)k. If n k  0 or k  n we return 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"moebius_mu(::Int)\nmoebius_mu(::fmpz)","category":"page"},{"location":"integer/#Nemo.moebius_mu-Tuple{Int64}","page":"Integers","title":"Nemo.moebius_mu","text":"moebius_mu(x::Int)\n\nReturn the Moebius mu function of x as an Int. The value returned is either -1, 0 or 1. If x leq 0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/#Nemo.moebius_mu-Tuple{fmpz}","page":"Integers","title":"Nemo.moebius_mu","text":"moebius_mu(x::fmpz)\n\nReturn the Moebius mu function of x as an Int. The value returned is either -1, 0 or 1. If x leq 0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"jacobi_symbol(::Int, ::Int)\njacobi_symbol(::fmpz, ::fmpz)","category":"page"},{"location":"integer/#Nemo.jacobi_symbol-Tuple{Int64, Int64}","page":"Integers","title":"Nemo.jacobi_symbol","text":"jacobi_symbol(x::Int, y::Int)\n\nReturn the value of the Jacobi symbol left(fracxyright). The modulus y must be odd and positive, otherwise a DomainError is thrown.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.jacobi_symbol-Tuple{fmpz, fmpz}","page":"Integers","title":"Nemo.jacobi_symbol","text":"jacobi_symbol(x::fmpz, y::fmpz)\n\nReturn the value of the Jacobi symbol left(fracxyright). The modulus y must be odd and positive, otherwise a DomainError is thrown.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"divisor_sigma(::Int, ::Int)\ndivisor_sigma(::fmpz, ::Int)\ndivisor_sigma(::fmpz, ::fmpz)","category":"page"},{"location":"integer/#Nemo.divisor_sigma-Tuple{Int64, Int64}","page":"Integers","title":"Nemo.divisor_sigma","text":"divisor_sigma(x::Int, y::Int)\n\nReturn the value of the sigma function, i.e. sum_0  d  x d^y. If x leq 0 or y  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/#Nemo.divisor_sigma-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.divisor_sigma","text":"divisor_sigma(x::fmpz, y::Int)\n\nReturn the value of the sigma function, i.e. sum_0  d  x d^y. If x leq 0 or y  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/#Nemo.divisor_sigma-Tuple{fmpz, fmpz}","page":"Integers","title":"Nemo.divisor_sigma","text":"divisor_sigma(x::fmpz, y::fmpz)\n\nReturn the value of the sigma function, i.e. sum_0  d  x d^y. If x leq 0 or y  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"euler_phi(::Int)\neuler_phi(::fmpz)","category":"page"},{"location":"integer/#Nemo.euler_phi-Tuple{Int64}","page":"Integers","title":"Nemo.euler_phi","text":"euler_phi(x::Int)\n\nReturn the value of the Euler phi function at x, i.e. the number of positive integers up to x (inclusive) that are coprime with x. An exception is raised if x leq 0.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.euler_phi-Tuple{fmpz}","page":"Integers","title":"Nemo.euler_phi","text":"euler_phi(x::fmpz)\n\nReturn the value of the Euler phi function at x, i.e. the number of positive integers up to x (inclusive) that are coprime with x. An exception is raised if x leq 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"number_of_partitions(::Int)\nnumber_of_partitions(::fmpz) ","category":"page"},{"location":"integer/#Nemo.number_of_partitions-Tuple{Int64}","page":"Integers","title":"Nemo.number_of_partitions","text":"number_of_partitions(x::Int)\n\nReturn the number of partitions of x. This function is not available on Windows 64.\n\n\n\n","category":"method"},{"location":"integer/#Nemo.number_of_partitions-Tuple{fmpz}","page":"Integers","title":"Nemo.number_of_partitions","text":"number_of_partitions(x::fmpz)\n\nReturn the number of partitions of x. This function is not available on Windows 64.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"isprime(ZZ(13))\nn = factorial(ZZ(100))\ns = divisor_sigma(ZZ(128), 10)\na = euler_phi(ZZ(12480))\np = number_of_partitions(ZZ(1000))\nf = factor(ZZ(12))","category":"page"},{"location":"integer/#Digits-and-bases","page":"Integers","title":"Digits and bases","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"bin(::fmpz)","category":"page"},{"location":"integer/#Base.bin-Tuple{fmpz}","page":"Integers","title":"Base.bin","text":"bin(n::fmpz)\n\nReturn n as a binary string.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"oct(::fmpz)","category":"page"},{"location":"integer/#Base.oct-Tuple{fmpz}","page":"Integers","title":"Base.oct","text":"oct(n::fmpz)\n\nReturn n as a octal string.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"dec(::fmpz)","category":"page"},{"location":"integer/#Base.dec-Tuple{fmpz}","page":"Integers","title":"Base.dec","text":"dec(n::fmpz)\n\nReturn n as a decimal string.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"hex(::fmpz)","category":"page"},{"location":"integer/#Base.hex-Tuple{fmpz}","page":"Integers","title":"Base.hex","text":"hex(n::fmpz) = base(n, 16)\n\nReturn n as a hexadecimal string.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"base(::fmpz, ::Integer)","category":"page"},{"location":"integer/#Nemo.base-Tuple{fmpz, Integer}","page":"Integers","title":"Nemo.base","text":"base(n::fmpz, b::Integer)\n\nReturn n as a string in base b. We require 2 leq b leq 62.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"ndigits(::fmpz, ::Integer)","category":"page"},{"location":"integer/#Base.ndigits-Tuple{fmpz, Integer}","page":"Integers","title":"Base.ndigits","text":"ndigits(x::fmpz, b::Integer)\n\nReturn the number of digits of x in the base b (default is b = 10).\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"nbits(::fmpz)","category":"page"},{"location":"integer/#Nemo.nbits-Tuple{fmpz}","page":"Integers","title":"Nemo.nbits","text":"nbits(x::fmpz)\n\nReturn the number of binary bits of x. We return zero if x = 0.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\n\ns1 = bin(a)\ns2 = base(a, 13)\nn1 = nbits(a)\nn2 = ndigits(a, 3)","category":"page"},{"location":"integer/#Bit-twiddling","page":"Integers","title":"Bit twiddling","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"popcount(::fmpz)","category":"page"},{"location":"integer/#Nemo.popcount-Tuple{fmpz}","page":"Integers","title":"Nemo.popcount","text":"popcount(x::fmpz)\n\nReturn the number of ones in the binary representation of x.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"prevpow2(::fmpz)","category":"page"},{"location":"integer/#Nemo.prevpow2-Tuple{fmpz}","page":"Integers","title":"Nemo.prevpow2","text":"prevpow2(x::fmpz)\n\nReturn the previous power of 2 up to including x.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"nextpow2(::fmpz)","category":"page"},{"location":"integer/#Nemo.nextpow2-Tuple{fmpz}","page":"Integers","title":"Nemo.nextpow2","text":"nextpow2(x::fmpz)\n\nReturn the next power of 2 that is at least x.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"trailing_zeros(::fmpz)","category":"page"},{"location":"integer/#Base.trailing_zeros-Tuple{fmpz}","page":"Integers","title":"Base.trailing_zeros","text":"trailing_zeros(x::fmpz)\n\nReturn the number of trailing zeros in the binary representation of x.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"clrbit!(::fmpz, ::Int)","category":"page"},{"location":"integer/#Nemo.clrbit!-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.clrbit!","text":"clrbit!(x::fmpz, c::Int)\n\nClear bit c of x, where the least significant bit is the 0-th bit. Note that this function modifies its input in-place.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"setbit!(::fmpz, ::Int)","category":"page"},{"location":"integer/#Nemo.setbit!-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.setbit!","text":"setbit!(x::fmpz, c::Int)\n\nSet bit c of x, where the least significant bit is the 0-th bit. Note that this function modifies its input in-place.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"combit!(::fmpz, ::Int)","category":"page"},{"location":"integer/#Nemo.combit!-Tuple{fmpz, Int64}","page":"Integers","title":"Nemo.combit!","text":"combit!(x::fmpz, c::Int)\n\nComplement bit c of x, where the least significant bit is the 0-th bit. Note that this function modifies its input in-place.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\n\np = popcount(a)\nb = nextpow2(a)\ncombit!(a, 2)","category":"page"},{"location":"integer/#Random-generation","page":"Integers","title":"Random generation","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"rand_bits(::FlintIntegerRing, ::Int)","category":"page"},{"location":"integer/#Nemo.rand_bits-Tuple{FlintIntegerRing, Int64}","page":"Integers","title":"Nemo.rand_bits","text":"rand_bits(::FlintIntegerRing, b::Int)\n\nReturn a random signed integer whose absolute value has b bits.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"rand_bits_prime(::FlintIntegerRing, ::Int, ::Bool)","category":"page"},{"location":"integer/#Nemo.rand_bits_prime-Tuple{FlintIntegerRing, Int64, Bool}","page":"Integers","title":"Nemo.rand_bits_prime","text":"rand_bits_prime(::FlintIntegerRing, n::Int, proved::Bool=true)\n\nReturn a random prime number with the given number of bits. If only a probable prime is required, one can pass proved=false.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = rand_bits(ZZ, 23)\nb = rand_bits_prime(ZZ, 7)","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"CurrentModule = Nemo","category":"page"},{"location":"mpolynomial/#Multivariate-polynomials","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"","category":"section"},{"location":"mpolynomial/#Introduction","page":"Multivariate polynomials","title":"Introduction","text":"","category":"section"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Nemo allow the creation of sparse, distributed multivariate polynomials over any computable ring R. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The following table shows each of the polynomial types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.MPoly{T} Generic.MPolyRing{T}\nmathbbZ Flint fmpz_mpoly FmpzMPolyRing\nmathbbZnmathbbZ (small n) Flint nmod_mpoly NmodMPolyRing\nmathbbQ Flint fmpq_mpoly FmpqMPolyRing","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The following are not implemented yet, but will be available soon:","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Base ring Library Element type Parent type\nmathbbZpmathbbZ (small prime p) Flint gfp_mpoly GFPMPolyRing\nmathbbF_p^n (small p) Flint fq_nmod_mpoly FqNmodMPolyRing","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The string representation of the variables and the base ring R of a generic polynomial is stored in its parent object. ","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"All polynomial element types belong to the abstract type MPolyElem and all of the polynomial ring types belong to the abstract type MPolyRing. This enables one to write generic functions that can accept any Nemo multivariate polynomial type.","category":"page"},{"location":"mpolynomial/#Polynomial-functionality","page":"Multivariate polynomials","title":"Polynomial functionality","text":"","category":"section"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"All multivariate polynomial types in Nemo provide the multivariate polynomial functionality described by AbstractAlgebra:","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Generic multivariate polynomials are also available.","category":"page"},{"location":"mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"We describe here only functions that are in addition to that guaranteed by AbstractAlgebra.jl, for specific coefficient rings.","category":"page"},{"location":"#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Nemo is a computer algebra package for the Julia programming language, maintained by William Hart,  Tommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak, Marek Kaluba and other contributors.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"https://nemocas.org (Website)\nhttps://github.com/Nemocas/Nemo.jl (Source code)\nhttps://nemocas.github.io/Nemo.jl/latest/ (Online documentation)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The features of Nemo so far include:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Multiprecision integers and rationals\nIntegers modulo n\np-adic numbers\nFinite fields (prime and non-prime order)\nNumber field arithmetic\nAlgebraic numbers\nExact real and complex numbers\nArbitrary precision real and complex balls\nUnivariate and multivariate polynomials and matrices over the above","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Nemo depends on AbstractAlgebra.jl which provides Nemo with generic routines for:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Univariate and multivariate polynomials\nAbsolute and relative power series\nLaurent series\nFraction fields\nResidue rings\nMatrices and linear algebra\nYoung Tableaux\nPermutation groups\nCharacters","category":"page"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"To use Nemo we require Julia 1.0 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg; Pkg.add(\"Nemo\")","category":"page"},{"location":"#Quick-start","page":"Getting Started","title":"Quick start","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Here are some examples of using Nemo.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"This example computes recursive univariate polynomials.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia> T, z = PolynomialRing(S, \"z\")\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia> f = x + y + z + 1\nz+(y+(x+1))\n\njulia> p = f^30; # semicolon supresses output\n\njulia> @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Here is an example using generic recursive ring constructions.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = FiniteField(7, 11, \"x\")\n(Finite field of degree 11 over F_7,x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia> T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia> U, z = PolynomialRing(T, \"z\")\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia> f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia> g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia> s = f^12;\n\njulia> t = (s + g)^12;\n\njulia> @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Here is an example using matrices.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia> S = MatrixSpace(R, 40, 40)\nMatrix Space of 40 rows and 40 columns over Univariate Polynomial Ring in x over Integer Ring\n\njulia> M = rand(S, 2:2, -20:20)\n\njulia> @time det(M);\n  0.131212 seconds (1.12 M allocations: 39.331 MiB, 4.77% gc time)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"And here is an example with power series.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = QQ[\"x\"]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia> S, t = PowerSeriesRing(R, 100, \"t\")\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia> u = t + O(t^100)\nt+O(t^100)\n\njulia> @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)","category":"page"},{"location":"#Building-dependencies-from-source","page":"Getting Started","title":"Building dependencies from source","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Nemo depends on various C libraries which are installed using binaries by default. With julia version >= 1.3, the use of these binaries can be overridden by putting the following into the file ~/.julia/artifacts/Overrides.toml:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"[e134572f-a0d5-539d-bddf-3cad8db41a82]\nFLINT = \"/prefix/for/libflint\"\n\n[d9960996-1013-53c9-9ba4-74a4155039c3]\nArb = \"/prefix/for/libarb\"\n\n[e21ec000-9f72-519e-ba6d-10061e575a27]\nAntic = \"/prefix/for/libantic\"","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"(If only a specific library should be overridden, only the specific entry should be added.)","category":"page"},{"location":"#Experimental-threading-support-for-flint","page":"Getting Started","title":"Experimental threading support for flint","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Enabling a threaded version of flint can be done by setting the evironment variable NEMO_THREADED=1. To set the actual number of threads, use Nemo.flint_set_num_threads($numberofthreads).","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"CurrentModule = Nemo","category":"page"},{"location":"developer/conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"AbstractAlgebra and Nemo have adopted a number of conventions to help maintain a uniform codebase.","category":"page"},{"location":"developer/conventions/#Code-conventions","page":"Conventions","title":"Code conventions","text":"","category":"section"},{"location":"developer/conventions/#Function-and-type-names","page":"Conventions","title":"Function and type names","text":"","category":"section"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Names of types in Julia follow the convention of CamelCase where the first letter of each word is capitalised, e.g. Int64 and AbstractString.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Function/method names in Julia use all lowercase with underscores between the words, e.g. zip and jacobi_symbol.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"We follow these conventions in Nemo with some exceptions:","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"When interfacing C libraries the types use the same spelling and capitalisation in Nemo as they do in C, e.g. the Flint library's fmpz_poly remains uncapitalised in Nemo.\nTypes such as gfp_poly which don't exist under that name on the C side also use the lowercase convention as they wrap an actual C type which must be split into more than one type on the Julia side. For example nmod_poly and gfp_poly on the Julia side both represent Flint nmod_poly's on the C side.\nTypes of rings and fields, modules, maps, etc. are capitalised whether they correspond to a C type or not, e.g. FqNmodFiniteField for the type of an object representing the field that fq_nmod's belong to.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":".","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"We omit an underscore if the first word of a method is \"is\" or \"has\", e.g. iseven.\nUnderscores are omitted if the method name is already well established without an underscore in Julia itself, e.g. setindex.\nConstructors with the same name as a type use the same spelling and capitalisation as that type, e.g. fmpz(1).\nFunctions for creating rings, fields, modules, maps, etc. (rather than the elements thereof) use CamelCase, e.g. PolynomialRing. We refer to these  functions as parent constructors. Note that we do not follow the Julia convention here, e.g. PolynomialRing is a function and not a type constructor (in fact we often return a tuple consisting of a parent object and other objects such as generators with this type of function) yet we capitalise it.\nWe prefer words to not be abbreviated, e.g. denominator instead of den.\nExceptions always exist where the result would be offensive in any major spoken language (example omitted).","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"It is easy to find counterexamples to virtually all these rules. However we have been making efforts to remove the most egregious cases from our codebase over time. As perfect consistency is not possible, work on this has to at times take a back seat.","category":"page"},{"location":"developer/conventions/#Use-of-ASCII-characters","page":"Conventions","title":"Use of ASCII characters","text":"","category":"section"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"All code and printed output in Nemo should use ASCII characters only. This is because we have developers who are using versions of the WSL that cannot correctly display non-ASCII characters.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"This extends to function and operator names, which saves people having to learn how to enter them to use the system.","category":"page"},{"location":"developer/conventions/#Spacing-and-tabs","page":"Conventions","title":"Spacing and tabs","text":"","category":"section"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"All function bodies and control blocks should be indented using spaces.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"A survey of existing code shows 2, 3 or 4 space indenting commonly used in our files. Values outside this range should not be used.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"When contributing to an existing file, follow the majority convention in that file. Consistency within a file is valued highly.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"If you are new to Nemo development and do not already have a very strong preference, new files should be started with 3 space indenting. This maximises the likelihood that copy and paste between files will be straightforward, though modern editors ease this to some degree.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Function signatures in docstrings should have four spaces before them.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Where possible, line lengths should not exceed 80 characters.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"We use a term/factor convention for spacing. This means that all (additive) terms have spaces before and after them, (multiplicative) factors usually do not.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"In practice this means that +, -, =, ==, !=, <, >, <=, >= all have spaces before and after them. The operators *, /, ^ and unary minus do not.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"As per English, commas are followed by a single space in expressions. This applies for example to function arguments and tuples.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"We do not put spaces immediately inside or before parentheses.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Colons used for ranges do not have spaces before or after them.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Logical operators, &, |, &&, etc. usually have spaces before and after them.","category":"page"},{"location":"developer/conventions/#Comments","page":"Conventions","title":"Comments","text":"","category":"section"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Despite appearances to the contrary, we now prefer code comments explaining the algorithm as it proceeds.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"The hash when used for a comment should always be followed by a space. Full sentences are preferred.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"We do not generally use comments in Nemo for questions, complaints or proposals for future improvement. These are better off in a ticket on GitHub with a discussion that will be brought to the attention of all relevant parties.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Any (necessary) limitations of the implementation should be noted in docstrings.","category":"page"},{"location":"developer/conventions/#Layout-of-files","page":"Conventions","title":"Layout of files","text":"","category":"section"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"In Nemo, all types are places in special files with the word \"Types\" in their name, e.g. FlintTypes.jl. This is because Julia must be aware of all types before they are used. Separation of types from implementations makes it easy to ensure this happens.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Abstract types should be put in the file called AbstractTypes.jl at the top level of the src directory.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Most implementation files present functions in a particular order, which is as follows:","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"A header stating what the file is for, and if needed, any copyright notices\nFunctions applying to any \"types\" used in the file, e.g. parent_type, elem_type, base_ring, parent, check_parent.\nBasic manipulation, including hashes, predicates, getters/setters, functions for creating special values (e.g. one, zero and the like), deepcopy_internal. These are usually fairly short functions, often a single line.\nIndexing (getindex, setindex), iteration, views.\nString I/O (expressify and file access, etc.)\nArithmetic operations, usually in multiple sections, such as unary operations, binary operations, ad hoc binary operations (e.g. multiplication of a complex object by a scalar), comparisons, ad hoc comparisons, division, etc.\nMore complex functionality separated into sections based on functionality provided, e.g. gcd, interpolation, special functions, solving, etc.\nFunctions for mapping between different types, coercion, changing base ring, etc.\nUnsafe operators, e.g. mul!, add!, addeq! etc.\nRandom generation\nPromotion rules\nParent object call overload (e.g. for implementing R(2) where R is an object representing a ring or field, etc.)\nAdditional constructors, e.g. matrix, which might be used instead of a parent object to construct elements.\nParent object constructors, e.g. PolynomialRing, etc.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"The exact order within the file is less important than generally following something like the above. This aids in finding functions in a file since all files are more or less set out the same way.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"For an example to follow, see the src/Poly.jl and src/generic/Poly.jl files in AbstractAlgebra which form the oldest and most canonical example.","category":"page"},{"location":"developer/conventions/","page":"Conventions","title":"Conventions","text":"Headings for sections should be 80 characters wide and formed of hashes in the style that can be seen in each Nemo file.","category":"page"},{"location":"types/#Types-in-Nemo","page":"Types in Nemo","title":"Types in Nemo","text":"","category":"section"},{"location":"types/","page":"Types in Nemo","title":"Types in Nemo","text":"Nemo is fully compatible with AbstractAlgebra.jl, but specialises implementations of various commonly used rings with a highly optimised C implementation, provided by the C libraries wrapped by Nemo.","category":"page"},{"location":"types/","page":"Types in Nemo","title":"Types in Nemo","text":"Below, we give a list of all of the specialised types available in Nemo that implement rings using a specialised C library. The types of elements of the respective rings and other mathematical structures are given, and in parentheses we list the types of the parent objects of the given rings and structures.","category":"page"},{"location":"types/","page":"Types in Nemo","title":"Types in Nemo","text":"Flint\nfmpz (FlintIntegerRing)\nfmpq (FlintRationalField)\nnmod (NmodRing)\nfmpz_mod (FmpzModRing`)\nfq_nmod (FqNmodFiniteField)\ngfp_elem (GaloisField)\ngfp_fmpz_elem (GaloisFmpzField)\nfq (FqFiniteField)\npadic (FlintPadicField)\nqadic (FlintQadicField)\nfmpz_poly (FmpzPolyRing)\nfmpq_poly (FmpqPolyRing)\nnmod_poly (NmodPolyRing)\nfmpz_mod_poly (FmpzModPolyRing)\nfq_poly (FqPolyRing)\nfq_nmod_poly (FqNmodPolyRing)\nfmpz_mpoly (FmpzMPolyRing)\nfmpq_mpoly (FmpqMPolyRing)\nnmod_mpoly (NmodMPolyRing)\nfq_nmod_mpoly (FqNmodMPolyRing`)\ngfp_poly (GFPPolyRing)\ngfp_fmpz_poly (GFPFmpzPolyRing)\nfmpz_rel_series (FmpzRelSeriesRing)\nfmpz_abs_series (FmpzAbsSeriesRing)\nfmpq_rel_series (FmpqRelSeriesRing)\nfmpq_abs_series (FmpqAbsSeriesRing)\nfmpz_mod_rel_series (FmpzModRelSeriesRing)\nfmpz_mod_abs_series (FmpzModAbsSeriesRing)\nnmod_rel_series (NmodRelSeriesRing)\nnmod_abs_series (NmodAbsSeriesRing)\ngfp_rel_series (GFPRelSeriesRing)\ngfp_abs_series (GFPAbsSeriesRing)\ngfp_fmpz_rel_series (GFPFmpzRelSeriesRing)\ngfp_fmpz_abs_series (GFPFmpzAbsSeriesRing)\nfq_nmod_rel_series (FqNmodRelSeriesRing)\nfq_nmod_abs_series (FqNmodAbsSeriesRing)\nfq_rel_series (FqRelSeriesRing)\nfq_abs_series (FqAbsSeriesRing)\nfmpz_mat (FmpzMatSpace)\nfmpq_mat (FmpqMatSpace)\nnmod_mat (NmodMatSpace)\nfmpz_mod_mat (FmpzModMatSpace`)\nfq_nmod_mat (FqNmodMatSpace)\nfq_mat (FqMatSpace)\ngfp_mat (GFPMatSpace)\nperm (SymmetricGroup)\nAntic\nnf_elem (AnticNumberField)\nArb\narb (ArbField)\nacb (AcbField)\narb_poly (ArbPolyRing)\nacb_poly (AcbPolyRing)\narb_mat (ArbMatSpace)\nacb_mat (AcbMatSpace)\nCalcium\nqqbar (CalciumQQBarField)\nca (CalciumField)","category":"page"}]
}
