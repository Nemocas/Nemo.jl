<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · Nemo.jl</title><meta name="title" content="Interfaces · Nemo.jl"/><meta property="og:title" content="Interfaces · Nemo.jl"/><meta property="twitter:title" content="Interfaces · Nemo.jl"/><meta name="description" content="Documentation for Nemo.jl."/><meta property="og:description" content="Documentation for Nemo.jl."/><meta property="twitter:description" content="Documentation for Nemo.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Nemo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><a class="tocitem" href="../../about/">About Nemo</a></li><li><a class="tocitem" href="../../types/">Types in Nemo</a></li><li><a class="tocitem" href="../../constructors/">Constructing mathematical objects in Nemo</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../integer/">Integers</a></li><li><a class="tocitem" href="../../polynomial/">Univariate polynomials</a></li><li><a class="tocitem" href="../../mpolynomial/">Multivariate polynomials</a></li><li><a class="tocitem" href="../../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../puiseux/">Puiseux series</a></li><li><a class="tocitem" href="../../residue/">Residue rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../fraction/">Fraction fields</a></li><li><a class="tocitem" href="../../rational/">Rationals</a></li><li><a class="tocitem" href="../../algebraic/">Algebraic numbers</a></li><li><a class="tocitem" href="../../exact/">Exact real and complex numbers</a></li><li><a class="tocitem" href="../../complex/">Arbitrary precision complex balls</a></li><li><a class="tocitem" href="../../real/">Arbitrary precision real balls</a></li><li><a class="tocitem" href="../../arb/">Fixed precision real balls</a></li><li><a class="tocitem" href="../../acb/">Fixed precision complex balls</a></li><li><a class="tocitem" href="../../gfp/">Galois fields</a></li><li><a class="tocitem" href="../../finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../ff_embedding/">Finite field embeddings</a></li><li><a class="tocitem" href="../../numberfield/">Number field arithmetic</a></li><li><a class="tocitem" href="../../padic/">Padics</a></li><li><a class="tocitem" href="../../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../matrix/">Matrices</a></li><li><a class="tocitem" href="../../factor/">Factorisation</a></li><li><a class="tocitem" href="../../misc/">Miscellaneous</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../introduction/">Introduction to Nemo development</a></li><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><a class="tocitem" href="../typesystem/">The type system</a></li><li><a class="tocitem" href="../parents/">Parent objects</a></li><li class="is-active"><a class="tocitem" href>Interfaces</a><ul class="internal"><li><a class="tocitem" href="#Functionality-for-Generic-and-Abstract-Types"><span>Functionality for Generic and Abstract Types</span></a></li><li><a class="tocitem" href="#Generic-interfaces"><span>Generic interfaces</span></a></li><li><a class="tocitem" href="#Julia-interfaces-we-support"><span>Julia interfaces we support</span></a></li><li><a class="tocitem" href="#Column-major-vs-row-major-matrices"><span>Column major vs row major matrices</span></a></li></ul></li><li><a class="tocitem" href="../topics/">Specific topics</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer</a></li><li class="is-active"><a href>Interfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interfaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/Nemo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/developer/interfaces.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h1><h2 id="Functionality-for-Generic-and-Abstract-Types"><a class="docs-heading-anchor" href="#Functionality-for-Generic-and-Abstract-Types">Functionality for Generic and Abstract Types</a><a id="Functionality-for-Generic-and-Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Functionality-for-Generic-and-Abstract-Types" title="Permalink"></a></h2><p>As previously mentioned, Nemo provides various generic types, e.g. <code>Poly{T}</code> for generic univariate polynomials and <code>Mat{T}</code> for generic matrices over a base ring. These and other polynomial and matrix types belong in turn to abstract types or unions thereof, e.g. <code>PolyRingElem{T}</code> is an abstract type representing all univariate polynomial types and <code>MatrixElem{T}</code> is a union of all Nemo matrix types.</p><p>When implementing generic functionality, one should usually implement it for the abstract types and unions thereof, since the new functionality will then work for all types of the specified kind, instead of just the generic types.</p><p>In order for this to work in practice, such implementations can only use functions in the relevant official interface. These are the functions required to be implemented by all types of that kind. For example, matrix implementations make heavy use of <code>addeq!</code> and <code>mul!</code> to accumulate entries, but they cannot make use of functions such as <code>subeq!</code> as it is not part of the official interface.</p><p>In addition to implementations for abstract types and their unions, one may also like to provide specialised implementations for the generic types e.g. <code>Poly{T}</code> and <code>Mat{T}</code> as one would for other specialised types. The generic types are based on Julia arrays internally, and so it makes perfect sense to implement lower level functionality for these types specifically, as this may lead to performance gains. Such specialised implementations can make use of any functions provided for the generic types, whether in the interface or not.</p><p>For convenience we list the most important abstract types and their unions for which one should usually prefer to write generic implementations.</p><ul><li><code>PolyRingElem{T}</code> : all univariate polynomial types</li><li><code>MPolyRingElem{T}</code> : all multivariate polynomial types (see note below)</li><li><code>MatrixElem{T}</code> : union of all matrix types including matrix algebras</li><li><code>MatElem{T}</code> : all matrix types not including matrix algebras</li><li><code>AbsPowerSeriesRingElem{T}</code> : all abstract series types</li><li><code>RelPowerSeriesRingElem{T}</code> : all relative series types</li><li><code>LaurentSeriesElem{T}</code> : union of all Laurent series over rings and fields</li><li><code>PuiseuxSeriesElem{T}</code> : union of all Puiseux series over rings and fields</li><li><code>FPModule{T}</code> : all finitely presented modules over a Euclidean domain</li><li><code>FPModuleElem{T}</code> : all elems of fin. presented modules over a Euc. domain</li><li><code>FracElem{T}</code> : all fractions</li><li><code>ResElem{T}</code> : all elements of a residue ring</li><li><code>ResFieldElem{T}</code> : all elements of a residue field</li><li><code>Map{D, C}</code> : all maps (see Maps developer docs for a description)</li></ul><p>N.B: inside the <code>Generic</code> submodule of AbstractAlgebra some abstract types <code>Blah</code> are only accessible by writing <code>AbstractAlgebra.Blah</code>. The unions are directly accessible. There may be generic types and abstract types with the same name, so this is more than just a convention.</p><p>Note that multivariate polynomials tend to require very specialised implementations depending heavily on implementation details of the specific multivariate type. Therefore it is rare to write implementations for the abstract type <code>MPolyRingElem{T}</code>. Instead, implementations tend to be done for each concrete multivariate type separately.</p><h2 id="Generic-interfaces"><a class="docs-heading-anchor" href="#Generic-interfaces">Generic interfaces</a><a id="Generic-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-interfaces" title="Permalink"></a></h2><p>As mentioned above, the generic implementations in Nemo depend on carefully written interfaces for each of the abstract types provided by the system.</p><p>These interfaces are spelled out in the AbstractAlgebra documentation. Note that a generic implementation may depend on functions in both the required and optional interfaces as the optional functions are all implemented with generic fallbacks in terms of the required functions.</p><p>For convenience we provide here a list of interfaces that can be relied on in generic implementations, along with a description.</p><ul><li>Ring : all commutative rings in the system</li><li>Field : all fields in the system</li><li>NCRing : all rings in the system (not necessarily commutative)</li><li>Euclidean Ring : Euclidean rings (see notes below)</li><li>Univariate Polynomial Ring : all dense univariate polynomials</li><li>Multivariate Polynomial Ring : all sparse distributed multivariate polys.</li><li>Series Ring : all series, relative and absolute</li><li>Residue Ring : all quotients of gcd domains with <code>gcdx</code> by a principal ideal</li><li>Fraction Field : all fractions over a gcd domain with <code>gcdx</code></li><li>Module : all finitely presented modules over a Euclidean domain</li><li>Matrix : all matrices over a commutative ring</li><li>Map : all (set) maps in the system</li></ul><p>Although we allow <code>Z/nZ</code> in our definition of Euclidean ring, much of the functionality in Nemo can be expected to misbehave (impossible inverses, etc.) when working with Euclidean rings that are not domains. In some cases the algorithms just don&#39;t exist, and in other cases we simply haven&#39;t implemented the required functionality to support all Euclidean rings for which computations can be done.</p><p>Whether a ring is a Euclidean domain or not cannot be encoded in the type. Thus there is no abstract type for Euclidean domains or their elements. Instead, generic functions rely on the existence of certain functions such as <code>gcdx</code> to implement functionality for Euclidean domains.</p><p>There is also currently no way to define a Euclidean function for a given ring (which is known to be Euclidean) and have the system recognise the ring as such. This kind of Euclidean interface may be provided in a future version of Nemo.</p><h2 id="Julia-interfaces-we-support"><a class="docs-heading-anchor" href="#Julia-interfaces-we-support">Julia interfaces we support</a><a id="Julia-interfaces-we-support-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-interfaces-we-support" title="Permalink"></a></h2><p>Many Julia interfaces rely on being able to create zero and one elements given the type only. As we use the parent/element model (see developer notes on this topic) we cannot support all Julia interfaces fully.</p><p>We do however partially implement some Julia interfaces.</p><ul><li><p>Iteration : iterators are currently provided for multivariate polynomials to iterate over the coefficients, terms and monomials. Nemo matrices can also be iterated over. Iteration proceeds down each column in turn. One can also iterate over all permutations and partitions. Finally, all finite field types can be iterated over.</p></li><li><p>Views : because C libraries cannot be expected to implement the full range of Julia view types, views of matrices in Nemo can only be constructed for submatrices consisting of contiguous blocks in the original matrix.</p></li><li><p><code>map</code> and <code>similar</code> : we implement the map and similar interfaces with the caveat that we generally use parent objects where Julia would use types. See the specific documentation for the module of interest to see details.</p></li><li><p><code>zero</code> and <code>one</code> : these are implemented for parent types, which is not what Julia typically expects. Exceptions include the Flint <code>ZZRingElem</code> and <code>QQFieldElem</code> types, as their parents are not parameterised, which makes it possible to implement these functions for the types as well as the parents.</p></li><li><p><code>rand</code> : we have a Nemo specific <code>rand</code> interface, which passes the tail of a given <code>rand</code> invocation to the <code>rand</code> function for the base ring, e.g. to create random matrix elements or polynomial coefficients and so on. In addition to this custom <code>rand</code> interface, we also support much of the Julia <code>rand</code> interface, with the usual caveat that we use parent objects instead of types where necessary.</p></li><li><p>serialisation : unfortunately this is currently NOT implemented by Nemo, but we would certainly like to see that done in the future. It&#39;s not automatic because of the C objects that underly many of our constructions.</p></li><li><p><code>Number</code> : Nemo number types do NOT belong to Julia&#39;s <code>Number</code> hierarchy, as we must make all our ring element types belong to our <code>RingElem</code> abstract type. To make some Julia <code>Number</code> types cooperate with Nemo, we define the unions <code>RingElement</code> and <code>FieldElement</code> which include some Julia types, such as <code>BigInt</code> and <code>Rational{BigInt}</code>, etc. Note that fixed precision integer types cannot be expected to be well-behaved when they overflow. We recommend using Nemo integer types if one wants good performance for small machine word sized integers, but no overflow when the integer becomes large (Nemo integers are based on Flint&#39;s multiprecision <code>ZZRingElem</code> type).</p></li><li><p><code>hash</code> : we implement hash functions for all major element types in Nemo.</p></li><li><p><code>getindex</code>/<code>setindex!</code>/<code>typed_hvcat</code> : we implement these to access elements of Nemo matrices, however see the note below on row major representation. In  addition, we allow creation of matrices using the notation <code>R[a b; c d]</code> etc. This is done by overloading <code>typed_hvcat</code> for the parent object <code>R</code> instead of a type as Julia would normally expect. This produces a Nemo matrix rather than a Julia one. Note that when passed a type, Julia&#39;s <code>typed_hvcat</code> can only construct Julia matrices for Nemo types such as <code>ZZRingElem</code> and <code>QQFieldElem</code> where elements can be constructed from types alone.</p></li></ul><p>Many other Julia interfaces are either not yet implemented or only very partially implemented.</p><h2 id="Column-major-vs-row-major-matrices"><a class="docs-heading-anchor" href="#Column-major-vs-row-major-matrices">Column major vs row major matrices</a><a id="Column-major-vs-row-major-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Column-major-vs-row-major-matrices" title="Permalink"></a></h2><p>Whereas Julia uses column major representation for its matrices, Nemo follows the convention of the C libraries it wraps and uses row major representation. Although Julia 2-D arrays are used internally in Nemo&#39;s generic matrix type, the interface from the perspective of the user is still the Nemo row major convention, not the Julia column major convention.</p><p>In row major representation, some row operations may be able to be performed more cheaply than similar column operations. In column major representation the converse is true. This may mean that some Julia matrix implementations may perform more slowly if naively ported to Nemo matrices, unless suitably modified.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parents/">« Parent objects</a><a class="docs-footer-nextpage" href="../topics/">Specific topics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 7 June 2024 00:02">Friday 7 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
