<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parent objects · Nemo.jl</title><meta name="title" content="Parent objects · Nemo.jl"/><meta property="og:title" content="Parent objects · Nemo.jl"/><meta property="twitter:title" content="Parent objects · Nemo.jl"/><meta name="description" content="Documentation for Nemo.jl."/><meta property="og:description" content="Documentation for Nemo.jl."/><meta property="twitter:description" content="Documentation for Nemo.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Nemo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><a class="tocitem" href="../../about/">About Nemo</a></li><li><a class="tocitem" href="../../types/">Types in Nemo</a></li><li><a class="tocitem" href="../../constructors/">Constructing mathematical objects in Nemo</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../integer/">Integers</a></li><li><a class="tocitem" href="../../polynomial/">Univariate polynomials</a></li><li><a class="tocitem" href="../../mpolynomial/">Multivariate polynomials</a></li><li><a class="tocitem" href="../../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../puiseux/">Puiseux series</a></li><li><a class="tocitem" href="../../residue/">Residue rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../fraction/">Fraction fields</a></li><li><a class="tocitem" href="../../rational/">Rationals</a></li><li><a class="tocitem" href="../../algebraic/">Algebraic numbers</a></li><li><a class="tocitem" href="../../exact/">Exact real and complex numbers</a></li><li><a class="tocitem" href="../../complex/">Arbitrary precision complex balls</a></li><li><a class="tocitem" href="../../real/">Arbitrary precision real balls</a></li><li><a class="tocitem" href="../../arb/">Fixed precision real balls</a></li><li><a class="tocitem" href="../../acb/">Fixed precision complex balls</a></li><li><a class="tocitem" href="../../gfp/">Galois fields</a></li><li><a class="tocitem" href="../../finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../ff_embedding/">Finite field embeddings</a></li><li><a class="tocitem" href="../../numberfield/">Number field arithmetic</a></li><li><a class="tocitem" href="../../padic/">Padics</a></li><li><a class="tocitem" href="../../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../matrix/">Matrices</a></li><li><a class="tocitem" href="../../factor/">Factorisation</a></li><li><a class="tocitem" href="../../misc/">Miscellaneous</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../introduction/">Introduction to Nemo development</a></li><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><a class="tocitem" href="../typesystem/">The type system</a></li><li class="is-active"><a class="tocitem" href>Parent objects</a><ul class="internal"><li><a class="tocitem" href="#The-use-of-parent-objects-in-Nemo"><span>The use of parent objects in Nemo</span></a></li></ul></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../topics/">Specific topics</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer</a></li><li class="is-active"><a href>Parent objects</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parent objects</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/Nemo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/developer/parents.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parent-objects"><a class="docs-heading-anchor" href="#Parent-objects">Parent objects</a><a id="Parent-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-objects" title="Permalink"></a></h1><h2 id="The-use-of-parent-objects-in-Nemo"><a class="docs-heading-anchor" href="#The-use-of-parent-objects-in-Nemo">The use of parent objects in Nemo</a><a id="The-use-of-parent-objects-in-Nemo-1"></a><a class="docs-heading-anchor-permalink" href="#The-use-of-parent-objects-in-Nemo" title="Permalink"></a></h2><h3 id="The-parent/element-model"><a class="docs-heading-anchor" href="#The-parent/element-model">The parent/element model</a><a id="The-parent/element-model-1"></a><a class="docs-heading-anchor-permalink" href="#The-parent/element-model" title="Permalink"></a></h3><p>As for other major computer algebra projects such as Sage and Magma, Nemo uses the parent/element model to manage its mathematical objects.</p><p>As explained in the appendix to the AbstractAlgebra documentation, the standard type/object model used in most programming languages is insufficient for much of mathematics which often requires mathematical structures parameterised by other objects.</p><p>For example a quotient ring by an ideal would be parameterised by the ideal. The ideal is an object in the system and not a type and so parameterised types are not sufficient to represent such quotient rings.</p><p>This means that each mathematical &quot;domain&quot; in the system (set, group, ring, field, module, etc.) must be represented by an object in the system, rather than a type. Such objects are called parent objects.</p><p>Just as one would write <code>typeof(a)</code> to get the type of an object <code>a</code> in an object/type system of a standard programming language, we write <code>parent(a)</code> to return the parent of the object <code>a</code>.</p><p>When talked about with reference to a parent in this way, the object <code>a</code> is referred to as an <code>element</code> of the parent. Thus the system is divided into elements and parents. For example a polynomial would be an element of a polynomial ring, the latter being the parent of the former.</p><p>Naturally the parent/element system leads to some issues in a programming language not built around this model. We discuss some of these issues below.</p><h3 id="Types-in-the-parent/element-model"><a class="docs-heading-anchor" href="#Types-in-the-parent/element-model">Types in the parent/element model</a><a id="Types-in-the-parent/element-model-1"></a><a class="docs-heading-anchor-permalink" href="#Types-in-the-parent/element-model" title="Permalink"></a></h3><p>As all elements and parents in Nemo are objects, those objects have types which we refer to as the element type and parent type respectively.</p><p>For example, FLINT integers have type <code>ZZRingElem</code> and the parent object they all belong to, <code>ZZ</code> has type <code>ZZRing</code>.</p><p>More complex parents and elements are parameterised. For example, generic univariate polynomials over a base ring <code>R</code> are parameterised by <code>R</code>. The base ring of a ring <code>S</code> can be obtained by the call <code>base_ring(S)</code>.</p><p>We have found it extremely useful to parameterise the type of both the parent and element objects of such a ring by the type of the elements of the base ring. Thus for example, a generic polynomial with FLINT integer coefficients would have type <code>Poly{ZZRingElem}</code>.</p><p>In practice FLINT already implements univariate polynomials over FLINT integers, and these have type <code>ZZPolyRingElem</code>. But both <code>ZZPolyRingElem</code> and the generic polynomials <code>Poly{ZZRingElem}</code> belong to the abstract type <code>PolyRingElem{ZZRingElem}</code> making it possible to write functions for all univariate polynomials over FLINT integers.</p><p>Given a specific element type or parent type it is possible to compute one from the other with the functions <code>elem_type</code> and <code>parent_type</code>. For example <code>parent_type(ZZPolyRingElem)</code> returns <code>ZZPolyRing</code> and <code>elem_type(ZZPolyRing)</code> returns <code>ZZPolyRingElem</code>. Similarly <code>parent_type(Generic.Poly{ZZRingElem})</code> returns <code>Generic.PolyRing{ZZRingElem}</code> and so on.</p><p>These functions are especially useful when writing type assertions or constructing arrays of elements insides function where only the parent object was passed.</p><h3 id="Other-functions-for-computing-types"><a class="docs-heading-anchor" href="#Other-functions-for-computing-types">Other functions for computing types</a><a id="Other-functions-for-computing-types-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions-for-computing-types" title="Permalink"></a></h3><p>Sometimes one needs to know the type of a polynomial or matrix one would obtain if it were constructed over a given ring or with coefficients/entries of a given element type.</p><p>This is especially important in generic code where it may not even be known which Julia package is being used. The user may be expecting an AbstractAlgebra object, a Nemo object or even some other kind of object to be constructed, depending on which package they are using.</p><p>The function for returning the correct type for a dense matrix is <code>dense_matrix_type</code> to which one can pass either a base ring or an element type. For example, if AbstractAlgebra is being used, <code>dense_matrix_type(ZZ)</code> will return <code>Mat{BigInt}</code> whereas if Nemo is being used it will return <code>ZZMatrix</code>.</p><p>We also have <code>dense_poly_type</code> for univariate polynomials, <code>abs_series_type</code> for absolute series and <code>rel_series_type</code> for relative series.</p><p>In theory such functions should exist for all major object types, however they have in most cases not been implemented yet.</p><h3 id="Functions-for-creating-objects-of-a-similar-type"><a class="docs-heading-anchor" href="#Functions-for-creating-objects-of-a-similar-type">Functions for creating objects of a similar type</a><a id="Functions-for-creating-objects-of-a-similar-type-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-creating-objects-of-a-similar-type" title="Permalink"></a></h3><p>A slightly more consistent interface for creating objects of a type that is suitable for the package currently in use is the <code>similar</code> interface.</p><p>For example, given a matrix <code>M</code> one can create one with the same dimensions but over a different ring <code>R</code> by calling <code>similar(M, R)</code>. Likewise one can create one over the same ring with different dimensions <code>r x c</code> by calling <code>similar(M, r, c)</code>.</p><p>The <code>similar</code> system is sophisticated enough to know that there is no native type provided by FLINT/Antic for matrices and polynomials over a number field. The system knows that in such cases it must create a generic matrix or polynomial over the given number field.</p><p>A great deal of thought went into the design of the <code>similar</code> system so that developers would not be required to implement similar for every pair of types in the package.</p><p>Again this interface should exist for all major Nemo domains, but the functionality is still being implemented in some cases.</p><h3 id="Changing-base-rings-and-map"><a class="docs-heading-anchor" href="#Changing-base-rings-and-map">Changing base rings and map</a><a id="Changing-base-rings-and-map-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-base-rings-and-map" title="Permalink"></a></h3><p>Given a polynomial, matrix or other composite object over a base ring, it is often convenient to create a similar object but with all the entries or coefficients coerced into a different ring.</p><p>For this purpose the function <code>change_base_ring</code> is provided.</p><p>Similarly it may be useful to create the matrix or polynomial that results by applying a given map/function/lambda to each of the entries or coefficients.</p><p>For this purpose Julia&#39;s <code>map</code> function is overloaded. There are also functions specific to polynomials and matrices called <code>map_coefficients</code> and <code>map_entries</code> respectively, which essentially do the same thing.</p><p>Note that the implementation of such functions must make use of the functions discussed above to ensure that a matrix/polynomial of the right type is output.</p><h3 id="Parent-checking"><a class="docs-heading-anchor" href="#Parent-checking">Parent checking</a><a id="Parent-checking-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-checking" title="Permalink"></a></h3><p>When applying binary operations to a pair of elements of a given ring, it is useful to check that they are in fact elements of the same ring. This is not possible by checking the types alone. For example elements of <span>$Z/7Z$</span> and <span>$Z/3Z$</span> would have the same type but different parents (one parameterised by the integer 7, the other by the integer 3).</p><p>In order to perform such a check in a function one uses <code>check_parent(a, b)</code> where <code>a</code> and <code>b</code> are the objects one wishes to assert must have the same parent. If not, an exception is raised by <code>check_parent</code>.</p><h3 id="Parent-object-constructors"><a class="docs-heading-anchor" href="#Parent-object-constructors">Parent object constructors</a><a id="Parent-object-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-object-constructors" title="Permalink"></a></h3><p>Various functions are provided for constructing parent objects. For example a polynomial ring is constructed by calling a <code>polynomial_ring</code> function. Such functions are called parent object constructors.</p><p>In general parent object constructors are intended for the user and should only be used with great care in library code. There are a number of reasons for this.</p><p>One issue is that parent objects are allowed to be arbitrarily large, and they are frequently cached by the system. They can also perform arbitrary precomputations for the ring/field/module etc. that is being constructed. This can lead to excessive memory usage. It can also have odd effects when a behavior affecting change is applied to a cached parent and thus has effects in places where one might not expect it. </p><p>Secondly, those parent caches are global objects. This is problematic for any future attempts to parallelise library code. And if the caches are not regularly emptied, in the worst case memory usage can balloon excessively.</p><p>To deal with this, most parent object constructors take a <code>cached</code> keyword which specifies whether the parent object should be cached which library code should generally set to <code>false</code>. That said it is better overall to simply eschew the use of parent object constructors in library code and instead let parents be passed in via arguments (directly or indirectly, e.g. the parent or base ring of some argument might be a suitable parent for some return values or intermediate objects).</p><p>One may also use, where applicable, functions such as <code>similar</code>, <code>zero</code>, <code>zero_matrix</code>, <code>identity_matrix</code>, <code>change_base_ring</code>, <code>map</code>, etc. for constructing polynomials and matrices directly without a parent object.</p><p>However even when using these functions in library code, it is important to remember to pass <code>cached=false</code> so that the cache is not filled up by calls to the library code. This creates an additional problem, namely that if one uses <code>polynomial</code> say, to construct two polynomials over the same base ring, they will not be compatible in the sense that they will have different parents.</p><p>Forcing the creation of full parent objects into as few bottlenecks as possible will make it much easier for developers to remove problems associated with such calls when they arise in future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../typesystem/">« The type system</a><a class="docs-footer-nextpage" href="../interfaces/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 25 February 2025 14:47">Tuesday 25 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
