<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parent objects · Nemo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Nemo.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><a class="tocitem" href="../../about/">About Nemo</a></li><li><a class="tocitem" href="../../types/">Types in Nemo</a></li><li><a class="tocitem" href="../../constructors/">Constructing mathematical objects in Nemo</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../integer/">Integers</a></li><li><a class="tocitem" href="../../polynomial/">Univariate polynomials</a></li><li><a class="tocitem" href="../../mpolynomial/">Multivariate polynomials</a></li><li><a class="tocitem" href="../../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../puiseux/">Puiseux series</a></li><li><a class="tocitem" href="../../residue/">Residue rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../fraction/">Fraction fields</a></li><li><a class="tocitem" href="../../rational/">Rationals</a></li><li><a class="tocitem" href="../../algebraic/">Algebraic numbers</a></li><li><a class="tocitem" href="../../complex/">Exact real and complex numbers</a></li><li><a class="tocitem" href="../../arb/">Real balls</a></li><li><a class="tocitem" href="../../acb/">Complex balls</a></li><li><a class="tocitem" href="../../gfp/">Galois fields</a></li><li><a class="tocitem" href="../../finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../ff_embedding/">Finite field embeddings</a></li><li><a class="tocitem" href="../../numberfield/">Number field arithmetic</a></li><li><a class="tocitem" href="../../padic/">Padics</a></li><li><a class="tocitem" href="../../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../matrix/">Matrices</a></li><li><a class="tocitem" href="../../factor/">Factorisation</a></li><li><a class="tocitem" href="../../misc/">Miscellaneous</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../introduction/">Introduction to Nemo development</a></li><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><a class="tocitem" href="../typesystem/">The type system</a></li><li class="is-active"><a class="tocitem" href>Parent objects</a><ul class="internal"><li><a class="tocitem" href="#The-use-of-parent-objects-in-Nemo"><span>The use of parent objects in Nemo</span></a></li></ul></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../topics/">Specific topics</a></li><li><a class="tocitem" href="../future/">Future plans</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer</a></li><li class="is-active"><a href>Parent objects</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parent objects</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/developer/parents.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Parent-objects"><a class="docs-heading-anchor" href="#Parent-objects">Parent objects</a><a id="Parent-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-objects" title="Permalink"></a></h1><h2 id="The-use-of-parent-objects-in-Nemo"><a class="docs-heading-anchor" href="#The-use-of-parent-objects-in-Nemo">The use of parent objects in Nemo</a><a id="The-use-of-parent-objects-in-Nemo-1"></a><a class="docs-heading-anchor-permalink" href="#The-use-of-parent-objects-in-Nemo" title="Permalink"></a></h2><h3 id="The-parent/element-model"><a class="docs-heading-anchor" href="#The-parent/element-model">The parent/element model</a><a id="The-parent/element-model-1"></a><a class="docs-heading-anchor-permalink" href="#The-parent/element-model" title="Permalink"></a></h3><p>As for other major computer algebra projects such as Sage and Magma, Nemo uses the parent/element model to manage its mathematical objects.</p><p>As explained in the appendix to the AbstractAlgebra documentation, the standard type/object model used in most programming languages is insufficient for much of mathematics which often requires mathematical structures parameterised by other objects.</p><p>For example a quotient ring by an ideal would be parameterised by the ideal. The ideal is an object in the system and not a type and so parameterised types are not sufficient to represent such quotient rings.</p><p>This means that each mathematical &quot;domain&quot; in the system (set, group, ring, field, module, etc.) must be represented by an object in the system, rather than a type. Such objects are called parent objects.</p><p>Just as one would write <code>typeof(a)</code> to get the type of an object <code>a</code> in an object/type system of a standard programming language, we write <code>parent(a)</code> to return the parent of the object <code>a</code>.</p><p>When talked about with reference to a parent in this way, the object <code>a</code> is referred to as an <code>element</code> of the parent. Thus the system is divided into elements and parents. For example a polynomial would be an element of a polynomial ring, the latter being the parent of the former.</p><p>Naturally the parent/element system leads to some issues in a programming language not built around this model. We discuss some of these issues below.</p><h3 id="Types-in-the-parent/element-model"><a class="docs-heading-anchor" href="#Types-in-the-parent/element-model">Types in the parent/element model</a><a id="Types-in-the-parent/element-model-1"></a><a class="docs-heading-anchor-permalink" href="#Types-in-the-parent/element-model" title="Permalink"></a></h3><p>As all elements and parents in Nemo are objects, those objects have types which we refer to as the element type and parent type respectively.</p><p>For example, Flint integers have type <code>fmpz</code> and the parent object they all belong to, <code>FlintZZ</code> has type <code>FlintIntegerRing</code>.</p><p>More complex parents and elements are parameterised. For example, generic univariate polynomials over a base ring <code>R</code> are parameterised by <code>R</code>. The base ring of a ring <code>S</code> can be obtained by the call <code>base_ring(S)</code>.</p><p>We have found it extremely useful to parameterise the type of both the parent and element objects of such a ring by the type of the elements of the base ring. Thus for example, a generic polynomial with Flint integer coefficients would have type <code>Poly{fmpz}</code>.</p><p>In practice Flint already implements univariate polynomials over Flint integers, and these have type <code>fmpz_poly</code>. But both <code>fmpz_poly</code> and the generic polynomials <code>Poly{fmpz}</code> belong to the abstract type <code>PolyElem{fmpz}</code> making it possible to write functions for all univariate polynomials over Flint integers.</p><p>Given a specific element type or parent type it is possible to compute one from the other with the functions <code>elem_type</code> and <code>parent_type</code>. For example <code>parent_type(fmpz_poly)</code> returns <code>FmpzPolyRing</code> and <code>elem_type(FmpzPolyRing)</code> returns <code>fmpz_poly</code>. Similarly <code>parent_type(Generic.Poly{fmpz})</code> returns <code>Generic.PolyRing{fmpz}</code> and so on.</p><p>These functions are especially useful when writing type assertions or constructing arrays of elements insides function where only the parent object was passed.</p><h3 id="Other-functions-for-computing-types"><a class="docs-heading-anchor" href="#Other-functions-for-computing-types">Other functions for computing types</a><a id="Other-functions-for-computing-types-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions-for-computing-types" title="Permalink"></a></h3><p>Sometimes one needs to know the type of a polynomial or matrix one would obtain if it were constructed over a given ring or with coefficients/entries of a given element type.</p><p>This is especially important in generic code where it may not even be known which Julia package is being used. The user may be expecting an AbstractAlgebra object, a Nemo object or even some other kind of object to be constructed, depending on which package they are using.</p><p>The function for returning the correct type for a dense matrix is <code>dense_matrix_type</code> to which one can pass either a base ring or an element type. For example, if AbstractAlgebra is being used, <code>dense_matrix_type(ZZ)</code> will return <code>Mat{BigInt}</code> whereas if Nemo is being used it will return <code>fmpz_mat</code>.</p><p>We also have <code>dense_poly_type</code> for univariate polynomials, <code>abs_series_type</code> for absolute series and <code>rel_series_type</code> for relative series.</p><p>In theory such functions should exist for all major object types, however they have in most cases not been implemented yet.</p><h3 id="Functions-for-creating-objects-of-a-similar-type"><a class="docs-heading-anchor" href="#Functions-for-creating-objects-of-a-similar-type">Functions for creating objects of a similar type</a><a id="Functions-for-creating-objects-of-a-similar-type-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-creating-objects-of-a-similar-type" title="Permalink"></a></h3><p>A slightly more consistent interface for creating objects of a type that is suitable for the package currently in use is the <code>similar</code> interface.</p><p>For example, given a matrix <code>M</code> one can create one with the same dimensions but over a different ring <code>R</code> by calling <code>similar(M, R)</code>. Likewise one can create one over the same ring with different dimensions <code>r x c</code> by calling <code>similar(M, r, c)</code>.</p><p>The <code>similar</code> system is sophisticated enough to know that there is no native type provided by Flint/Antic for matrices and polynomials over a number field. The system knows that in such cases it must create a generic matrix or polynomial over the given number field.</p><p>A great deal of thought went into the design of the <code>similar</code> system so that developers would not be required to implement similar for every pair of types in the package.</p><p>Again this interface should exist for all major Nemo domains, but the functionality is still being implemented in some cases.</p><h3 id="Changing-base-rings-and-map"><a class="docs-heading-anchor" href="#Changing-base-rings-and-map">Changing base rings and map</a><a id="Changing-base-rings-and-map-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-base-rings-and-map" title="Permalink"></a></h3><p>Given a polynomial, matrix or other composite object over a base ring, it is often convenient to create a similar object but with all the entries or coefficients coerced into a different ring.</p><p>For this purpose the function <code>change_base_ring</code> is provided.</p><p>Similarly it may be useful to create the matrix or polynomial that results by applying a given map/function/lambda to each of the entries or coefficients.</p><p>For this purpose Julia&#39;s <code>map</code> function is overloaded. There are also functions specific to polynomials and matrices called <code>map_coefficients</code> and <code>map_entries</code> respectively, which essentially do the same thing.</p><p>Note that the implementation of such functions must make use of the functions discussed above to ensure that a matrix/polynomial of the right type is output.</p><h3 id="Parent-checking"><a class="docs-heading-anchor" href="#Parent-checking">Parent checking</a><a id="Parent-checking-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-checking" title="Permalink"></a></h3><p>When applying binary operations to a pair of elements of a given ring, it is useful to check that they are in fact elements of the same ring. This is not possible by checking the types alone. For example elements of <span>$Z/7Z$</span> and <span>$Z/3Z$</span> would have the same type but different parents (one parameterised by the integer 7, the other by the integer 3).</p><p>In order to perform such a check in a function one uses <code>check_parent(a, b)</code> where <code>a</code> and <code>b</code> are the objects one wishes to assert must have the same parent. If not, an exception is raised by <code>parent_check</code>.</p><h3 id="Parent-object-constructors"><a class="docs-heading-anchor" href="#Parent-object-constructors">Parent object constructors</a><a id="Parent-object-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-object-constructors" title="Permalink"></a></h3><p>Various functions are provided for constructing parent objects. For example a polynomial ring is constructed by calling a <code>PolynomialRing</code> function. Such functions are called parent object constructors.</p><p>In general parent object constructors are intended for the user and should not be used in library code. There are a number of reasons for this.</p><p>Firstly, inside the Generic submodule of AbstractAlgebra the only parent object constructors that are directly accessible are the ones inside Generic. Thus if a Nemo function calls a function inside Generic and it creates a parent object using one of the parent object constructors, it will create a parent object for a generic ring rather than a Nemo one.</p><p>One can work around this by calling <code>AbstractAlgebra.PolynomialRing</code> instead of simply <code>PolynomialRing</code> inside Generic, but even safer would be to find another way to construct the polynomials required.</p><p>A second issue is that parent objects are allowed to be as large as one likes and they are cached by the system. They can also perform arbitrary precomputations for the ring/field/module etc. that is being constructed. Over time they tend to accumulate such precomputations, slowing down all generic code which made use of them. Both memory usage and performance may blow out in previously working code.</p><p>Thirdly, parent objects must be unique across the system for a given set of parameters. This means they must be cached globally. This is problematic for any future attempts to parallelise library code and in the worst case memory usage can balloon due to swelling caches.</p><p>Most parent object constructors take a <code>cached</code> keyword which specifies whether the parent object should be cached or not, but again it is better overall to simply eschew the use of parent object constructors in library code.</p><p>Instead, it is recommended to use functions such as <code>similar</code>, <code>zero</code>, <code>zero_matrix</code>, <code>identity_matrix</code>, <code>change_base_ring</code>, <code>map</code>, etc. for constructing polynomials and matrices directly.</p><p>There are also functions that provide alternative ways of constructing objects, e.g. <code>matrix</code> provides a means of creating a matrix over a given ring with given dimensions. The constructor <code>polynomial</code> allows creation of a polynomial over a given base ring with given coefficients and <code>abs_series</code> and <code>rel_series</code> do similar things for absolute and relative series. These should be used in preference to parent object constructors where possible. Additional functions of this type should be added in future.</p><p>However even when using these functions in library code, it is important to remember to pass <code>cached=false</code> so that the cache is not filled up by calls to the library code. But this creates an additional problem, namely that if one uses <code>polynomial</code> say, to construct two polynomials over the same base ring, they will not be compatible in the sense that they will have different parents.</p><p>When one wishes to construct multiple elements in the same group/ring/field, it is convenient to be able to construct a parent just as a user would. For this purpose various light-weight and very safe parent constructors are provided for use in library code.</p><p>For example there are the constructors <code>PolyRing</code>, <code>AbsSeriesRing</code> and <code>RelSeriesRing</code>. These functions return the parent ring <span>$R$</span> only and no generator (it can be obtained by calling <code>gen(R)</code>). They also set the variable for printing to a default (usually <code>x</code>). Moreover, these parents are not cached, so they are completely safe to use in library code. They can be thousands of times faster than the full parent constructors intended for users.</p><p>Here is an example of their use:</p><pre><code class="language-julia">R = PolyRing(ZZ)
p = R([1, 2, 3])
q = R([2, 3, 4])
s = p + q</code></pre><p>Naturally functions like <code>polynomial</code> and <code>matrix</code> and the light-weight parent constructors are missing for other modules in Nemo at present and it is hoped that developers will fill in such infrastructure rather than simply push the can down the road for someone else to fix. Forcing the creating of full parent objects into as few bottlenecks as possible will make it much easier for developers to remove problems associated with such calls when they arise in future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../typesystem/">« The type system</a><a class="docs-footer-nextpage" href="../interfaces/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 December 2021 09:58">Tuesday 14 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
