<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="X-UA-Compatible"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="William Hart" name="author"/><title>Capped relative power series - Nemo.jl</title><link href="../../img/favicon.ico" rel="shortcut icon"/><link href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css"/><link href="../../css/theme.css" rel="stylesheet" type="text/css"/><link href="../../css/theme_extra.css" rel="stylesheet" type="text/css"/><link href="../../css/highlight.css" rel="stylesheet"/><link href="../../build/assets/Documenter.css" rel="stylesheet"/><script>
    // Current page data
    var mkdocs_page_name = "Capped relative power series";
    var mkdocs_page_input_path = "build/series.md";
    var mkdocs_page_url = "/build/series/";
  </script><script src="../../js/jquery-2.1.1.min.js"></script><script src="../../js/modernizr-2.8.3.min.js"></script><script src="../../js/highlight.pack.js" type="text/javascript"></script><script src="../../js/theme.js"></script><script src="../../mathjaxhelper.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift"><div class="wy-side-nav-search"><a class="icon icon-home" href="../.."> Nemo.jl</a><div role="search"><form action="../../search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li></li><li class="toctree-l1 "><a class="" href="../..">Getting Started</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../../about/">About Nemo</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../../types/">Types in Nemo</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../../constructors/">Parent object constructors</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../polynomial/">Univariate polynomials</a></li><li></li><li></li><li class="toctree-l1 current"><a class="current" href="./">Capped relative power series</a><ul><li class="toctree-l3"><a href="#introduction">Introduction</a></li><li class="toctree-l3"><a href="#capped-relative-power-series">Capped relative power series</a></li><li class="toctree-l3"><a href="#power-series-ring-constructors">Power series ring constructors</a></li><li class="toctree-l3"><a href="#power-series-element-constructors">Power series element constructors</a></li><li class="toctree-l3"><a href="#basic-functionality">Basic functionality</a></li><li class="toctree-l3"><a href="#basic-manipulation">Basic manipulation</a></li><li class="toctree-l3"><a href="#arithmetic-operators">Arithmetic operators</a></li><li class="toctree-l3"><a href="#comparison-operators">Comparison operators</a></li><li class="toctree-l3"><a href="#function">Function</a></li><li class="toctree-l3"><a href="#function_1">Function</a></li><li class="toctree-l3"><a href="#shifting">Shifting</a></li><li class="toctree-l3"><a href="#truncation">Truncation</a></li><li class="toctree-l3"><a href="#inverse">Inverse</a></li><li class="toctree-l3"><a href="#special-functions">Special functions</a></li></ul></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../residue/">Residue rings</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../fraction/">Fraction fields</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../matrix/">Matrices</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../integer/">Integers</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../rational/">Rationals</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../finitefield/">Finite fields</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../padic/">P-adic fields</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../arb/">Real balls</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../acb/">Complex boxes</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../numberfield/">Number fields</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../maximalorder/">Maximal orders</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../classgroup/">Class groups</a></li><li></li><li></li><li class="toctree-l1 "><a class="" href="../perm/">Permutation groups</a></li><li></li></ul></div>
       
    </nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="../..">Nemo.jl</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="../..">Docs</a> »</li><li>Capped relative power series</li><li class="wy-breadcrumbs-aside"><a class="icon icon-github" href="https://github.com/Nemocas/Nemo.jl"> Edit on GitHub</a></li></ul><hr/></div><div role="main"><div class="section"><p><a id="Introduction-1"></a></p><h2 id="introduction">Introduction</h2><p>Nemo allows the creation of capped relative power series over any computable ring <script type="math/tex">R</script>. These are power series of the form <script type="math/tex">a_jx^j + a_{j+1}x^{j+1} + \cdots + a_{k-1}x^{k-1} + O(x^k)</script> where <script type="math/tex">i \geq 0</script>, <script type="math/tex">a_i \in R</script> and the relative precision <script type="math/tex">k - j</script> is at most equal to some specified precision <script type="math/tex">n</script>.</p><p>There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.</p><p>The following table shows each of the relative power series types available in Nemo, the base ring <script type="math/tex">R</script>, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).</p><table><thead><tr><th align="right">Base ring</th><th align="right">Library</th><th align="right">Element type</th><th align="right">Parent type</th></tr></thead><tbody><tr><td align="right">Generic ring <script type="math/tex">R</script></td><td align="right">Nemo</td><td align="right"><code>GenRelSeries{T}</code></td><td align="right"><code>GenRelSeriesRing{T}</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{Z}</script></td><td align="right">Flint</td><td align="right"><code>fmpz_rel_series</code></td><td align="right"><code>FmpzRelSeriesRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script></td><td align="right">Flint</td><td align="right"><code>fmpz_mod_rel_series</code></td><td align="right"><code>FmpzModRelSeriesRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{Q}</script></td><td align="right">Flint</td><td align="right"><code>fmpq_rel_series</code></td><td align="right"><code>FmpqRelSerieRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{F}_{p^n}</script> (small <script type="math/tex">n</script>)</td><td align="right">Flint</td><td align="right"><code>fq_nmod_rel_series</code></td><td align="right"><code>FqNmodRelSeriesRing</code></td></tr><tr><td align="right"><script type="math/tex">\mathbb{F}_{p^n}</script> (large <script type="math/tex">n</script>)</td><td align="right">Flint</td><td align="right"><code>fq_rel_series</code></td><td align="right"><code>FqRelSeriesRing</code></td></tr></tbody></table><p>The maximum relative precision, the string representation of the variable and the base ring <script type="math/tex">R</script> of a generic power series are stored in its parent object. </p><p>All power series element types belong to the abstract type <code>SeriesElem</code> and all of the power series ring types belong to the abstract type <code>SeriesRing</code>. This enables one to write generic functions that can accept any Nemo power series type.</p><p><a id="Capped-relative-power-series-1"></a></p><h2 id="capped-relative-power-series">Capped relative power series</h2><p>Capped relative power series have their maximum relative precision capped at some value <code>prec_max</code>. This means that if the leading term of a nonzero power series element is <script type="math/tex">c_ax^a</script> and the precision is <script type="math/tex">b</script> then the power series is of the form  <script type="math/tex">c_ax^a + c_{a+1}x^{a+1} + \ldots + O(x^{a + b})</script>.</p><p>The zero power series is simply taken to be <script type="math/tex">0 + O(x^b)</script>.</p><p>The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series <script type="math/tex">f</script> and <script type="math/tex">g</script> we have that <code>divexact(f*g), g) == f</code>.</p><p>However, capped relative power series are not additively stable, i.e. we do not always have <script type="math/tex">(f + g) - g = f</script>.</p><p>In the capped relative model we say that two power series are equal if they agree up to the minimum <em>absolute</em> precision of the two power series. Thus, for example, <script type="math/tex">x^5 + O(x^10) == 0 + O(x^5)</script>, since the minimum absolute precision is <script type="math/tex">5</script>.</p><p>During computations, it is possible for power series to lose relative precision due to cancellation. For example if <script type="math/tex">f = x^3 + x^5 + O(x^8)</script> and <script type="math/tex">g = x^3 + x^6 + O(x^8)</script> then <script type="math/tex">f - g = x^5 - x^6 + O(x^8)</script> which now has relative precision <script type="math/tex">3</script> instead of relative precision <script type="math/tex">5</script>.</p><p>Amongst other things, this means that equality is not transitive. For example <script type="math/tex">x^6 + O(x^11) == 0 + O(x^5)</script> and <script type="math/tex">x^7 + O(x^12) == 0 + O(x^5)</script> but <script type="math/tex">x^6 + O(x^11) \neq x^7 + O(x^12)</script>.</p><p>Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the <code>isequal</code> function.</p><p>For example, if <script type="math/tex">f = x^2 + O(x^7)</script> and <script type="math/tex">g = x^2 + O(x^8)</script> and <script type="math/tex">h = 0 + O(x^2)</script> then <script type="math/tex">f == g</script>, <script type="math/tex">f == h</script> and <script type="math/tex">g == h</script>, but <code>isequal(f, g)</code>, <code>isequal(f, h)</code> and <code>isequal(g, h)</code> would all return <code>false</code>. However, if <script type="math/tex">k = x^2 + O(x^7)</script> then <code>isequal(f, k)</code> would return <code>true</code>.</p><p>There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in <script type="math/tex">y</script> over the power series ring in <script type="math/tex">x</script> over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of <script type="math/tex">(0 + O(x^10))y + (1 + O(x^10))</script>?</p><p>If one takes it to be <script type="math/tex">(0 + O(x^10))</script> then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.</p><p>On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!</p><p>One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.</p><p>Simply increasing the precision will not necessarily give a "more correct" answer and some computations may not even terminate due to the presence of arithmetic zeroes!</p><p><a id="Power-series-ring-constructors-1"></a></p><h2 id="power-series-ring-constructors">Power series ring constructors</h2><p>In order to construct power series in Nemo, one must first construct the power series ring itself. This is accomplished with the following constructor.</p><pre><code>PowerSeriesRing(::Ring, ::Int, ::AbstractString{}, ::Bool)
</code></pre><p>Here are some examples of creating a power series ring using the constructor and using the resulting parent object to coerce various elements into the power series ring.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = S(x)
b = S(t + 1)
c = S(1)
d = S(ZZ(2))
f = S()
</code></pre><p><a id="Power-series-element-constructors-1"></a></p><h2 id="power-series-element-constructors">Power series element constructors</h2><p>Once a power series ring is constructed, there are various ways to construct power series in that ring.</p><p>The easiest way is simply using the generator returned by the <code>PowerSeriesRing</code> constructor and and build up the power series using basic arithmetic. The absolute precision of a power series can be set using the following function.</p><p><a href="#Nemo.O-Tuple{Nemo.SeriesElem{T}}" id="Nemo.O-Tuple{Nemo.SeriesElem{T}}">#</a><strong><code>Nemo.O</code></strong> — <em>Method</em>.</p><pre><code>O{T}(a::SeriesElem{T})
</code></pre><blockquote><p>Returns <script type="math/tex">0 + O(x^\mbox{deg}(a))</script>. Usually this function is called with <script type="math/tex">x^n</script> as parameter. Then the function returns the power series <script type="math/tex">0 + O(x^n)</script>, which can be used to set the precision of a power series when constructing it.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L16" target="_blank">source</a><br/></p><p>In addition we provide the following functions for constructing certain useful polynomials.</p><p><a href="#Base.zero-Tuple{Nemo.SeriesRing}" id="Base.zero-Tuple{Nemo.SeriesRing}">#</a><strong><code>Base.zero</code></strong> — <em>Method</em>.</p><pre><code>zero(R::SeriesRing)
</code></pre><blockquote><p>Return <script type="math/tex">0 + O(x^n)</script> where <script type="math/tex">n</script> is the maximum precision of the power series ring <script type="math/tex">R</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L108" target="_blank">source</a><br/></p><p><a href="#Base.one-Tuple{Nemo.SeriesRing}" id="Base.one-Tuple{Nemo.SeriesRing}">#</a><strong><code>Base.one</code></strong> — <em>Method</em>.</p><pre><code>zero(R::SeriesRing)
</code></pre><blockquote><p>Return <script type="math/tex">1 + O(x^n)</script> where <script type="math/tex">n</script> is the maximum precision of the power series ring <script type="math/tex">R</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L115" target="_blank">source</a><br/></p><p><a href="#Nemo.gen-Tuple{Nemo.SeriesRing}" id="Nemo.gen-Tuple{Nemo.SeriesRing}">#</a><strong><code>Nemo.gen</code></strong> — <em>Method</em>.</p><pre><code>zero(R::SeriesRing)
</code></pre><blockquote><p>Return the generator of the power series ring, i.e. <script type="math/tex">x + O(x^{n + 1})</script> where <script type="math/tex">n</script> is the maximum precision of the power series ring <script type="math/tex">R</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L122" target="_blank">source</a><br/></p><p>Here are some examples of constructing power series.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = x^3 + 2x + 1
b = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)
c = zero(S)
d = one(S)
f = gen(S)
</code></pre><p><a id="Basic-functionality-1"></a></p><h2 id="basic-functionality">Basic functionality</h2><p>All power series modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)</p><p>Developers who are writing their own power series module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom power series types in Nemo. </p><p>We write <code>U</code> for the type of the power series in the power series ring and <code>T</code> for the type of elements of the coefficient ring.</p><p>All of these functions are provided for all existing power series types in Nemo.</p><pre><code>parent_type{U &lt;: SeriesElem}(::Type{U})
</code></pre><p>Given the type of power series elements, should return the type of the corresponding parent object.</p><pre><code>elem_type(R::SeriesRing)
</code></pre><p>Given a parent object for the power series ring, return the type of elements of the power series ring.</p><pre><code>Base.hash(a::SeriesElem, h::UInt)
</code></pre><p>Return a <code>UInt</code> hexadecimal hash of the power series <script type="math/tex">a</script>. This should be xor'd with a fixed random hexadecimal specific to the power series type. The hash of each coefficient should be xor'd with the supplied parameter <code>h</code> as part of computing the hash.</p><pre><code>fit!(a::SeriesElem, n::Int)
</code></pre><p>By reallocating if necessary, ensure that the polynomial underlying the given power series has space for at least <script type="math/tex">n</script> coefficients. This function does not change the length of the power series and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.</p><pre><code>normalise(a::SeriesElem, n::Int)
</code></pre><p>Return the normalised length of the polynomial underlying the given power series, assuming its current length is <script type="math/tex">n</script>. Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the power series. That can be done with a subsequent call to <code>set_length!</code> using the length returned by <code>normalise</code>.</p><pre><code>set_length!(a::SeriesElem, n::Int)
</code></pre><p>Set the length of the polynomial underlying a power series assuming it has sufficient space allocated, i.e. a power series for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial power series type has a field, <code>length</code>, which corresponds to the current length of the polynomial underlying a power series, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.</p><pre><code>length(a::SeriesElem)
</code></pre><p>Return the current length (not the number of allocated coefficients), of the polynomial underlying the given power series. Note that this function only needs to be provided by a developer for a custom power series type if the Julia type definition the power series type doesn't contain a field <code>length</code> corresponding to the current length of the polynomial underlying the power series. Otherwise the supplied generic implementation will work.</p><pre><code>set_prec!(a::SeriesElem, n::Int)
</code></pre><p>Set the precision of the given power series to <script type="math/tex">n</script>. Note this function only needs to be provided by a developer for a custom power series type if the Julia type definition of the power series type doesn't contain a field <code>prec</code> corresponding to the current precision of the power series. Otherwise the supplied generic implementation will work.</p><pre><code>precision(a::SeriesElem)
</code></pre><p>Return the current precision of the given power series. This function does not have to be provided by a developer of a custom power series type if the Julia type definition of the power series type contains a field <code>prec</code> corresponding to the current precision of the power series. In this case the supplied generic implementation will work. Note that for convenience, the precision is stored as an absolute precision.</p><pre><code>coeff(a::SeriesElem, n::Int)
</code></pre><p>Return the degree <script type="math/tex">n</script> coefficient of the given power series. Note coefficients are numbered from <script type="math/tex">n = 0</script> for the constant coefficient. If <script type="math/tex">n</script> exceeds the current precision of the power series, the function returns a zero coefficient. We require <script type="math/tex">n \geq 0</script>. </p><pre><code>setcoeff!{T &lt;: RingElem}(a::SeriesElem{T}, n::Int, c::T)
</code></pre><p>Set the coefficient of the degree <script type="math/tex">n</script> term of the given power series to the given value <script type="math/tex">a</script>. The polynomial underlying the power series is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.</p><pre><code>deepcopy(a::SeriesElem)
</code></pre><p>Construct a copy of the given power series and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo power series are mutable and so returning shallow copies is not sufficient.</p><pre><code>mul!(c::SeriesElem, a::SeriesElem, b::SeriesElem)
</code></pre><p>Multiply <script type="math/tex">a</script> by <script type="math/tex">b</script> and set the existing power series <script type="math/tex">c</script> to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.</p><pre><code>addeq!(c::SeriesElem, a::SeriesElem)
</code></pre><p>In-place addition. Adds <script type="math/tex">a</script> to <script type="math/tex">c</script> and sets <script type="math/tex">c</script> to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.</p><p>Given a parent object <code>S</code> for a power series ring, the following coercion functions are provided to coerce various elements into the power series ring. Developers provide these by overloading the <code>call</code> operator for the polynomial parent objects.</p><pre><code>S()
</code></pre><p>Coerce zero into the ring <script type="math/tex">S</script>.</p><pre><code>S(n::Integer)
S(n::fmpz)
</code></pre><p>Coerce an integer value or Flint integer into the power series ring <script type="math/tex">S</script>.</p><pre><code>S(n::T)
</code></pre><p>Coerces an element of the base ring, of type <code>T</code> into <script type="math/tex">S</script>.</p><pre><code>S(A::Array{T, 1}, len::Int, prec::Int)
</code></pre><p>Take an array of elements in the base ring, of type <code>T</code> and construct the power series with those coefficients. The length of the underlying polynomial and the precision of the power series will be set to the given values.</p><pre><code>S(f::SeriesElem)
</code></pre><p>Take a power series that is already in the ring <script type="math/tex">S</script> and simply return it. A copy of the original is not made.</p><pre><code>S(c::RingElem)
</code></pre><p>Try to coerce the given ring element into the power series ring. This only succeeds if <script type="math/tex">c</script> can be coerced into the base ring.</p><p>In addition to the above, developers of custom power series must ensure the parent object of a power series type constains a field <code>base_ring</code> specifying the base ring, a field <code>S</code> containing a symbol (not a string) representing the variable name of the power series ring and a field <code>max_prec</code> specifying the maximum relative precision of the power series. They must also ensure that each power series element contains a field <code>parent</code> specifying the parent object of the power series.</p><p>Typically a developer will also overload the <code>PowerSeriesRing</code> generic function to create power series of the custom type they are implementing.</p><p><a id="Basic-manipulation-1"></a></p><h2 id="basic-manipulation">Basic manipulation</h2><p>Numerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.</p><p><a href="#Nemo.base_ring-Tuple{Nemo.SeriesRing}" id="Nemo.base_ring-Tuple{Nemo.SeriesRing}">#</a><strong><code>Nemo.base_ring</code></strong> — <em>Method</em>.</p><pre><code>base_ring(R::SeriesRing)
</code></pre><blockquote><p>Return the base ring of the given power series ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L38" target="_blank">source</a><br/></p><p><a href="#Nemo.base_ring-Tuple{Nemo.SeriesElem}" id="Nemo.base_ring-Tuple{Nemo.SeriesElem}">#</a><strong><code>Nemo.base_ring</code></strong> — <em>Method</em>.</p><pre><code>base_ring(a::SeriesElem)
</code></pre><blockquote><p>Return the base ring of the power series ring of the given power series.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L44" target="_blank">source</a><br/></p><p><a href="#Base.parent-Tuple{Nemo.SeriesElem}" id="Base.parent-Tuple{Nemo.SeriesElem}">#</a><strong><code>Base.parent</code></strong> — <em>Method</em>.</p><pre><code>parent(a::SeriesElem)
</code></pre><blockquote><p>Return the parent of the given power series.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L30" target="_blank">source</a><br/></p><p><a href="#Base.var-Tuple{Nemo.SeriesRing}" id="Base.var-Tuple{Nemo.SeriesRing}">#</a><strong><code>Base.var</code></strong> — <em>Method</em>.</p><pre><code>var(a::SeriesRing)
</code></pre><blockquote><p>Return the internal name of the generator of the power series ring. Note that this is returned as a <code>Symbol</code> not a <code>String</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L50" target="_blank">source</a><br/></p><p><a href="#Nemo.valuation-Tuple{Nemo.SeriesElem}" id="Nemo.valuation-Tuple{Nemo.SeriesElem}">#</a><strong><code>Nemo.valuation</code></strong> — <em>Method</em>.</p><pre><code>valuation(a::SeriesElem)
</code></pre><blockquote><p>Return the valuation of the given power series, i.e. the degree of the first nonzero term (or the precision if it is arithmetically zero).</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L165" target="_blank">source</a><br/></p><p><a href="#Nemo.max_precision-Tuple{Nemo.SeriesRing}" id="Nemo.max_precision-Tuple{Nemo.SeriesRing}">#</a><strong><code>Nemo.max_precision</code></strong> — <em>Method</em>.</p><pre><code>max_precision(R::SeriesRing)
</code></pre><blockquote><p>Return the maximum relative precision of power series in the given power series ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L81" target="_blank">source</a><br/></p><p><a href="#Nemo.modulus-Tuple{Nemo.SeriesElem{T&lt;:Nemo.ResElem}}" id="Nemo.modulus-Tuple{Nemo.SeriesElem{T&lt;:Nemo.ResElem}}">#</a><strong><code>Nemo.modulus</code></strong> — <em>Method</em>.</p><pre><code>modulus{T &lt;: ResElem}(a::SeriesElem{T})
</code></pre><blockquote><p>Return the modulus of the coefficients of the given polynomial.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L182" target="_blank">source</a><br/></p><p><a href="#Nemo.iszero-Tuple{Nemo.SeriesElem}" id="Nemo.iszero-Tuple{Nemo.SeriesElem}">#</a><strong><code>Nemo.iszero</code></strong> — <em>Method</em>.</p><pre><code>iszero(a::SeriesElem)
</code></pre><blockquote><p>Return <code>true</code> if the given power series is arithmetically equal to zero to its current precision, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L132" target="_blank">source</a><br/></p><p><a href="#Nemo.isone-Tuple{Nemo.SeriesElem}" id="Nemo.isone-Tuple{Nemo.SeriesElem}">#</a><strong><code>Nemo.isone</code></strong> — <em>Method</em>.</p><pre><code>isone(a::SeriesElem)
</code></pre><blockquote><p>Return <code>true</code> if the given power series is arithmetically equal to one to its current precision, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L139" target="_blank">source</a><br/></p><p><a href="#Nemo.isgen-Tuple{Nemo.SeriesElem}" id="Nemo.isgen-Tuple{Nemo.SeriesElem}">#</a><strong><code>Nemo.isgen</code></strong> — <em>Method</em>.</p><pre><code>isgen(a::SeriesElem)
</code></pre><blockquote><p>Return <code>true</code> if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L148" target="_blank">source</a><br/></p><p><a href="#Nemo.isunit-Tuple{Nemo.SeriesElem}" id="Nemo.isunit-Tuple{Nemo.SeriesElem}">#</a><strong><code>Nemo.isunit</code></strong> — <em>Method</em>.</p><pre><code>isunit(a::SeriesElem)
</code></pre><blockquote><p>Return <code>true</code> if the given power series is arithmetically equal to a unit, i.e. is invertible, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L158" target="_blank">source</a><br/></p><p>Here are some examples of basic manipulation of power series.</p><pre><code>R, t = PowerSeriesRing(QQ, 10, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = O(x^4)
b = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)

c = gen(R)
d = zero(R)
f = one(S)

g = iszero(d)
h = isone(f)
k = isgen(c)
m = isunit(-1 + x + 2x^2)
n = valuation(a)
p = valuation(b)
s = var(S)
U = base_ring(S)
V = base_ring(t)
W = parent(t + 1)
</code></pre><p><a id="Arithmetic-operators-1"></a></p><h2 id="arithmetic-operators">Arithmetic operators</h2><p>All the usual arithmetic operators are overloaded for Nemo power series. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use <code>divexact</code>. To construct an element of a fraction field one can use the double slash operator <code>//</code>.</p><p>The following operators and functions are provided.</p><table><thead><tr><th align="right">Function</th><th align="right">Operation</th></tr></thead><tbody><tr><td align="right"><code>-(a::SeriesElem)</code></td><td align="right">unary minus</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})</code></td><td align="right">addition</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>divexact{T &lt;: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})</code></td><td align="right">exact division</td></tr></tbody></table><p>The following ad hoc operators are also provided.</p><table><thead><tr><th align="right">Function</th><th align="right">Operation</th></tr></thead><tbody><tr><td align="right"><code>+(a::Integer, b::SeriesElem)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::SeriesElem, b::Integer)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::fmpz, b::SeriesElem)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::SeriesElem, b::fmpz)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::T, b::SeriesElem{T})</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::SeriesElem{T}, b::T)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>-(a::Integer, b::SeriesElem)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::SeriesElem, b::Integer)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::fmpz, b::SeriesElem)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::SeriesElem, b::fmpz)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::T, b::SeriesElem{T})</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::SeriesElem{T}, b::T)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>*(a::Integer, b::SeriesElem)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::SeriesElem, b::Integer)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::fmpz, b::SeriesElem)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::SeriesElem, b::fmpz)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::T, b::SeriesElem{T})</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::SeriesElem{T}, b::T)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>divexact(a::SeriesElem, b::Integer)</code></td><td align="right">exact division</td></tr><tr><td align="right"><code>divexact(a::SeriesElem, b::fmpz)</code></td><td align="right">exact division</td></tr><tr><td align="right"><code>divexact{T &lt;: RingElem}(a::SeriesElem{T}, b::T)</code></td><td align="right">exact division</td></tr><tr><td align="right"><code>^(a::SeriesElem, n::Int)</code></td><td align="right">powering</td></tr></tbody></table><p>If the appropriate <code>promote_rule</code> and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.</p><p>Here are some examples of arithmetic operations on power series.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = x^2 + 3x^3 - x^4

f = -a
g = a + b
h = a - c
k = b*c
m = a*c
n = a*d
p = 2a
q = fmpz(3)*b
r = c*2
s = d*fmpz(3)
t = a^12
u = divexact(b, c)
v = divexact(a, 7)
w = divexact(b, fmpz(11))
</code></pre><p><a id="Comparison-operators-1"></a></p><h2 id="comparison-operators">Comparison operators</h2><p>The following comparison operators are implemented for power series in Nemo. Julia provides the corresponding <code>!=</code> function automatically.</p><p><a id="Function-1"></a></p><h2 id="function">Function</h2><p><code>isequal{T &lt;: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})</code><code>=={T &lt;: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})</code></p><p>The <code>isequal</code> function is a stronger notion of equality. It requires that the precision of the power series is identical as well as the power series being arithmetically equal. Coefficients are also compared using <code>isequal</code> recursively. The <code>==</code> function notionally truncates both power series to the lower of the two (absolute) precisions, and then compares arithmetically.</p><p>In addition we have the following ad hoc comparison operators.</p><p><a id="Function-2"></a></p><h2 id="function_1">Function</h2><p><code>=={T &lt;: RingElem}(a::SeriesElem{T}, b::T)</code><code>=={T &lt;: RingElem}(a::T, b::SeriesElem{T})</code><code>==(a::SeriesElem, b::Integer)</code><code>==(a::Integer, b::SeriesElem)</code><code>==(a::SeriesElem, b::fmpz)</code><code>==(a::fmpz, b::SeriesElem)</code></p><p>Here are some examples of comparisons.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^3)
c = 1 + x + 3x^2 + O(x^5)
d = 3x^3 - x^4

a == 2x + x^3
b == d
c != d
isequal(b, d)
d == 3
c == fmpz(1)
fmpz(0) != a
2 == b
fmpz(1) == c
</code></pre><p><a id="Shifting-1"></a></p><h2 id="shifting">Shifting</h2><pre><code>shift_left(::SeriesElem, ::Int)
</code></pre><pre><code>shift_right(::SeriesElem, ::Int)
</code></pre><p>Here are some examples of shifting.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = shift_left(a, 2)
g = shift_left(b, 2)
h = shift_right(c, 1)
k = shift_right(d, 3)
</code></pre><p><a id="Truncation-1"></a></p><h2 id="truncation">Truncation</h2><pre><code>truncate(::SeriesElem, ::Int)
</code></pre><p>Here are some examples of truncation.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = truncate(a, 3)
g = truncate(b, 2)
h = truncate(c, 7)
k = truncate(d, 5)
</code></pre><p><a id="Inverse-1"></a></p><h2 id="inverse">Inverse</h2><p><a href="#Base.inv-Tuple{Nemo.SeriesElem}" id="Base.inv-Tuple{Nemo.SeriesElem}">#</a><strong><code>Base.inv</code></strong> — <em>Method</em>.</p><p>inv(a::SeriesElem)</p><blockquote><p>Return the inverse of the power series <script type="math/tex">a</script>, i.e. <script type="math/tex">1/a</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L864" target="_blank">source</a><br/></p><p>Here are some examples of taking the inverse.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 1 + x + 2x^2 + O(x^5)
b = S(-1)

c = inv(a)
d = inv(b)
</code></pre><p><a id="Special-functions-1"></a></p><h2 id="special-functions">Special functions</h2><p><a href="#Base.exp-Tuple{Nemo.SeriesElem}" id="Base.exp-Tuple{Nemo.SeriesElem}">#</a><strong><code>Base.exp</code></strong> — <em>Method</em>.</p><pre><code>exp(a::SeriesElem)
</code></pre><blockquote><p>Return the exponential of the power series <script type="math/tex">a</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/generic/RelSeries.jl#L896" target="_blank">source</a><br/></p><p>The following special functions are only available for certain rings.</p><p><a href="#Base.log-Tuple{Nemo.fmpq_rel_series}" id="Base.log-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.log</code></strong> — <em>Method</em>.</p><p>log(a::fmpq_rel_series)</p><blockquote><p>Return log<script type="math/tex">(a)</script>. Requires the constant term to be one.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L464" target="_blank">source</a><br/></p><p><a href="#Base.sqrt-Tuple{Nemo.fmpq_rel_series}" id="Base.sqrt-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.sqrt</code></strong> — <em>Method</em>.</p><p>sqrt(a::fmpq_rel_series)</p><blockquote><p>Return the power series square root of <script type="math/tex">a</script>. Requires a constant term equal to one.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L651" target="_blank">source</a><br/></p><p><a href="#Base.tan-Tuple{Nemo.fmpq_rel_series}" id="Base.tan-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.tan</code></strong> — <em>Method</em>.</p><p>tan(a::fmpq_rel_series)</p><blockquote><p>Return tan<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L481" target="_blank">source</a><br/></p><p><a href="#Base.tanh-Tuple{Nemo.fmpq_rel_series}" id="Base.tanh-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.tanh</code></strong> — <em>Method</em>.</p><p>tanh(a::fmpq_rel_series)</p><blockquote><p>Return tanh<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L498" target="_blank">source</a><br/></p><p><a href="#Base.sin-Tuple{Nemo.fmpq_rel_series}" id="Base.sin-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.sin</code></strong> — <em>Method</em>.</p><p>sin(a::fmpq_rel_series)</p><blockquote><p>Return sin<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L515" target="_blank">source</a><br/></p><p><a href="#Base.sinh-Tuple{Nemo.fmpq_rel_series}" id="Base.sinh-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.sinh</code></strong> — <em>Method</em>.</p><p>sinh(a::fmpq_rel_series)</p><blockquote><p>Return sinh<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L532" target="_blank">source</a><br/></p><p><a href="#Base.cos-Tuple{Nemo.fmpq_rel_series}" id="Base.cos-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.cos</code></strong> — <em>Method</em>.</p><p>cos(a::fmpq_rel_series)</p><blockquote><p>Return cos<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L549" target="_blank">source</a><br/></p><p><a href="#Base.cosh-Tuple{Nemo.fmpq_rel_series}" id="Base.cosh-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.cosh</code></strong> — <em>Method</em>.</p><p>cosh(a::fmpq_rel_series)</p><blockquote><p>Return cosh<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L566" target="_blank">source</a><br/></p><p><a href="#Base.asin-Tuple{Nemo.fmpq_rel_series}" id="Base.asin-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.asin</code></strong> — <em>Method</em>.</p><p>asin(a::fmpq_rel_series)</p><blockquote><p>Return asin<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L583" target="_blank">source</a><br/></p><p><a href="#Base.asinh-Tuple{Nemo.fmpq_rel_series}" id="Base.asinh-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.asinh</code></strong> — <em>Method</em>.</p><p>asinh(a::fmpq_rel_series)</p><blockquote><p>Return asinh<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L600" target="_blank">source</a><br/></p><p><a href="#Base.atan-Tuple{Nemo.fmpq_rel_series}" id="Base.atan-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.atan</code></strong> — <em>Method</em>.</p><p>atan(a::fmpq_rel_series)</p><blockquote><p>Return atan<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L617" target="_blank">source</a><br/></p><p><a href="#Base.atanh-Tuple{Nemo.fmpq_rel_series}" id="Base.atanh-Tuple{Nemo.fmpq_rel_series}">#</a><strong><code>Base.atanh</code></strong> — <em>Method</em>.</p><p>atanh(a::fmpq_rel_series)</p><blockquote><p>Return atanh<script type="math/tex">(a)</script>. Requires a zero constant term.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/a7e680756720736fbf3d66de5eb23a88117eb2fa/src/flint/fmpq_rel_series.jl#L634" target="_blank">source</a><br/></p><p>Here are some examples of special functions.</p><pre><code>R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")
T, z = PowerSeriesRing(QQ, 30, "z")

a = 1 + z + 3z^2 + O(z^5)
b = z + 2z^2 + 5z^3 + O(z^5)

c = exp(x + O(x^40))
d = divexact(x, exp(x + O(x^40)) - 1)
f = exp(b)
g = log(a)
h = sqrt(a)
k = sin(b)
m = atanh(b)
</code></pre></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a class="btn btn-neutral float-right" href="../residue/" title="Residue rings">Next <span class="icon icon-circle-arrow-right"></span></a><a class="btn btn-neutral" href="../polynomial/" title="Univariate polynomials"><span class="icon icon-circle-arrow-left"></span> Previous</a></div><hr/><div role="contentinfo"></div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer></div></div></section></div><div class="rst-versions" role="note" style="cursor: pointer"><span class="rst-current-version" data-toggle="rst-current-version"><a class="icon icon-github" href="https://github.com/Nemocas/Nemo.jl" style="float: left; color: #fcfcfc"> GitHub</a><span><a href="../polynomial/" style="color: #fcfcfc;">« Previous</a></span><span style="margin-left: 15px"><a href="../residue/" style="color: #fcfcfc">Next »</a></span></span></div></body></HTML>