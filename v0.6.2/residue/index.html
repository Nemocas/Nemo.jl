<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="X-UA-Compatible"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="William Hart" name="author"/><link href="../img/favicon.ico" rel="shortcut icon"/><title>Residue rings - Nemo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css"/><link href="../css/theme.css" rel="stylesheet" type="text/css"/><link href="../css/theme_extra.css" rel="stylesheet" type="text/css"/><link href="../css/highlight.css" rel="stylesheet"/><link href="../assets/Documenter.css" rel="stylesheet"/><script>
    // Current page data
    var mkdocs_page_name = "Residue rings";
    var mkdocs_page_input_path = "residue.md";
    var mkdocs_page_url = "/residue/";
  </script><script src="../js/jquery-2.1.1.min.js"></script><script src="../js/modernizr-2.8.3.min.js"></script><script src="../js/highlight.pack.js" type="text/javascript"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift"><div class="wy-side-nav-search"><a class="icon icon-home" href=".."> Nemo.jl</a><div role="search"><form action="../search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="" href="..">Getting Started</a></li><li class="toctree-l1"><a class="" href="../about/">About Nemo</a></li><li class="toctree-l1"><a class="" href="../types/">Types in Nemo</a></li><li class="toctree-l1"><a class="" href="../constructors/">Parent object constructors</a></li><li class="toctree-l1"><a class="" href="../polynomial/">Univariate polynomials</a></li><li class="toctree-l1"><a class="" href="../series/">Capped relative power series</a></li><li class="toctree-l1 current"><a class="current" href="./">Residue rings</a><ul class="subnav"><li class="toctree-l2"><a href="#introduction">Introduction</a></li><li class="toctree-l2"><a href="#residue-ring-constructors">Residue ring constructors</a></li><li class="toctree-l2"><a href="#residue-element-constructors">Residue element constructors</a></li><li class="toctree-l2"><a href="#basic-functionality">Basic functionality</a></li><li class="toctree-l2"><a href="#basic-manipulation">Basic manipulation</a></li><li class="toctree-l2"><a href="#arithmetic-operators">Arithmetic operators</a></li><li class="toctree-l2"><a href="#comparison-operators">Comparison operators</a></li><li class="toctree-l2"><a href="#function">Function</a></li><li class="toctree-l2"><a href="#function_1">Function</a></li><li class="toctree-l2"><a href="#inversion">Inversion</a></li><li class="toctree-l2"><a href="#greatest-common-divisor">Greatest common divisor</a></li></ul></li><li class="toctree-l1"><a class="" href="../fraction/">Fraction fields</a></li><li class="toctree-l1"><a class="" href="../matrix/">Matrices</a></li><li class="toctree-l1"><a class="" href="../integer/">Integers</a></li><li class="toctree-l1"><a class="" href="../rational/">Rationals</a></li><li class="toctree-l1"><a class="" href="../finitefield/">Finite fields</a></li><li class="toctree-l1"><a class="" href="../padic/">P-adic fields</a></li><li class="toctree-l1"><a class="" href="../arb/">Real balls</a></li><li class="toctree-l1"><a class="" href="../acb/">Complex boxes</a></li><li class="toctree-l1"><a class="" href="../numberfield/">Number fields</a></li><li class="toctree-l1"><a class="" href="../maximalorder/">Maximal orders</a></li><li class="toctree-l1"><a class="" href="../classgroup/">Class groups</a></li><li class="toctree-l1"><a class="" href="../perm/">Permutation groups</a></li><li class="toctree-l1"><a class="" href="../factor/">Factorization</a></li></ul></div>
       
    </nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="..">Nemo.jl</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="..">Docs</a> »</li><li>Residue rings</li><li class="wy-breadcrumbs-aside"><a class="icon icon-github" href="https://github.com/Nemocas/Nemo.jl/edit/master/docs/residue.md"> Edit on GitHub</a></li></ul><hr/></div><div role="main"><div class="section"><p><a id="Introduction-1"></a></p><h2 id="introduction">Introduction</h2><p>Nemo allows the creation of residue rings of the form <script type="math/tex">R/(a)</script> for an element <script type="math/tex">a</script> of a ring <script type="math/tex">R</script>.</p><p>We don't require <script type="math/tex">(a)</script> to be a prime or maximal ideal. Instead, we allow the creation of the residue ring <script type="math/tex">R/(a)</script> for any nonzero <script type="math/tex">a</script> and simply raise an exception if an impossible inverse is encountered during computations  involving elements of <script type="math/tex">R/(a)</script>.</p><p>There is a generic implementation of residue rings of this form in Nemo, which accepts any ring <script type="math/tex">R</script> as base ring. The associated types of parent object and elements in such residue rings are given in the following table.</p><table><thead><tr><th align="right">Base ring</th><th align="right">Library</th><th align="right">Element type</th><th align="right">Parent type</th></tr></thead><tbody><tr><td align="right">Generic ring <script type="math/tex">R</script></td><td align="right">Nemo</td><td align="right"><code>GenRes{T}</code></td><td align="right"><code>GeResRing{T}</code></td></tr></tbody></table><p>The modulus <script type="math/tex">a</script> of a residue ring is stored in its parent object.</p><p>All residue element types belong to the abstract type <code>ResElem</code> and all the residue ring parent object types belong to the abstract type <code>ResRing</code>. This enables one to write generic functions that accept any Nemo residue type.</p><p><a id="Residue-ring-constructors-1"></a></p><h2 id="residue-ring-constructors">Residue ring constructors</h2><p>In order to construct residues in Nemo, one must first construct the residue ring itself. This is accomplished with the following constructor.</p><p><a href="#Nemo.ResidueRing-Tuple{Nemo.Ring,T&lt;:Nemo.RingElem}" id="Nemo.ResidueRing-Tuple{Nemo.Ring,T&lt;:Nemo.RingElem}">#</a><strong><code>Nemo.ResidueRing</code></strong> — <em>Method</em>.</p><pre><code>ResidueRing{T &lt;: RingElem}(R::Ring, a::T; cached=true)
</code></pre><blockquote><p>Create the residue ring <script type="math/tex">R/(a)</script> where <script type="math/tex">a</script> is an element of the ring <script type="math/tex">R</script>. We require <script type="math/tex">a \neq 0</script>. If <code>cached == true</code> (the default) then the resulting residue ring parent object is cached and returned for any subsequent calls to the constructor with the same base ring <script type="math/tex">R</script> and element <script type="math/tex">a</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L573" target="_blank">source</a><br/></p><p>Here are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into those rings.</p><pre><code>R = ResidueRing(ZZ, 17)
S, x = PolynomialRing(QQ, "x")
T = ResidueRing(S, x^2 + 1)

a = R(11)
b = T(x)
c = T(ZZ(3))
</code></pre><p><a id="Residue-element-constructors-1"></a></p><h2 id="residue-element-constructors">Residue element constructors</h2><p>Once a residue ring is constructed, there are various ways to construct residues in that ring.</p><p>Apart from coercing elements into the residue ring as above, we offer the following functions.</p><p><a href="#Base.zero-Tuple{Nemo.ResRing}" id="Base.zero-Tuple{Nemo.ResRing}">#</a><strong><code>Base.zero</code></strong> — <em>Method</em>.</p><pre><code>zero(R::ResRing)
</code></pre><blockquote><p>Return the zero element of the given residue ring, i.e. <script type="math/tex">0 \pmod{a}</script> where <script type="math/tex">a</script> is the modulus of the residue ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L79" target="_blank">source</a><br/></p><p><a href="#Base.one-Tuple{Nemo.ResRing}" id="Base.one-Tuple{Nemo.ResRing}">#</a><strong><code>Base.one</code></strong> — <em>Method</em>.</p><pre><code>zero(R::ResRing)
</code></pre><blockquote><p>Return <script type="math/tex">1 \pmod{a}</script> where <script type="math/tex">a</script> is the modulus of the residue ring.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L86" target="_blank">source</a><br/></p><p>Here are some examples of constructing residues.</p><pre><code>R = ResidueRing(ZZ, 16453889)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

g = zero(R)
h = one(T)
</code></pre><p><a id="Basic-functionality-1"></a></p><h2 id="basic-functionality">Basic functionality</h2><p>All residue ring modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)</p><p>Developers who are writing their own residue ring module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom residue ring types in Nemo. </p><p>We write <code>U</code> for the type of residue elements in the residue ring and <code>T</code> for the type of elements of the base ring.</p><p>All of these functions are provided for all existing residue types in Nemo.</p><pre><code>parent_type{U &lt;: ResElem}(::Type{U})
</code></pre><p>Given the type of residue elements, should return the type of the corresponding parent object.</p><pre><code>elem_type(R::ResRing)
</code></pre><p>Given a parent object for the residue ring, return the type of elements of the residue ring.</p><pre><code>Base.hash(a::ResElem, h::UInt)
</code></pre><p>Return a <code>UInt</code> hexadecimal hash of the residue <script type="math/tex">a</script>. This should be xor'd with a fixed random hexadecimal specific to the residue type. The hash of the data associated with a residue should be xor'd with the supplied parameter <code>h</code> as part of computing the hash.</p><pre><code>data(a::ResElem)
</code></pre><p>Return the data of the given residue element, i.e. for <script type="math/tex">c \pmod{a}</script> in the ring <script type="math/tex">R/(a)</script> return the value <script type="math/tex">c</script> as an element of the ring <script type="math/tex">R</script>.</p><pre><code>deepcopy(a::ResElem)
</code></pre><p>Construct a copy of the given residue and return it. This function must recursively construct copies of all of the internal data in the given residue. Nemo residues are mutable and so returning shallow copies is not sufficient.</p><pre><code>mul!(c::ResElem, a::ResElem, b::ResElem)
</code></pre><p>Multiply <script type="math/tex">a</script> by <script type="math/tex">b</script> and set the existing residue <script type="math/tex">c</script> to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.</p><pre><code>addeq!(c::ResElem, a::ResElem)
</code></pre><p>In-place addition. Adds <script type="math/tex">a</script> to <script type="math/tex">c</script> and sets <script type="math/tex">c</script> to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.</p><p>Given a parent object <code>S</code> for a residue ring, the following coercion functions are provided to coerce various elements into the residue ring. Developers provide these by overloading the <code>call</code> operator for the residue ring parent objects.</p><pre><code>S()
</code></pre><p>Coerce zero into the ring <script type="math/tex">S</script>.</p><pre><code>S(n::Integer)
S(n::fmpz)
</code></pre><p>Coerce an integer value or Flint integer into the residue ring <script type="math/tex">S</script>.</p><pre><code>S(n::T)
</code></pre><p>Coerces an element of the base ring, of type <code>T</code> into <script type="math/tex">S</script>.</p><pre><code>S(f::ResElem)
</code></pre><p>Take a residue that is already in the ring <script type="math/tex">S</script> and simply return it. A copy of the original is not made.</p><pre><code>S(c::RingElem)
</code></pre><p>Try to coerce the given ring element into the residue ring. This only succeeds if <script type="math/tex">c</script> can be coerced into the base ring.</p><p>In addition to the above, developers of custom residues must ensure the parent object of a residue type constains a field <code>base_ring</code> specifying the base ring, a field <code>modulus</code> containing the modulus <script type="math/tex">a</script> of the residue ring <script type="math/tex">R/(a)</script>. They must also ensure that each residue element contains a field <code>parent</code> specifying the parent object of the residue.</p><p>Typically a developer will also overload the <code>ResidueRing</code> generic function to create residues of the custom type they are implementing.</p><p><a id="Basic-manipulation-1"></a></p><h2 id="basic-manipulation">Basic manipulation</h2><p>Numerous functions are provided to manipulate residues. Also see the section on basic functionality above.</p><pre><code>base_ring(::ResRing)
</code></pre><p><a href="#Nemo.base_ring-Tuple{Nemo.ResElem}" id="Nemo.base_ring-Tuple{Nemo.ResElem}">#</a><strong><code>Nemo.base_ring</code></strong> — <em>Method</em>.</p><pre><code>base_ring(r::ResElem)
</code></pre><blockquote><p>Return the base ring <script type="math/tex">R</script> of the residue ring <script type="math/tex">R/(a)</script> that the supplied element <script type="math/tex">r</script> belongs to.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L25" target="_blank">source</a><br/></p><p><a href="#Base.parent-Tuple{Nemo.ResElem}" id="Base.parent-Tuple{Nemo.ResElem}">#</a><strong><code>Base.parent</code></strong> — <em>Method</em>.</p><pre><code>parent(a::ResElem)
</code></pre><blockquote><p>Return the parent object of the given residue element.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L32" target="_blank">source</a><br/></p><p><a href="#Nemo.modulus-Tuple{Nemo.ResRing}" id="Nemo.modulus-Tuple{Nemo.ResRing}">#</a><strong><code>Nemo.modulus</code></strong> — <em>Method</em>.</p><pre><code>modulus(R::ResRing)
</code></pre><blockquote><p>Return the modulus <script type="math/tex">a</script> of the given residue ring <script type="math/tex">S = R/(a)</script>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L60" target="_blank">source</a><br/></p><p><a href="#Nemo.modulus-Tuple{Nemo.ResElem}" id="Nemo.modulus-Tuple{Nemo.ResElem}">#</a><strong><code>Nemo.modulus</code></strong> — <em>Method</em>.</p><pre><code>modulus(R::ResRing)
</code></pre><blockquote><p>Return the modulus <script type="math/tex">a</script> of the residue ring <script type="math/tex">S = R/(a)</script> that the supplied residue <script type="math/tex">r</script> belongs to.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L68" target="_blank">source</a><br/></p><p><a href="#Nemo.iszero-Tuple{Nemo.ResElem}" id="Nemo.iszero-Tuple{Nemo.ResElem}">#</a><strong><code>Nemo.iszero</code></strong> — <em>Method</em>.</p><pre><code>iszero(a::ResElem)
</code></pre><blockquote><p>Return <code>true</code> if the supplied element <script type="math/tex">a</script> is zero in the residue ring it belongs to, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L92" target="_blank">source</a><br/></p><p><a href="#Nemo.isone-Tuple{Nemo.ResElem}" id="Nemo.isone-Tuple{Nemo.ResElem}">#</a><strong><code>Nemo.isone</code></strong> — <em>Method</em>.</p><pre><code>isone(a::ResElem)
</code></pre><blockquote><p>Return <code>true</code> if the supplied element <script type="math/tex">a</script> is one in the residue ring it belongs to, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L99" target="_blank">source</a><br/></p><p><a href="#Nemo.isunit-Tuple{Nemo.ResElem}" id="Nemo.isunit-Tuple{Nemo.ResElem}">#</a><strong><code>Nemo.isunit</code></strong> — <em>Method</em>.</p><pre><code>iszero(a::ResElem)
</code></pre><blockquote><p>Return <code>true</code> if the supplied element <script type="math/tex">a</script> is invertible in the residue ring it belongs to, otherwise return <code>false</code>.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L106" target="_blank">source</a><br/></p><p>Here are some examples of basic manipulation of residues.</p><pre><code>R = ResidueRing(ZZ, 16453889)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

g = zero(R)
h = one(T)

a = modulus(R)
b = modulus(T(x + 1))
c = isunit(h)
d = isone(h)
f = iszero(g)
U = parent(g)
V = base_ring(R)
W = base_ring(T(x + 1))
</code></pre><p><a id="Arithmetic-operators-1"></a></p><h2 id="arithmetic-operators">Arithmetic operators</h2><p>All the usual arithmetic operators are overloaded for Nemo residues. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use <code>divexact</code>. To construct an element of a fraction field one can use the double slash operator <code>//</code>.</p><p>The following operators and functions are provided.</p><table><thead><tr><th align="right">Function</th><th align="right">Operation</th></tr></thead><tbody><tr><td align="right"><code>-(a::ResElem)</code></td><td align="right">unary minus</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::ResElem{T}, b::ResElem{T})</code></td><td align="right">addition</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::ResElem{T}, b::ResElem{T})</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::ResElem{T}, b::ResElem{T})</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>divexact{T &lt;: RingElem}(a::ResElem{T}, b::ResElem{T})</code></td><td align="right">exact division</td></tr></tbody></table><p>The following ad hoc operators are also provided.</p><table><thead><tr><th align="right">Function</th><th align="right">Operation</th></tr></thead><tbody><tr><td align="right"><code>+(a::Integer, b::ResElem)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::ResElem, b::Integer)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::fmpz, b::ResElem)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+(a::ResElem, b::fmpz)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::T, b::ResElem{T})</code></td><td align="right">addition</td></tr><tr><td align="right"><code>+{T &lt;: RingElem}(a::ResElem{T}, b::T)</code></td><td align="right">addition</td></tr><tr><td align="right"><code>-(a::Integer, b::ResElem)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::ResElem, b::Integer)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::fmpz, b::ResElem)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-(a::ResElem, b::fmpz)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::T, b::ResElem{T})</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>-{T &lt;: RingElem}(a::ResElem{T}, b::T)</code></td><td align="right">subtraction</td></tr><tr><td align="right"><code>*(a::Integer, b::ResElem)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::ResElem, b::Integer)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::fmpz, b::ResElem)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*(a::ResElem, b::fmpz)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::T, b::ResElem{T})</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>*{T &lt;: RingElem}(a::ResElem{T}, b::T)</code></td><td align="right">multiplication</td></tr><tr><td align="right"><code>^(a::ResElem, n::Int)</code></td><td align="right">powering</td></tr></tbody></table><p>If the appropriate <code>promote_rule</code> and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.</p><p>Here are some examples of arithmetic operations on residues.</p><pre><code>R = ResidueRing(ZZ, 16453889)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = R(4)
g = R(6)
n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

a = -R(12345)
b = -T(x^5 + 1)
c = f + g
d = f - g
h = f*g
k = n + p
l = n - p
m = n*p
q = divexact(a*b, a)
r = divexact(n*p, p)
s = f + 3
t = 3 - g
u = 5g
v = n + 4
w = 4 - p
y = n*5
z = p^12
</code></pre><p><a id="Comparison-operators-1"></a></p><h2 id="comparison-operators">Comparison operators</h2><p>The following comparison operators are implemented for residues in Nemo. Julia provides the corresponding <code>!=</code> operator automatically.</p><p><a id="Function-1"></a></p><h2 id="function">Function</h2><p><code>isequal{T &lt;: RingElem}(a::ResElem{T}, b::ResElem{T})</code><code>=={T &lt;: RingElem}(a::ResElem{T}, b::ResElem{T})</code></p><p>The <code>isequal</code> operation returns <code>true</code> if and only if residues are precisely equal as compared by <code>isequal</code>. This is a stronger form of equality, used for comparing inexact ring elements, such as elements of a power series ring, the <script type="math/tex">p</script>-adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal. </p><p>In addition we have the following ad hoc comparison operators.</p><p><a id="Function-2"></a></p><h2 id="function_1">Function</h2><p><code>=={T &lt;: RingElem}(a::ResElem{T}, b::T)</code><code>=={T &lt;: RingElem}(a::T, b::ResElem{T})</code><code>==(a::ResElem, b::Integer)</code><code>==(a::Integer, b::ResElem)</code><code>==(a::ResElem, b::fmpz)</code><code>==(a::fmpz, b::ResElem)</code></p><p>Here are some examples of comparisons.</p><pre><code>R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

a = R(3)
b = a
c = R(2)
f = T(x^5 + 1)
g = 8f
h = f + g

b == a
c != a
f == g
h != g
isequal(f, g)
a == 3
4 != a
f != 5
</code></pre><p><a id="Inversion-1"></a></p><h2 id="inversion">Inversion</h2><p><a href="#Base.inv-Tuple{Nemo.ResElem}" id="Base.inv-Tuple{Nemo.ResElem}">#</a><strong><code>Base.inv</code></strong> — <em>Method</em>.</p><pre><code>inv(a::ResElem)
</code></pre><blockquote><p>Return the inverse of the element <script type="math/tex">a</script> in the residue ring. If an impossible inverse is encountered, an exception is raised.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L423" target="_blank">source</a><br/></p><p>Here are some examples of computing inverses.</p><pre><code>R = ResidueRing(ZZ, 49)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

a = R(5)
f = T(x^5 + 1)

b = inv(a)
g = inv(f)
</code></pre><p><a id="Greatest-common-divisor-1"></a></p><h2 id="greatest-common-divisor">Greatest common divisor</h2><p><a href="#Base.gcd-Tuple{Nemo.ResElem{T&lt;:Nemo.RingElem},Nemo.ResElem{T&lt;:Nemo.RingElem}}" id="Base.gcd-Tuple{Nemo.ResElem{T&lt;:Nemo.RingElem},Nemo.ResElem{T&lt;:Nemo.RingElem}}">#</a><strong><code>Base.gcd</code></strong> — <em>Method</em>.</p><pre><code>gcd{T &lt;: RingElem}(a::ResElem{T}, b::ResElem{T})
</code></pre><blockquote><p>Return a greatest common divisor of <script type="math/tex">a</script> and <script type="math/tex">b</script> if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.</p></blockquote><p><a class="documenter-source" href="https://github.com/Nemocas/Nemo.jl/tree/331f82ab5c3c0a9028ff2c535cfb93b94c3cd1ff/src/generic/Residue.jl#L466" target="_blank">source</a><br/></p><p>Here are some examples of computing a greatest common divisor.</p><pre><code>R = ResidueRing(ZZ, 43)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 - 2x + 1)

a = R(5)
b = R(7)
c = T(x^5 + 1)
d = T(x^2 + x)

f = gcd(a, b)
g = gcd(c, d)
</code></pre></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a class="btn btn-neutral float-right" href="../fraction/" title="Fraction fields">Next <span class="icon icon-circle-arrow-right"></span></a><a class="btn btn-neutral" href="../series/" title="Capped relative power series"><span class="icon icon-circle-arrow-left"></span> Previous</a></div><hr/><div role="contentinfo"></div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer></div></div></section></div><div class="rst-versions" role="note" style="cursor: pointer"><span class="rst-current-version" data-toggle="rst-current-version"><a class="fa fa-github" href="https://github.com/Nemocas/Nemo.jl" style="float: left; color: #fcfcfc"> GitHub</a><span><a href="../series/" style="color: #fcfcfc;">« Previous</a></span><span style="margin-left: 15px"><a href="../fraction/" style="color: #fcfcfc">Next »</a></span></span></div><script src="../js/theme.js"></script><script src="../mathjaxhelper.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script></body></HTML>