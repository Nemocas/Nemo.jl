<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Integers · Nemo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>Nemo.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="about.html">About Nemo</a></li><li><a class="toctext" href="types.html">Types in Nemo</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in Nemo</a></li><li><span class="toctext">Rings</span><ul><li class="current"><a class="toctext" href="integer.html">Integers</a><ul class="internal"><li><a class="toctext" href="#Integer-functionality-1">Integer functionality</a></li></ul></li><li><a class="toctext" href="polynomial.html">Univariate polynomials</a></li><li><a class="toctext" href="series.html">Power series and Laurent series</a></li><li><a class="toctext" href="puiseux.html">Puiseux series</a></li><li><a class="toctext" href="residue.html">Residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="fraction.html">Fraction fields</a></li><li><a class="toctext" href="rational.html">Rationals</a></li><li><a class="toctext" href="arb.html">Real balls</a></li><li><a class="toctext" href="acb.html">Complex balls</a></li><li><a class="toctext" href="gfp.html">Galois fields</a></li><li><a class="toctext" href="finitefield.html">Finite fields</a></li><li><a class="toctext" href="numberfield.html">Number field arithmetic</a></li><li><a class="toctext" href="padic.html">Padics</a></li></ul></li><li><a class="toctext" href="matrix.html">Matrices</a></li><li><a class="toctext" href="factor.html">Factorisation</a></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href="integer.html">Integers</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/integer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Integers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Integers-1" id="Integers-1">Integers</a></h1><p>The default integer type in Nemo is provided by Flint. The associated ring of integers is represented by the constant parent object called <code>FlintZZ</code>.</p><p>For convenience we define</p><pre><code class="language-none">ZZ = FlintZZ</code></pre><p>so that integers can be constructed using <code>ZZ</code> instead of <code>FlintZZ</code>. Note that this is the name of a specific parent object, not the name of its type.</p><p>The types of the integer ring parent objects and elements of the associated rings of integers are given in the following table according to the library provding them.</p><table><tbody><tr><th>Library</th><th>Element type</th><th>Parent type</th></tr><tr><td>Flint</td><td><code>fmpz</code></td><td><code>FlintIntegerRing</code></td></tr></tbody></table><p>All integer element types belong directly to the abstract type <code>RingElem</code> and all the integer ring parent object types belong to the abstract type <code>Ring</code>.</p><h2><a class="nav-anchor" href="#Integer-functionality-1" id="Integer-functionality-1">Integer functionality</a></h2><p>Nemo integers implement the whole of the ring and Euclidean ring interfaces of AbstractAlgebra.jl.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/rings.html">https://nemocas.github.io/AbstractAlgebra.jl/rings.html</a></p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html">https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html</a></p><p>Below, we describe the functionality that is specific to the Nemo/Flint integer ring.</p><h3><a class="nav-anchor" href="#Constructors-1" id="Constructors-1">Constructors</a></h3><pre><code class="language-julia">ZZ(n::Integer)</code></pre><p>Coerce a Julia integer value into the integer ring.</p><pre><code class="language-julia">ZZ(n::String)</code></pre><p>Parse the given string as an integer.</p><pre><code class="language-julia">ZZ(n::Float64)
ZZ(n::Float32)
ZZ(n::Float16)
ZZ(n::BigFloat)</code></pre><p>Coerce the given floating point number into the integer ring, assuming that it can be exactly represented as an integer.</p><h3><a class="nav-anchor" href="#Basic-manipulation-1" id="Basic-manipulation-1">Basic manipulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.isunit-Tuple{fmpz}" id="AbstractAlgebra.Generic.isunit-Tuple{fmpz}"><code>AbstractAlgebra.Generic.isunit</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isunit(a::fmpz)</code></pre><blockquote><p>Return <code>true</code> if the given integer is a unit, i.e. <span>$\pm 1$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.sign-Tuple{fmpz}" id="Base.sign-Tuple{fmpz}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sign(a::fmpz)</code></pre><blockquote><p>Returns the sign of <span>$a$</span>, i.e. <span>$+1$</span>, <span>$0$</span> or <span>$-1$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.size-Tuple{fmpz}" id="Base.size-Tuple{fmpz}"><code>Base.size</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">size(a::fmpz)</code></pre><blockquote><p>Returns the number of limbs required to store the absolute value of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.fits-Tuple{Type{UInt64},fmpz}" id="Nemo.fits-Tuple{Type{UInt64},fmpz}"><code>Nemo.fits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fits(::Type{UInt}, a::fmpz)</code></pre><blockquote><p>Returns <code>true</code> if the given integer fits into a <code>UInt</code>, otherwise returns <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.fits-Tuple{Type{Int64},fmpz}" id="Nemo.fits-Tuple{Type{Int64},fmpz}"><code>Nemo.fits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fits(::Type{Int}, a::fmpz)</code></pre><blockquote><p>Returns <code>true</code> if the given integer fits into an <code>Int</code>, otherwise returns <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.denominator-Tuple{fmpz}" id="Base.denominator-Tuple{fmpz}"><code>Base.denominator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">denominator(a::fmpz)</code></pre><blockquote><p>Returns the denominator of <span>$a$</span> thought of as a rational. Always returns <span>$1$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.numerator-Tuple{fmpz}" id="Base.numerator-Tuple{fmpz}"><code>Base.numerator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">numerator(a::fmpz)</code></pre><blockquote><p>Returns the numerator of <span>$a$</span> thought of as a rational. Always returns <span>$a$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-none">a = ZZ(12)

isunit(a)
sign(a)
s = size(a)
fits(Int, a)
n = numerator(a)
d = denominator(a)</code></pre><h3><a class="nav-anchor" href="#Euclidean-division-1" id="Euclidean-division-1">Euclidean division</a></h3><p>Nemo also provides a large number of Euclidean division operations. Recall that for a dividend <span>$a$</span> and divisor <span>$b$</span>, we can write <span>$a = bq + r$</span> with <span>$0 \leq |r| &lt; |b|$</span>. We call <span>$q$</span> the quotient and <span>$r$</span> the remainder.</p><p>We distinguish three cases. If <span>$q$</span> is rounded towards zero, <span>$r$</span> will have the same sign as <span>$a$</span>. If <span>$q$</span> is rounded towards plus infinity, <span>$r$</span> will have the opposite sign to <span>$b$</span>. Finally, if <span>$q$</span> is rounded towards minus infinity, <span>$r$</span> will have the same sign as <span>$b$</span>.</p><p>In the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with <span>$q$</span> representing return of the quotient and <span>$r$</span> representing return of the remainder.</p><table><tbody><tr><th>Function</th><th>Return</th><th>Rounding</th></tr><tr><td><code>divrem(a::fmpz, b::fmpz)</code></td><td>q, r</td><td>towards zero</td></tr><tr><td><code>tdivrem(a::fmpz, b::fmpz)</code></td><td>q, r</td><td>towards zero</td></tr><tr><td><code>fdivrem(a::fmpz, b::fmpz)</code></td><td>q, r</td><td>towards minus infinity</td></tr></tbody></table><p>Nemo also offers the following ad hoc division operators. The notation and description is as for the other Euclidean division functions.</p><table><tbody><tr><th>Function</th><th>Return</th><th>Rounding</th></tr><tr><td><code>rem(a::fmpz, b::Int)</code></td><td>r</td><td>towards zero</td></tr><tr><td><code>div(a::fmpz, b::Int)</code></td><td>q</td><td>towards zero</td></tr><tr><td><code>tdiv(a::fmpz, b::Int)</code></td><td>q</td><td>towards zero</td></tr><tr><td><code>fdiv(a::fmpz, b::Int)</code></td><td>q</td><td>towards minus infinity</td></tr><tr><td><code>cdiv(a::fmpz, b::Int)</code></td><td>q</td><td>towards plus infinity</td></tr></tbody></table><p>The following functions are also available, for the case where one is dividing by a power of <span>$2$</span>. In other words, for Euclidean division of the form <span>$a = b2^{d} + r$</span>. These are useful for bit twiddling.</p><table><tbody><tr><th>Function</th><th>Return</th><th>Rounding</th></tr><tr><td><code>tdivpow2(a::fmpz, d::Int)</code></td><td>q</td><td>towards zero</td></tr><tr><td><code>fdivpow2(a::fmpz, d::Int)</code></td><td>q</td><td>towards minus infinity</td></tr><tr><td><code>fmodpow2(a::fmpz, d::Int)</code></td><td>r</td><td>towards minus infinity</td></tr><tr><td><code>cdivpow2(a::fmpz, d::Int)</code></td><td>q</td><td>towards plus infinity</td></tr></tbody></table><p><strong>Examples</strong></p><pre><code class="language-julia">a = fmpz(12)
b = fmpz(5)

q, r = divrem(a, b)
c = cdiv(a, b)
d = fdiv(a, b)
f = tdivpow2(a, 2)
g = fmodpow2(a, 3)</code></pre><h3><a class="nav-anchor" href="#Comparison-1" id="Comparison-1">Comparison</a></h3><p>Instead of <code>isless</code> we implement a function <code>cmp(a, b)</code> which returns a positive value if <span>$a &gt; b$</span>, zero if <span>$a == b$</span> and a negative value if <span>$a &lt; b$</span>. We then implement all the other operators, including <code>==</code> in terms of <code>cmp</code>.</p><p>For convenience we also implement a <code>cmpabs(a, b)</code> function which returns a positive value if <span>$|a| &gt; |b|$</span>, zero if <span>$|a| == |b|$</span> and a negative value if <span>$|a| &lt; |b|$</span>. This can be slightly faster than a call to <code>cmp</code> or one of the comparison operators when comparing nonnegative values for example.</p><p>Here is a list of the comparison functions implemented, with the understanding that <code>cmp</code> provides all of the comparison operators listed above.</p><table><tbody><tr><th>Function</th></tr><tr><td><code>cmp(a::fmpz, b::fmpz)</code></td></tr><tr><td><code>cmpabs(a::fmpz, b::fmpz)</code></td></tr></tbody></table><p>We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.</p><table><tbody><tr><th>Function</th></tr><tr><td><code>cmp(a::fmpz, b::Int)</code></td></tr><tr><td><code>cmp(a::Int, b::fmpz)</code></td></tr><tr><td><code>cmp(a::fmpz, b::UInt)</code></td></tr><tr><td><code>cmp(a::UInt, b::fmpz)</code></td></tr></tbody></table><p><strong>Examples</strong></p><pre><code class="language-julia">a = ZZ(12)
b = ZZ(3)

a &lt; b
a != b
a &gt; 4
5 &lt;= b
cmpabs(a, b)</code></pre><h3><a class="nav-anchor" href="#Shifting-1" id="Shifting-1">Shifting</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.:&lt;&lt;-Tuple{fmpz,Int64}" id="Base.:&lt;&lt;-Tuple{fmpz,Int64}"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&lt;&lt;(x::fmpz, c::Int)</code></pre><blockquote><p>Return <span>$2^cx$</span> where <span>$c \geq 0$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.:&gt;&gt;-Tuple{fmpz,Int64}" id="Base.:&gt;&gt;-Tuple{fmpz,Int64}"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&gt;&gt;(x::fmpz, c::Int)</code></pre><blockquote><p>Return <span>$x/2^c$</span>, discarding any remainder, where <span>$c \geq 0$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = fmpz(12)

a &lt;&lt; 3
a &gt;&gt; 5</code></pre><h3><a class="nav-anchor" href="#Modular-arithmetic-1" id="Modular-arithmetic-1">Modular arithmetic</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.sqrtmod-Tuple{fmpz,fmpz}" id="Nemo.sqrtmod-Tuple{fmpz,fmpz}"><code>Nemo.sqrtmod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sqrtmod(x::fmpz, m::fmpz)</code></pre><blockquote><p>Return a square root of <span>$x (\mod m)$</span> if one exists. The remainder will be in the range <span>$[0, m)$</span>. We require that <span>$m$</span> is prime, otherwise the algorithm may not terminate.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.crt-Tuple{fmpz,fmpz,fmpz,fmpz,Bool}" id="AbstractAlgebra.crt-Tuple{fmpz,fmpz,fmpz,fmpz,Bool}"><code>AbstractAlgebra.crt</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, signed=false)</code></pre><blockquote><p>Find <span>$r$</span> such that <span>$r \equiv r_1 (\mod m_1)$</span> and <span>$r \equiv r_2 (\mod m_2)$</span>. If <code>signed = true</code>, <span>$r$</span> will be in the range <span>$-m_1m_2/2 &lt; r \leq m_1m_2/2$</span>. If <code>signed = false</code> the value will be in the range <span>$0 \leq r &lt; m_1m_2$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.crt-Tuple{fmpz,fmpz,Int64,Int64,Bool}" id="AbstractAlgebra.crt-Tuple{fmpz,fmpz,Int64,Int64,Bool}"><code>AbstractAlgebra.crt</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">crt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, signed=false)</code></pre><blockquote><p>Find <span>$r$</span> such that <span>$r \equiv r_1 (\mod m_1)$</span> and <span>$r \equiv r_2 (\mod m_2)$</span>. If <code>signed = true</code>, <span>$r$</span> will be in the range <span>$-m_1m_2/2 &lt; r \leq m_1m_2/2$</span>. If <code>signed = false</code> the value will be in the range <span>$0 \leq r &lt; m_1m_2$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">c = sqrtmod(ZZ(12), ZZ(13))
d = crt(ZZ(5), ZZ(13), ZZ(7), ZZ(37), true)</code></pre><h3><a class="nav-anchor" href="#Integer-logarithm-1" id="Integer-logarithm-1">Integer logarithm</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.flog-Tuple{fmpz,fmpz}" id="Nemo.flog-Tuple{fmpz,fmpz}"><code>Nemo.flog</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">flog(x::fmpz, c::fmpz)</code></pre><blockquote><p>Return the floor of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.flog-Tuple{fmpz,Int64}" id="Nemo.flog-Tuple{fmpz,Int64}"><code>Nemo.flog</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">flog(x::fmpz, c::Int)</code></pre><blockquote><p>Return the floor of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.clog-Tuple{fmpz,fmpz}" id="Nemo.clog-Tuple{fmpz,fmpz}"><code>Nemo.clog</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">clog(x::fmpz, c::fmpz)</code></pre><blockquote><p>Return the ceiling of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.clog-Tuple{fmpz,Int64}" id="Nemo.clog-Tuple{fmpz,Int64}"><code>Nemo.clog</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">clog(x::fmpz, c::Int)</code></pre><blockquote><p>Return the ceiling of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = fmpz(12)
b = fmpz(2)

c = flog(a, b)
d = clog(a, 3)</code></pre><h3><a class="nav-anchor" href="#Integer-roots-1" id="Integer-roots-1">Integer roots</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.isqrt-Tuple{fmpz}" id="Base.isqrt-Tuple{fmpz}"><code>Base.isqrt</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isqrt(x::fmpz)</code></pre><blockquote><p>Return the floor of the square root of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.isqrtrem-Tuple{fmpz}" id="Nemo.isqrtrem-Tuple{fmpz}"><code>Nemo.isqrtrem</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isqrtrem(x::fmpz)</code></pre><blockquote><p>Return a tuple <span>$s, r$</span> consisting of the floor <span>$s$</span> of the square root of <span>$x$</span> and the remainder <span>$r$</span>, i.e. such that <span>$x = s^2 + r$</span>. We require <span>$x \geq 0$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.root-Tuple{fmpz,Int64}" id="Nemo.root-Tuple{fmpz,Int64}"><code>Nemo.root</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">root(x::fmpz, n::Int)</code></pre><blockquote><p>Return the floor of the <span>$n$</span>-the root of <span>$x$</span>. We require <span>$n &gt; 0$</span> and that <span>$x \geq 0$</span> if <span>$n$</span> is even.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = ZZ(13)

b = sqrt(a)
s, r = sqrtrem(a)
c = root(a, 3)</code></pre><h3><a class="nav-anchor" href="#Number-theoretic-functionality-1" id="Number-theoretic-functionality-1">Number theoretic functionality</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.divisible-Tuple{fmpz,Int64}" id="Nemo.divisible-Tuple{fmpz,Int64}"><code>Nemo.divisible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">divisible(x::fmpz, y::Int)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is divisible by <span>$y$</span>, otherwise return <code>false</code>. We require <span>$x \neq 0$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.divisible-Tuple{fmpz,fmpz}" id="Nemo.divisible-Tuple{fmpz,fmpz}"><code>Nemo.divisible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">divisible(x::fmpz, y::fmpz)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is divisible by <span>$y$</span>, otherwise return <code>false</code>. We require <span>$x \neq 0$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.issquare-Tuple{fmpz}" id="AbstractAlgebra.Generic.issquare-Tuple{fmpz}"><code>AbstractAlgebra.Generic.issquare</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issquare(x::fmpz)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is a square, otherwise return <code>false</code>.</p></blockquote></div></section><pre><code class="language-none">isprime(::fmpz)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.isprobabprime-Tuple{fmpz}" id="Nemo.isprobabprime-Tuple{fmpz}"><code>Nemo.isprobabprime</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isprobabprime(x::fmpz)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is a very probably a prime number, otherwise return <code>false</code>. No counterexamples are known to this test, but it is conjectured that infinitely many exist.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.factor-Tuple{fmpz}" id="Nemo.factor-Tuple{fmpz}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(a::fmpz)</code></pre><blockquote><p>Return a factorisation of <span>$a$</span> using a <code>Fac</code> struct (see the documentation on factorisation in Nemo.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.divisor_lenstra-Tuple{fmpz,fmpz,fmpz}" id="Nemo.divisor_lenstra-Tuple{fmpz,fmpz,fmpz}"><code>Nemo.divisor_lenstra</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)</code></pre><blockquote><p>If <span>$n$</span> has a factor which lies in the residue class <span>$r (\mod m)$</span> for <span>$0 &lt; r &lt; m &lt; n$</span>, this function returns such a factor. Otherwise it returns <span>$0$</span>. This is only efficient if <span>$m$</span> is at least the cube root of <span>$n$</span>. We require gcd<span>$(r, m) = 1$</span> and this condition is not checked.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.fac-Tuple{Int64}" id="Nemo.fac-Tuple{Int64}"><code>Nemo.fac</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fac(x::Int)</code></pre><blockquote><p>Return the factorial of <span>$x$</span>, i.e. <span>$x! = 1.2.3\ldots x$</span>. We require <span>$x \geq 0$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.risingfac-Tuple{fmpz,Int64}" id="Nemo.risingfac-Tuple{fmpz,Int64}"><code>Nemo.risingfac</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">risingfac(x::fmpz, y::Int)</code></pre><blockquote><p>Return the rising factorial of <span>$x$</span>, i.e. <span>$x(x + 1)(x + 2)\ldots (x + n - 1)$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.risingfac-Tuple{Int64,Int64}" id="Nemo.risingfac-Tuple{Int64,Int64}"><code>Nemo.risingfac</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">risingfac(x::Int, y::Int)</code></pre><blockquote><p>Return the rising factorial of <span>$x$</span>, i.e. <span>$x(x + 1)(x + 2)\ldots (x + n - 1)$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.primorial-Tuple{Int64}" id="Nemo.primorial-Tuple{Int64}"><code>Nemo.primorial</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">primorial(x::Int)</code></pre><blockquote><p>Return the primorial of <span>$n$</span>, i.e. the product of all primes less than or equal to <span>$n$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.fib-Tuple{Int64}" id="Nemo.fib-Tuple{Int64}"><code>Nemo.fib</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fib(x::Int)</code></pre><blockquote><p>Return the <span>$n$</span>-th Fibonacci number <span>$F_n$</span>. We define <span>$F_1 = 1$</span>, <span>$F_2 = 1$</span> and <span>$F_{i + 1} = F_i + F_{i - 1}$</span> for all <span>$i &gt; 2$</span>. We require <span>$n \geq 0$</span>. For convenience, we define <span>$F_0 = 0$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.bell-Tuple{Int64}" id="Nemo.bell-Tuple{Int64}"><code>Nemo.bell</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bell(x::Int)</code></pre><blockquote><p>Return the Bell number <span>$B_n$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.binom-Tuple{Int64,Int64}" id="Nemo.binom-Tuple{Int64,Int64}"><code>Nemo.binom</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">binom(n::Int, k::Int)</code></pre><blockquote><p>Return the binomial coefficient <span>$\frac{n!}{(n - k)!k!}$</span>. If <span>$n, k &lt; 0$</span> or <span>$k &gt; n$</span> we return <span>$0$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.moebiusmu-Tuple{fmpz}" id="Nemo.moebiusmu-Tuple{fmpz}"><code>Nemo.moebiusmu</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">moebiusmu(x::fmpz)</code></pre><blockquote><p>Returns the Moebius mu function of <span>$x$</span> as an \code{Int}. The value returned is either <span>$-1$</span>, <span>$0$</span> or <span>$1$</span>. If <span>$x &lt; 0$</span> we throw a <code>DomainError()</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.jacobi-Tuple{fmpz,fmpz}" id="Nemo.jacobi-Tuple{fmpz,fmpz}"><code>Nemo.jacobi</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">jacobi(x::fmpz, y::fmpz)</code></pre><blockquote><p>Return the value of the Jacobi symbol <span>$\left(\frac{x}{y}\right)$</span>. If <span>$y \leq x$</span> or <span>$x &lt; 0$</span>, we throw a <code>DomainError()</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.sigma-Tuple{fmpz,Int64}" id="Nemo.sigma-Tuple{fmpz,Int64}"><code>Nemo.sigma</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sigma(x::fmpz, y::Int)</code></pre><blockquote><p>Return the value of the sigma function, i.e. <span>$\sum_{0 &lt; d \;| x} d^y$</span>. If <span>$y &lt; 0$</span> we throw a <code>DomainError()</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.eulerphi-Tuple{fmpz}" id="Nemo.eulerphi-Tuple{fmpz}"><code>Nemo.eulerphi</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eulerphi(x::fmpz)</code></pre><blockquote><p>Return the value of the Euler phi function at <span>$x$</span>, i.e. the number of positive integers less than <span>$x$</span> that are coprime with <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.numpart-Tuple{Int64}" id="Nemo.numpart-Tuple{Int64}"><code>Nemo.numpart</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">numpart(x::Int)</code></pre><blockquote><p>Return the number of partitions of <span>$x$</span>. This function is not available on Windows 64.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.numpart-Tuple{fmpz}" id="Nemo.numpart-Tuple{fmpz}"><code>Nemo.numpart</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">numpart(x::fmpz)</code></pre><blockquote><p>Return the number of partitions of <span>$x$</span>. This function is not available on Windows 64.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">isprime(ZZ(13))
n = fac(100)
s = sigma(ZZ(128), 10)
a = eulerphi(ZZ(12480))
p = numpart(1000)
f = factor(ZZ(12))</code></pre><h3><a class="nav-anchor" href="#Digits-and-bases-1" id="Digits-and-bases-1">Digits and bases</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.bin-Tuple{fmpz}" id="Base.bin-Tuple{fmpz}"><code>Base.bin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bin(n::fmpz)</code></pre><blockquote><p>Return <span>$n$</span> as a binary string.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.oct-Tuple{fmpz}" id="Base.oct-Tuple{fmpz}"><code>Base.oct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">oct(n::fmpz)</code></pre><blockquote><p>Return <span>$n$</span> as a octal string.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.dec-Tuple{fmpz}" id="Base.dec-Tuple{fmpz}"><code>Base.dec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dec(n::fmpz)</code></pre><blockquote><p>Return <span>$n$</span> as a decimal string.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.hex-Tuple{fmpz}" id="Base.hex-Tuple{fmpz}"><code>Base.hex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hex(n::fmpz) = base(n, 16)</code></pre><blockquote><p>Return <span>$n$</span> as a hexadecimal string.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.base-Tuple{fmpz,Integer}" id="Nemo.base-Tuple{fmpz,Integer}"><code>Nemo.base</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">base(n::fmpz, b::Integer)</code></pre><blockquote><p>Return <span>$n$</span> as a string in base <span>$b$</span>. We require <span>$2 \leq b \leq 62$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.ndigits-Tuple{fmpz,Integer}" id="Base.ndigits-Tuple{fmpz,Integer}"><code>Base.ndigits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ndigits(x::fmpz, b::Integer = 10)</code></pre><blockquote><p>Return the number of digits of <span>$x$</span> in the base <span>$b$</span> (default is <span>$b = 10$</span>).</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.nbits-Tuple{fmpz}" id="Nemo.nbits-Tuple{fmpz}"><code>Nemo.nbits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nbits(x::fmpz)</code></pre><blockquote><p>Return the number of binary bits of <span>$x$</span>. We return zero if <span>$x = 0$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = fmpz(12)

s1 = bin(a)
s2 = base(a, 13)
n1 = nbits(a)
n2 = ndigits(a, 3)</code></pre><h3><a class="nav-anchor" href="#Bit-twiddling-1" id="Bit-twiddling-1">Bit twiddling</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.popcount-Tuple{fmpz}" id="Nemo.popcount-Tuple{fmpz}"><code>Nemo.popcount</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">popcount(x::fmpz)</code></pre><blockquote><p>Return the number of ones in the binary representation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.prevpow2-Tuple{fmpz}" id="Nemo.prevpow2-Tuple{fmpz}"><code>Nemo.prevpow2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">prevpow2(x::fmpz)</code></pre><blockquote><p>Return the previous power of <span>$2$</span> up to including <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.nextpow2-Tuple{fmpz}" id="Nemo.nextpow2-Tuple{fmpz}"><code>Nemo.nextpow2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nextpow2(x::fmpz)</code></pre><blockquote><p>Return the next power of <span>$2$</span> that is at least <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.trailing_zeros-Tuple{fmpz}" id="Base.trailing_zeros-Tuple{fmpz}"><code>Base.trailing_zeros</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">trailing_zeros(x::fmpz)</code></pre><blockquote><p>Count the trailing zeros in the binary representation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.clrbit!-Tuple{fmpz,Int64}" id="Nemo.clrbit!-Tuple{fmpz,Int64}"><code>Nemo.clrbit!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">clrbit!(x::fmpz, c::Int)</code></pre><blockquote><p>Clear bit <span>$c$</span> of <span>$x$</span>, where the least significant bit is the <span>$0$</span>-th bit. Note that this function modifies its input in-place.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.setbit!-Tuple{fmpz,Int64}" id="Nemo.setbit!-Tuple{fmpz,Int64}"><code>Nemo.setbit!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setbit!(x::fmpz, c::Int)</code></pre><blockquote><p>Set bit <span>$c$</span> of <span>$x$</span>, where the least significant bit is the <span>$0$</span>-th bit. Note that this function modifies its input in-place.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Nemo.combit!-Tuple{fmpz,Int64}" id="Nemo.combit!-Tuple{fmpz,Int64}"><code>Nemo.combit!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">combit!(x::fmpz, c::Int)</code></pre><blockquote><p>Complement bit <span>$c$</span> of <span>$x$</span>, where the least significant bit is the <span>$0$</span>-th bit. Note that this function modifies its input in-place.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = fmpz(12)

p = popcount(a)
b = nextpow2(a)
combit!(a, 2)</code></pre><footer><hr/><a class="previous" href="constructors.html"><span class="direction">Previous</span><span class="title">Constructing mathematical objects in Nemo</span></a><a class="next" href="polynomial.html"><span class="direction">Next</span><span class="title">Univariate polynomials</span></a></footer></article></body></HTML>